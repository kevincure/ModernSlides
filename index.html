<!DOCTYPE html>
<!--
ModernSlides - Kevin Bryan - Nov 22 2025 update
============================
Details at https://github.com/kevincure/ModernSlides/

This is a single-file HTML application that creates an interactive slideshow system.
The application allows users to create, edit, and present slides using a simple 
text-based markup language.
-->
<html lang="en">
<head>
<meta charset="UTF-8" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ModernSlides</title>


<!--------------------------------------- RENDER MATH CORRECTLY --------------------------------------------------------->
<!-- MathJax -->
<script>
  window.MathJax = {
    tex: { 
      inlineMath: [["$", "$"], ["\\(", "\\)"]], 
      displayMath: [["$$", "$$"], ["\\[", "\\]"]], 
      processEscapes: true 
    },
    svg: { fontCache: "global" }
  };
</script>
<script id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>


<!---------------------------------------STYLESHEETS SHARED ACROSS FILES ------------------------------------------------>
<style id="core-styles"> 
/* ----------------------------- */
/* --- Core Style Variables --- */
/* ----------------------------- */
/* The given "theme" updates some of these styles, and is user controllable */

:root {
  --slide-base-font-size: 3cqw;
  --editor-bg-color: #fffff8;
  --editor-text-color: #1a1a1a;
  --editor-border-color: #d4d4d4;
  --editor-accent-color: #333333;
  --editor-accent-text-color: #ffffff;
  --editor-thumb-bg: #ffffff;
  --editor-thumb-selected-border: #333333;
  --editor-input-bg: #ffffff;
  --editor-input-text: #333333;
  --editor-input-border: #d4d4d4;
  --editor-ui-font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --editor-mono-font: "Courier New", monospace;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html, body { width:100%; height:100%; overflow:hidden; }

body {
  line-height: 1.5;
}

/* The entire scaling system is driven by the --base-font-size variable */
.presentation-scaler,
.slide-wrapper {
  container-type: inline-size;
  container-name: slideshow;
  /* This is the single master switch for all slide scaling */
  --base-font-size: var(--slide-base-font-size);
}

.deckbar-spacer {
  flex-grow: 1;
}

#editor button.primary-action {
  --editor-accent-color: #008000;
}

/* ----------------------------- */
/* --- Slideshow Layout --- */
/* ----------------------------- */

.slide {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.4s ease;
  background-position: center;
  background-size: cover;
  background-repeat: no-repeat;
}
.slide.active { opacity: 1; z-index: 1; }
.slide.hidden-in-presentation { display: none !important; }

.slide.is-fullscreen-image-slide {
  background-size: contain;
}
.slide.is-fullscreen-image-slide .slide-content {
  background-color: transparent !important;
}

.slide-header {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  padding: calc(var(--base-font-size) * 0.2);
  font-size: calc(var(--base-font-size) * 0.8);
}

.slide-content {
  width: 100%;
  height: 100%;
  padding: 4cqw;
  display: flex;
  position: relative;
  text-align: left;
}

.slide-content.has-background-image {
  background-color: var(--slide-content-bg-if-image);
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

.slide.is-fullscreen-image-slide .slide-content.has-background-image {
  background: transparent;
}

.slide-flow-content {
  width: 80%;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  min-height: 0;
  line-height: 1.6;
  --text-scale: 1;
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
}

.slide[style*="background-image"] .slide-content {
  background: var(--slide-content-bg-if-image);
}

.text-scale {
  display: block;
  width: 100%;
  align-self: stretch;
}

.slide-flow-content > .text-scale {
  align-self: stretch;
}

/* ----------------------------- */
/* --- Slide Typography --- */
/* ----------------------------- */

.slide-content h1 {
  font-size: calc(var(--base-font-size) * 2.33);
  line-height: 1.2;
  text-align: center;
  padding-bottom: calc(var(--base-font-size) * 0.25);
  margin-bottom: calc(var(--base-font-size) * 0.25);
  width: 100%;
}

.slide-content p {
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
  line-height: 1.6;
  margin-bottom: calc(var(--base-font-size) * 0.3);
  text-align: inherit;
  font-family: inherit;
  line-height: inherit;
  font-weight: inherit;
  font-style: inherit;
}

.slide-content .text-center { text-align: center; }

/* Alignment helpers used by <<<, |||, >>> markers */
.slide-content .ms-align-left,
.slide-content .ms-align-center,
.slide-content .ms-align-right {
  display: block;
  width: 100%;
}

/* Use !important so markers override directive defaults like .large/.small/.tiny */
.slide-content .ms-align-left  { text-align: left  !important; }
.slide-content .ms-align-center{ text-align: center!important; }
.slide-content .ms-align-right { text-align: right !important; }

.slide-content .large {
  --text-scale: 1.6;
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
  text-align: center;
  width: 100%;
}

.slide-content .large p {
  text-align: inherit;
  margin: calc(var(--base-font-size) * 0.5) auto;
}

.slide-content .small {
  --text-scale: 0.67;
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
  width: 100%;
}

.slide-content .tiny {
  --text-scale: 0.33;
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
  width: 100%;
}

.slide-content .notes {
  position: absolute;
  bottom: auto;
  top: calc(var(--base-font-size) * 1.2);
  right: calc(var(--base-font-size) * 0.6);
  width: calc(var(--base-font-size) * 6);
  font-size: calc(var(--base-font-size) * 0.7);
  line-height: 1.5;
}

.slide-content .notes p {
  font-size: calc(var(--base-font-size) * .5);
  margin-bottom: calc(var(--base-font-size) * .25);
}

/* --- BLOCKQUOTE COMPONENT --- */
.slide-content .blockquote {
  width: 100%;
  margin: calc(var(--base-font-size) * 0.5) 0;
  padding: 0;
  box-sizing: border-box;
}

/* Quote: Defaults to BigText size (scale 1.6) and Italic */
.slide-content .blockquote .quote-text {
  font-size: calc(var(--base-font-size) * 1.6);
  font-style: italic;
  line-height: 1.2;
  margin-bottom: calc(var(--base-font-size) * 0.4);
}

.slide-content .blockquote .quote-text p {
  font-size: inherit;
  line-height: inherit;
  margin: 0;
}

/* Source: Defaults to Regular size, Normal style, Right Aligned */
.slide-content .blockquote .quote-source {
  font-size: var(--base-font-size);
  font-style: normal;
  text-align: right;
  opacity: 0.85;
  margin-top: 0;
}

.slide-content .blockquote .quote-source p {
  font-size: inherit;
  line-height: inherit;
  margin: 0;
}

/* ----------------------------- */
/* --- Columns, Tables, Images --- */
/* ----------------------------- */

.slide-content .columns {
  display: flex;
  gap: calc(var(--base-font-size) * 0.75);
  align-items: stretch;
  width: 100%;
  flex: 1;
  min-height: 0;
}

.slide-content .columns .column {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  justify-content: center;
  overflow: visible;
}

.slide-content .columns .column.column--double {
  flex: 2;
}

.slide-content .columns .column.images-only[data-imgcount]:not([data-imgcount="1"]) {
  justify-content: center;
}

.slide-content .columns .column.images-only > .img-container {
  margin: calc(var(--base-font-size) * 0.1) 0;
  flex: 1;
  min-height: 0;
}

.slide-content table {
  border-collapse: collapse;
  margin: calc(var(--base-font-size) * 0.5) auto;
  font-size: calc(var(--base-font-size) * 0.7);
}

.slide-content th, .slide-content td {
  border: 1px solid var(--h1-border-color);
  padding: calc(var(--base-font-size) * 0.3);
  text-align: left;
}

.slide-content .img-container {
  text-align: center;
  margin-bottom: calc(var(--base-font-size) * 0.5);
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex-shrink: 1;
  min-height: 0;
  overflow: visible;
  inline-size: 100%;
  block-size: 100%;
}

/* Two-way scaling: fill the box while preserving aspect */
.slide-content .img-container img,
.slide-content .column img {
  inline-size: 100%;
  block-size: 100%;
  object-fit: contain;
  display: block;
  margin: 0 auto calc(var(--base-font-size) * 0.2) auto;
}

.slide-content .caption {
  font-size: calc(var(--base-font-size) * 0.8);
  max-width: 90%;
  flex-shrink: 0;
  flex-grow: 0;
}

.slide-content .caption p {
  font-size: inherit;
  text-align: inherit;
  font-weight: inherit;
  font-style: inherit;
  margin: 0;
}

body.is-edit-mode .slide.has-overflow {
  outline: calc(var(--base-font-size) * 0.1) solid rgba(179, 38, 30, 0.6);
  outline-offset: calc(var(--base-font-size) * -0.05);
}

.overflow-indicator {
  position: absolute;
  left: 50%;
  bottom: calc(var(--base-font-size) * 0.6);
  transform: translateX(-50%);
  background: rgba(179, 38, 30, 0.9);
  color: #fff;
  padding: calc(var(--base-font-size) * 0.2) calc(var(--base-font-size) * 0.6);
  border-radius: calc(var(--base-font-size) * 0.2);
  font-size: calc(var(--base-font-size) * 0.4);
  text-align: center;
  max-width: 80%;
  box-shadow: 0 8px 20px rgba(0,0,0,0.25);
  pointer-events: none;
  display: flex;
  flex-direction: column;
  gap: calc(var(--base-font-size) * 0.15);
}

.overflow-indicator strong {
  font-weight: 600;
  letter-spacing: 0.02em;
}

body:not(.is-edit-mode) .overflow-indicator {
  display: none !important;
}

/* BACKGROUND: 80% transparency overlay without dimming text */
.slide-content.has-background-image { position: relative; }

/* overlay sits UNDER content, ABOVE background image */
.slide:not(.is-fullscreen-image-slide) .slide-content.has-background-image::before {
  content: "";
  position: absolute;
  inset: 0;
  background: var(--bg-color, #ffffff);
  opacity: 0.8;                 /* 80% fade of the image */
  pointer-events: none;
  z-index: 0;                   /* crucial: below content */
}

/* ensure content stays above the overlay */
.slide-content.has-background-image > .slide-flow-content {
  position: relative;
  z-index: 1;
}
.slide-content.has-background-image > .notes {
  position: absolute;           /* keep your existing positioning */
  z-index: 1;
}


/* ----------------------------- */
/* --- Presentation HUD --- */
/* ----------------------------- */

.company-logo {
  position: fixed;
  top: calc(var(--base-font-size) * 0.4);
  right: calc(var(--base-font-size) * 0.4);
  max-height: calc(var(--base-font-size) * 2.4);
  display: none;
  z-index: 5;
}
.slide-counter {
  position: fixed;
  bottom: calc(var(--base-font-size) * 0.4);
  left: calc(var(--base-font-size) * 0.4);
  font-size: calc(var(--base-font-size) * 0.2);
  color: color-mix(in srgb, var(--main-text-color) 70%, transparent);
  z-index: 5;
}
#progress-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  height: calc(var(--base-font-size) * 0.16);
  background: var(--accent-color);
  z-index: 10;
  transition: width 0.3s;
}

/* ----------------------------- */
/* --- Editor UI Layout --- */
/* ----------------------------- */

#editor {
  position: fixed;
  inset: 0;
  z-index: 100;
  background: var(--editor-bg-color);
  color: var(--editor-text-color);
  font-family: var(--editor-ui-font-family);
  display: none;
  flex-direction: row;
  overflow: hidden;
}
#editor.active { display: flex; }
#editor.active ~ #slideshow .hidden-in-presentation {
  display: flex !important;
  opacity: 0.3 !important;
}

#thumbs {
  width: 240px;
  overflow-y: auto;
  overflow-x: hidden;
  border-right: 1px solid var(--editor-border-color);
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

#thumbs::-webkit-scrollbar {
  width: 8px;
}
#thumbs::-webkit-scrollbar-track {
  background: transparent;
}
#thumbs::-webkit-scrollbar-thumb {
  background-color: #999;
  border-radius: 4px;
}
#thumbs:hover::-webkit-scrollbar-thumb {
  background-color: #666;
}

#editor-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 1rem;
  overflow: hidden;
  position: relative;
}

.selection-toolbar {
  position: absolute;
  top: 1.2rem;
  right: 1.2rem;
  display: none;
  gap: 0.4rem;
  padding: 0.4rem 0.6rem;
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid var(--editor-border-color);
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
  z-index: 10;
}

.selection-toolbar.visible {
  display: inline-flex;
  align-items: center;
}

.selection-toolbar button {
  border: 1px solid var(--editor-border-color);
  background: var(--editor-input-bg);
  color: var(--editor-input-text);
  border-radius: 4px;
  padding: 0.2rem 0.5rem;
  font-size: 0.85rem;
  cursor: pointer;
}

.selection-toolbar button:hover,
.selection-toolbar button:focus {
  border-color: var(--editor-accent-color);
  color: var(--editor-accent-color);
}

/* ----------------------------- */
/* --- Editor Components --- */
/* ----------------------------- */

.thumb { 
  position: relative;
  width: 200px;
  height: 112.5px;
  border: 2px solid var(--editor-border-color);
  border-radius: 6px;
  background: #000;
  cursor: move;
  cursor: grab;
  pointer-events: auto;
  overflow: hidden;
  transition: opacity 0.2s;
  user-select: none;
  flex-shrink: 0;
}

.thumb-controls {
  position: absolute;
  top: 6px;
  right: 6px;
  display: inline-flex;
  gap: 0.3rem;
  opacity: 0;
  transition: opacity 0.2s ease;
  pointer-events: none;
}

.thumb:hover .thumb-controls,
.thumb.selected .thumb-controls {
  opacity: 1;
  pointer-events: auto;
}

.thumb-controls button {
  width: 26px;
  height: 26px;
  padding: 0;
  border-radius: 50%;
  background: color-mix(in srgb, var(--editor-accent-color) 85%, black 20%);
  color: var(--editor-accent-text-color);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  border: none;
  cursor: pointer;
  box-shadow: 0 1px 4px rgba(0,0,0,0.25);
}

.thumb-controls button:hover:not(:disabled) {
  background: var(--editor-accent-color);
}

.thumb-controls button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.thumb.selected {
  border-color: var(--editor-thumb-selected-border);
  box-shadow: 0 0 0 2px var(--editor-thumb-selected-border);
}

.thumb:active {
  cursor: grabbing;
}

.thumb.dragging {
  opacity: 0.4;
}

.thumb-iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 200px;
  height: 112.5px;
  border: none;
  pointer-events: none;
  background: var(--editor-thumb-bg)
}

.thumb-number {
  position: absolute;
  top: 4px;
  left: 6px;
  font-size: 10px;
  font-family: var(--editor-mono-font);
  background: var(--editor-accent-color);
  color: var(--editor-accent-text-color);
  padding: 1px 5px;
  border-radius: 3px;
  z-index: 1;
}

.thumb.hidden-slide { opacity: 0.6; }
.thumb.hidden-slide::after {
  content: "HIDDEN";
  position: absolute;
  bottom: 4px;
  right: 4px;
  font-family: var(--editor-mono-font);
  font-size: 10px;
  background-color: rgba(0,0,0,0.7);
  color: white;
  padding: 2px 5px;
  border-radius: 3px;
  z-index: 2;
}

.thumb-placeholder {
  background: #007bff;
  opacity: 0.2;
  border: 2px dashed #0056b3;
  border-radius: 4px;
  margin: 5px;
  box-sizing: border-box;
  width: 200px;
  height: 112.5px;
  flex-shrink: 0;
}

#raw-text-editor {
  flex: 1;
  font-size: 18px;
  line-height: 1.7;
  padding: 1rem;
  border: none;
  resize: none;
  margin-bottom: 1rem;
  font-family: var(--editor-ui-font-family);
  background-color: var(--editor-input-bg);
  color: var(--editor-input-text);
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow: auto;
}

#overflow-measure-stage {
  position: fixed;
  top: -3000px;
  left: -3000px;
  width: 1280px;
  height: 720px;
  pointer-events: none;
  visibility: hidden;
  z-index: -1;
}

#overflow-measure-stage .presentation-scaler {
  width: 100%;
  height: 100%;
}

.toolbar {
  display: flex;
  flex-wrap: wrap;
  font-family: var(--editor-ui-font-family);
  font-size: 16px;
  gap: 0.6rem;
  align-items: center;
  margin-bottom: 1rem;
}

#editor button {
  padding: 6px 12px;
  background: var(--editor-accent-color);
  font-family: var(--editor-ui-font-family);
  font-size: 15px;
  color: var(--editor-accent-text-color);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
}
#editor button.ghost {
  background: transparent;
  color: var(--editor-accent-color);
  border: 1px solid color-mix(in srgb, var(--editor-accent-color) 60%, transparent);
}
#editor button.ghost:disabled {
  border-color: color-mix(in srgb, var(--editor-border-color) 80%, transparent);
}
#editor button.ghost:hover:not(:disabled) {
  background: color-mix(in srgb, var(--editor-accent-color) 10%, transparent);
}
#editor button:hover:not(:disabled) {
  background: color-mix(in srgb, var(--editor-accent-color) 85%, black);
}
#editor button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.editor-bottom-bar {
  margin-top: auto;
  display: flex;
  align-items: center;
  gap: 1rem;
  padding-top: 0.75rem;
  border-top: 1px solid color-mix(in srgb, var(--editor-border-color) 70%, transparent);
  min-height: 2.75rem;
}

.overflow-warning {
  font-size: 0.9rem;
  color: #b3261e;
  max-width: 60ch;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.overflow-warning::before {
  content: "⚠";
  font-size: 1.1rem;
  display: inline-flex;
  align-items: center;
}

.overflow-warning:empty::before {
  content: "";
}

.overflow-warning:empty {
  display: none;
}

.editor-status {
  margin-left: auto;
  font-size: 0.85rem;
  color: var(--editor-accent-color);
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.editor-status:empty {
  display: none;
}

.editor-status::before {
  content: '';
  width: 0.45rem;
  height: 0.45rem;
  border-radius: 999px;
  background: color-mix(in srgb, var(--editor-accent-color) 70%, transparent);
  opacity: 0.75;
}

@keyframes editor-glow {
  from { box-shadow: 0 0 8px 2px var(--editor-accent-color); }
  to   { box-shadow: 0 0 2px 1px color-mix(in srgb, var(--editor-accent-color) 50%, transparent); }
}
#editor .glow { animation: editor-glow 1.2s infinite alternate; }

.toolbar select,
.toolbar input[type="text"] {
  padding: 0.25rem 0.45rem;
  border-radius: 4px;
  border: 1px solid var(--editor-input-border);
  background-color: var(--editor-input-bg);
  font-size: 15px;
  font-family: var(--editor-ui-font-family);
  color: var(--editor-input-text);
}

.toolbar .theme-selector {
  min-width: 9rem;
}

/* ----------------------------- */
/* --- Help Modal --- */
/* ----------------------------- */

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 250;
}
.modal.active { display: flex; }
.modal-box {
  background: var(--editor-bg-color);
  color: var(--editor-text-color);
  max-width: 700px;
  max-height: 85vh;
  overflow: auto;
  padding: 2rem;
  border-radius: 8px;
  font-family: var(--editor-ui-font-family);
  line-height: 1.6;
}
.modal-box h3 {
  margin-bottom: 1rem;
  font-size: 1.5rem;
}
.modal-box pre {
  background-color: color-mix(in srgb, var(--editor-bg-color) 90%, var(--editor-text-color) 10%);
  padding: 1em;
  border-radius: 4px;
  overflow-x: auto;
  font-family: var(--editor-mono-font);
  font-size: 0.9rem;
  white-space: pre-wrap;
}
.modal-box button {
  padding: 0.5rem 1rem;
  background: var(--editor-accent-color);
  color: var(--editor-accent-text-color);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-top: 1rem;
  float: right;
}

.modal-box label {
  display: block;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.modal-box input[type="text"] {
  width: 100%;
  padding: 0.5rem 0.75rem;
  border-radius: 4px;
  border: 1px solid var(--editor-input-border);
  background-color: var(--editor-input-bg);
  color: var(--editor-input-text);
  font-family: var(--editor-ui-font-family);
  font-size: 1rem;
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
  margin-top: 1.5rem;
}

.modal-actions button {
  float: none;
  margin-top: 0;
}

.modal-actions .secondary-action {
  background: transparent;
  color: var(--editor-accent-color);
  border: 1px solid var(--editor-accent-color);
}

.modal-actions .secondary-action:hover {
  background: color-mix(in srgb, var(--editor-accent-color) 15%, transparent);
}

/* ----------------------------- */
/* --- 16:9 Presentation Viewport --- */
/* ----------------------------- */

.presentation-viewport {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
  container-type: inline-size;
  container-name: slideshow;
  --base-font-size: var(--slide-base-font-size);
}

.presentation-scaler {
  position: relative;
  width: min(100vw, 177.78vh);
  height: auto;
  aspect-ratio: 16 / 9;
  overflow: hidden;
  box-shadow: 0 0 50px rgba(0,0,0,0.5);
  container-type: inline-size;
  container-name: slideshow;
}

/* make the slideshow fill the stage without absolute overlay issues */
#slideshow {
  position: relative;
  width: 100%;
  height: 100%;
  background: var(--bg-color);
}

.slide { width: 100%; height: 100%; }

.presentation-viewport .slide-counter {
  position: absolute;
  bottom: calc(var(--base-font-size) * 0.48);
  left: calc(var(--base-font-size) * 0.48);
  font-size: calc(var(--base-font-size) * 0.33);
  color: #888;
  z-index: 100;
  pointer-events: none;
}

.presentation-viewport #progress-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  height: calc(var(--base-font-size) * 0.2);
  width: 100%;
  background-color: #007bff;
  z-index: 100;
  pointer-events: none;
}

.presentation-viewport .company-logo {
  position: absolute;
  top: calc(var(--base-font-size) * 0.8);
  right: calc(var(--base-font-size) * 0.8);
  max-height: calc(var(--base-font-size) * 2);
  max-width: calc(var(--base-font-size) * 6);
  z-index: 100;
  pointer-events: none;
}


/* ----------------------------- */
/* --- Presenter Mode Styles --- */
/* ----------------------------- */

.presenter-body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #1a1a1a;
  color: #fff;
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr auto;
  height: 100vh;
  gap: 20px;
  padding: 20px;
  box-sizing: border-box;
}

.presenter-slide-container {
  background: #000;
  border-radius: 8px;
  overflow: hidden;
  position: relative;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
  aspect-ratio: 16 / 9;
  display: flex;
  align-items: center;
  justify-content: center;
}

.presenter-slide-container iframe {
  width: 100%;
  height: 100%;
  border: none;
}

.presenter-slide-label {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.7);
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 14px;
  z-index: 10;
}

.presenter-notes-section {
  grid-column: 1 / -1;
  background: #2a2a2a;
  border-radius: 8px;
  padding: 20px;
  max-height: 200px;
  overflow-y: auto;
}

.presenter-notes-section h3 {
  margin-top: 0;
  color: #ffa500;
}

.presenter-timer-section {
  position: absolute;
  top: 20px;
  right: 20px;
  text-align: right;
  background: rgba(0,0,0,0.7);
  padding: 10px 15px;
  border-radius: 4px;
}

.presenter-timer {
  font-size: 32px;
  font-family: monospace;
  color: #0f0;
}

.presenter-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 10px;
}

.presenter-controls button {
  padding: 10px 20px;
  background: #333;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}

.presenter-controls button:hover {
  background: #555;
}

/* ----------------------------- */
/* --- PRINT STYLES --- */
/* ----------------------------- */

/* Hide injected print notes on screen */
.print-notes-content { display: none; }

body.print-with-notes .print-notes-content {
  display: block !important;
  position: absolute !important;
  left: 0 !important; 
  right: 0 !important; 
  bottom: 0 !important;
  /* This calculation matches your print layout (16:9 aspect ratio offset) */
  top: calc(min(177.78vh, 100vw) * 0.5625) !important; 
  padding: calc(var(--slide-base-font-size) * 0.4) !important;
  background: #fff !important;
  z-index: 2147483647 !important; /* Show on top of everything */
  overflow: hidden !important; /* Essential for scrollHeight measurement */
}

/* Hide the website placeholder on screen */
.website-print-placeholder { display: none; }

@media print {
  @page {
    size: letter landscape;
    margin: 0;
  }

  /* Allow the printer to see all slides */
  html, body {
    height: auto !important;
    overflow: visible !important;
    background: #fff !important;
    margin: 0 !important;
    padding: 0 !important;
  }

  #overflow-measure-stage, .modal, #editor {
    display: none !important;
  }

  .slide.is-fullscreen-image-slide .slide-content {
    background-size: contain !important;   /* override the generic 'cover' in print */
    background-color: transparent !important;
  }

  /* Fix flex-min-height behavior so the 16:9 box never grows on print */
  .slide > .slide-content {
    min-height: 0 !important;
    min-width: 0 !important;
    flex: 0 0 auto !important;   /* don't stretch to fit content */
    overflow: hidden !important;  /* hard clip, like the screen view */
  }

  /* Tame the inline-styled iframe wrapper used for FullScreenWebsite */
  .slide [style*="z-index: 100"] {
    /* occupy exactly the 16:9 area, no chrome */
    width: min(177.78vh, 100vw) !important;
    height: calc(min(177.78vh, 100vw) * 0.5625) !important;
    top: 50% !important; left: 50% !important; transform: translate(-50%, -50%) !important;
    background: transparent !important; box-shadow: none !important; border-radius: 0 !important;
  }

  /* When printing with notes, the slide is at the top—align the placeholder with it */
  body.print-with-notes .slide [style*="z-index: 100"] {
    top: 0 !important; left: 50% !important; transform: translate(-50%, 0) !important;
  }

  /* Center the placeholder message fully within the 16:9 area */
  .slide .website-print-placeholder {
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    text-align: center !important;
    width: 100% !important;
    height: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
    font-size: calc(var(--base-font-size) * 0.9) !important;
  }
  
  /* Use the exact same container-relative unit for printing */
  .slide {
    --base-font-size: var(--slide-base-font-size);
  }

  /* Hide all on-screen UI chrome */
  #editor, #progress-bar, .slide-counter, #company-logo, .presenter-controls {
    display: none !important;
  }

  /* Ensure all colors and backgrounds print */
  * {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
    color-adjust: exact !important;
  }

  /* Flatten on-screen layout containers */
  .presentation-viewport, .presentation-scaler, #slideshow {
    position: static !important; display: block !important;
    width: auto !important; height: auto !important;
    background: transparent !important; box-shadow: none !important;
    aspect-ratio: unset !important;
  }

  /* --- SLIDE PAGE STRUCTURE --- */
  .slide {
    position: relative !important;
    display: flex !important;
    align-items: center !important; /* Center slide vertically by default */
    justify-content: center !important;
    width: 100vw !important; height: 100vh !important;
    overflow: hidden !important;
    margin: 0 !important; padding: 0 !important;
    opacity: 1 !important;
    break-inside: avoid;
    page-break-inside: avoid;
    page-break-after: always;
    break-after: page;
    background: transparent !important;
    background-image: none !important; /* keep imagery inside the 16:9 box */
  }
  .slide:last-of-type { 
    page-break-after: auto !important; 
    break-after: auto !important; 
  }
  .slide.hidden-in-presentation { display: none !important; }
  
  /* --- 16:9 CONTENT BOX (THE "PRINTABLE SCREEN") --- */
  .slide-content {
    position: relative !important; display: flex !important;
    box-sizing: border-box !important; overflow: hidden !important;
    background-color: var(--bg-color) !important;
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
    width: min(177.78vh, 100vw) !important;
    height: calc(min(177.78vh, 100vw) * 0.5625) !important;
    margin: 0 auto !important;
    container-type: inline-size;
    container-name: print-slide-container;
  }

  .slide-content.has-background-image {
    background-color: var(--slide-content-bg-if-image) !important;
  }

  .slide.is-fullscreen-image-slide .slide-content {
    background-color: transparent !important;
  }

  /* Show iframes and hide their placeholders */
  .slide iframe { display: none !important; }
  .website-print-placeholder { display: flex !important; }

  /* When printing with notes, push the slide to the top of the page */
  body.print-with-notes .slide {
    align-items: flex-start !important;
  }

  /* Shrink the slide's 16:9 container to make room at the bottom. */
  body.print-with-notes .slide-content {
    height: calc(min(177.78vh, 100vw) * 0.5625) !important;
  }

  /* ]Make the notes area visible and position it in the new empty space. */
  body.print-with-notes .print-notes-content {
    display: block !important;
    position: absolute !important;
    left: 0 !important; right: 0 !important; bottom: 0 !important;
    top: calc(min(177.78vh, 100vw) * 0.5625) !important; /* Start exactly where the slide content ends */
    padding: calc(var(--base-font-size) * 0.4) calc(var(--base-font-size) * 0.8) !important;
    background: #fff !important;
    height: auto; 
    font-size: calc(var(--base-font-size) * 0.8);
    line-height: 1.4 !important;
    z-index: 2147483647 !important;
    color: #cc0000 !important; 
  }
}
</style>
</head>




<!---------------------------------------------------- HTML BODY FOR PRESENTATION AND EDITOR VIEW ------------------->
<body>
  <!-- Presentation View -->
  <div id="slideshow"></div>
  <img id="company-logo" class="company-logo" />
  <div id="slide-counter" class="slide-counter">
    <span id="cur">1</span>/<span id="tot">1</span>
  </div>
  <div id="progress-bar"></div>

  <!-- Editor View -->
  <div id="editor">
    <div id="thumbs"></div>
    <div id="editor-main">
      <textarea id="raw-text-editor" placeholder="Enter slide content here. Click Help for syntax." spellcheck="true" lang="en"></textarea>
      <div id="selection-toolbar" class="selection-toolbar" role="toolbar" aria-hidden="true">
        <button type="button" data-format="align-left" title="Align left">⇤</button>
        <button type="button" data-format="align-center" title="Align center">↔</button>
        <button type="button" data-format="align-right" title="Align right">⇥</button>
        <button type="button" data-format="bold" title="Bold">B</button>
        <button type="button" data-format="italic" title="Italic">I</button>
        <button type="button" data-format="bolditalic" title="Bold Italic">BI</button>
      </div>
      <div class="toolbar">
        <button id="add-btn"       title="New Slide">      <i class="fa-solid fa-plus"></i></button>
        <button id="del-btn"       title="Delete Slide">   <i class="fa-solid fa-minus"></i></button>
        <button id="dup-btn"       title="Duplicate Slide"><i class="fa-solid fa-copy"></i></button>
        <button id="toggle-hide-btn" title="Hide/Show Slide"> <i class="fa-solid fa-eye"></i></button>
        <!-- hidden state, still used by updateHUD() -->
        <input type="checkbox" id="show-count" checked style="display:none">
        <!-- toggle button -->
        <button id="toggle-count-btn" title="Hide Slide Numbers">
          <i class="fa-solid fa-sort-numeric-asc"></i>
        </button>
        <select id="theme-selector" class="theme-selector" aria-label="Choose theme">
          <!-- Options will be dynamically populated -->
        </select>
        <button id="undo-btn" class="ghost" title="Undo" disabled>
          <i class="fa-solid fa-rotate-left"></i>
        </button>
        <button id="redo-btn" class="ghost" title="Redo" disabled>
          <i class="fa-solid fa-rotate-right"></i>
        </button>
        <div class="deckbar-spacer"></div>
        <button id="help-btn" title="Help"><i class="fa-solid fa-question"></i></button>
        <button id="new-presentation-btn"   title="New Slideshow">  <i class="fa-solid fa-file-circle-plus"></i></button>
        <button id="load-btn"  title="Load Slideshow"> <i class="fa-solid fa-folder-open"></i></button>
        <button id="restore-btn" title="Restore most recently saved" aria-label="Restore most recently saved slideshow" disabled><i class="fa-solid fa-clock-rotate-left"></i></button>
        <button id="manage-images-btn" title="Manage Images"><i class="fa-solid fa-images"></i></button>
        <button id="download-txt-btn" title="Download Raw Presentation"><i class="fa-solid fa-download"></i></button>
        <button id="print-notes-btn" title="Print with Notes"><i class="fa-solid fa-print"></i></button>
        <button id="save-btn" class="primary-action" title="Presentation View"><i class="fa-solid fa-bullhorn"></i></button>
      </div>
      <div class="editor-bottom-bar">
        <div id="overflow-warning" class="overflow-warning" role="status" aria-live="polite"></div>
        <div id="editor-status" class="editor-status" role="status" aria-live="polite"></div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="help" class="modal">
    <div class="modal-box">
      <button id="close-help">Close</button>
      <h3>Modern Slides | Kevin Bryan | July 2025</h3>
      <p>This is a modern, very computationally light, slideshow maker. It completely separates style rules from content. You can edit it completely online or download the code from <a href="https://github.com/kevincure/ModernSlides">github.com/kevincure/ModernSlides</a> or find more similar tools at <a href="https://kevinbryanecon.com/tools.html">kevinbryanecon.com/tools.html</a> and create your slides locally in your browser. Once your slides are set, click download. You can upload that text file to anywhere you like, then open it with a url query of the form ?xml=...: e.g., <a href="https://kevinbryanecon.com/ModernSlides?xml=Progress2025Class1/Class1Slides.txt">this one here</a></p> 
      <p>Each slide is defined by directives in a Markdown type format. A directive starts a line, ends with a colon `:`, and its value is all text that follows until the next directive. In the text editor, you can use abbrevations, noted like [B:]. That is, if you type B: at the start of a line, Background: will automatically pop up.</p>
      <p>Press 'e' to toggle between edit and present, 'f' to go to full screen mode, and 'p' to open a presenter mode window.
      <pre>
      # --- METADATA (place at the top) ---
      Background: image-url.jpg (B:)
      FullScreenImage: image-url.jpg (F:)

      # --- CONTENT DIRECTIVES ---
      Title: The Main Title of The Slide (t:)
        Supports $LaTeX$ and
        manual line breaks.

      Header: Small text in corner (h:)

      BigText: For large, prominent text. (b:)

      Text: For standard body text. (x:)
        
      Add a number to Text (e.g., Text2:, Text.6:) to scale relative to the slide (0.2–5 works).
      
      <<< Text on Left <<<, >>> Text on Right >>>, and ||| Text is centered ||| align any line
      
      A blank line between text...

      ...and a skipped line creates a new paragraph.

      SmallText: For smaller body text. (s:)

      TinyText: For footnote-sized text. (y:)

      Blockquote(caption): Creates a blockquote with a caption below (q:)

      Break: 1 (or 2.2 or .7), provides a break of a set size

      Notes: For notes at the bottom of the slide. (n:)
        These appear in a special position.

      SpeakerNote: For notes for yourself in presentation mode (S:)

      PrintNote: notes about the slide to appear only when printed from the 'print' button in Edit (if you print from the slides, you won't get these) (P:)

      Image: image-url.jpg (or a weblink to jpg/png/gif), An optional caption for image after the comma (I:)

      FullScreenWebsite: https://example.com. If the website shows as broken, it is being blocked on the other website's end. Your personal website should work fine. You can use this to embed a Youtube video including the start time by clicking 'share' and then 'embed' and copying the embed url on Youtube. (F:)

      Columns: (C:)
        This is the left column. Can contain any
        amount of text, paragraphs, and $math$. The ---- instead of --- makes it double-width.
        ----
        This is the right column. You can put an
        image here using the 'image, caption' syntax:
        test.jpg, A caption for the image in the column.
        ...or you can just have more text.
        ---
        BigText: >>> Third column right-aligned >>>

      Table: (T:)
        Header 1 & Header 2 & Header 3
        ---
        Cell 1.1 & Cell 1.2 & Cell 1.3
        ---
        Cell 2.1 & Cell 2.2 & $math$ is fine

      *some text* is italic, **some text** is bold, ***some text*** is bold italic.
      
      To include a link, put ! before http (e.g., !http://www.alldayta.com)

      # --- NOTES ---
      # - Download Raw Deck and Load Deck give you your slides but you
      #      will still need any images referred to in the same folder
      # - If you print from your browser, it will give slides without PrintNotes. 
      # - If you print from the print icon in Edit mode, it will show the PrintNotes.
      # - You can add a bullet point by pressing Ctrl+B.
      # - Sequential lines with * or bullet points will form unordered lists
      # - Sequential lines with 1., 2., 3. will form ordered lists
      # - If no directive is given, text defaults to `Text:`.
      # - In `Columns` and `Table`, use `---` on its own line
      #       to separate sections/rows.
      # - You cannot nest some directives (e.g., a Table inside a Column).
      # - As you edit, your two most recent sessions are stored locally. The app automatically reopens the last one and the clock icon restores the prior deck in case you face a crash or accidentally overwrite your slides you haven't yet downloaded.
      # - Undo and Redo are next to the style selector in the toolbar.
      # - When a thumbnail is highlighted you can use the + / - buttons on it to add or delete slides.
      # - 11 different styles are given, but you can create your own also
      # - If you want images that are not web-linked, you can paste images into the textbox, and when you download, it will include those images. Keep all in the same folder wherever you store your offline slide text and images.
      </pre>
    </div>
  </div>

<!-- Image Manager Modal -->
<div id="image-manager" class="modal">
  <div class="modal-box">
    <button id="close-image-manager" style="float:right;">Close</button>
    <h3>Manage Images</h3>
    <p>Images pasted into this browser (IndexedDB). Delete unused ones to free space.</p>
    <div id="image-list" style="max-height:400px;overflow:auto;margin-top:1rem;"></div>
  </div>
</div>

<!-- New Deck Modal -->
<div id="new-deck-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="new-deck-modal-title">
  <div class="modal-box">
    <h3 id="new-deck-modal-title">Name your new slideshow</h3>
    <label for="new-deck-name">Deck name</label>
    <input id="new-deck-name" type="text" maxlength="120" placeholder="New Presentation" />
    <div class="modal-actions">
      <button id="cancel-new-deck" type="button" class="secondary-action">Cancel</button>
      <button id="confirm-new-deck" type="button" class="primary-action">Create</button>
    </div>
  </div>
</div>





<!---------------------------------------------------- JAVASCRIPT ------------------------------------------>
<script>
const ModernSlideshow = (function() {
  'use strict';
  
  /* ═══════════════════════════════════════════════════════════════
                              CONSTANTS
     ═══════════════════════════════════════════════════════════════ */
  const DEFAULT_THEME = 'tufte-base';
  const AVAILABLE_THEMES = ['tufte-base', 'editorial', 'oxford', 'bringhurst', 'calgary', 'swiss-modern', 'david-carson', 'gradient', 'modern-dark','japan-minimal', 'bauhaus', 'style-example'];
  const MINIMAL_NEW_XML = `<presentation title="New Presentation" showSlideCount="true" theme="${DEFAULT_THEME}"><slide><raw><![CDATA[Title: New slide]]></raw></slide></presentation>`;
  const METADATA_DIRECTIVES = ["Theme", "ShowSlideCount", "LogoUrl"];
  const CONTENT_DIRECTIVES = ["Hidden", "Background", "FullScreenImage", "Header",
                                "Title", "BigText", "Text", "SmallText", "TinyText", "Notes",
                                "Image", "Columns", "Table", "FullScreenWebsite", "SpeakerNote",
                                "PrintNote", "Break", "Logo", "Blockquote"];
  const ALL_DIRECTIVES = [...METADATA_DIRECTIVES, ...CONTENT_DIRECTIVES];
  const INLINE_MODE_DIRECTIVE_RE = /\[\[([A-Za-z][A-Za-z0-9.]*)(?::?\s*([^\]]+))?\]\]/g;
  const ALIGNMENT_MARKERS = ['<<<', '|||', '>>>'];
  const MIN_TEXT_SCALE = 0.2;
  const MAX_TEXT_SCALE = 5;
  const DEFAULT_TEXT_SCALE = 1;
  const LAST_SESSION_KEY = 'modernSlides_lastSession';
  const PREVIOUS_SESSION_KEY = 'modernSlides_previousSession';
  const LAST_SESSION_META_KEY = 'modernSlides_lastSessionMeta';
  const PREVIOUS_SESSION_META_KEY = 'modernSlides_previousSessionMeta';
  const LAST_SLIDE_INDEX_KEY = 'modernSlides_lastSlideIndex';
  const DEFAULT_NEW_SLIDE_CONTENT = "Title: New Slide\n\nText: Edit this content.";

  function clampTextScale(value) {
    if (!Number.isFinite(value)) return DEFAULT_TEXT_SCALE;
    return Math.min(MAX_TEXT_SCALE, Math.max(MIN_TEXT_SCALE, value));
  }

  function makeModeState(name, scale) {
    const normalizedName = name || 'Text';
    if (normalizedName === 'Text') {
      return { name: 'Text', textScale: clampTextScale(scale ?? DEFAULT_TEXT_SCALE) };
    }
    return { name: normalizedName };
  }

  function resolveModeState(mode) {
    if (!mode) return makeModeState('Text');

    if (typeof mode === 'string') {
      const interpreted = interpretModeKeyword(mode);
      if (interpreted) return makeModeState(interpreted.name, interpreted.textScale);
      return makeModeState(mode);
    }

    if (typeof mode === 'object') {
      const candidateName = mode.name || mode.type || mode.mode;
      if (candidateName) {
        if (candidateName === 'Text' || candidateName === 'text') {
          const sourceScale = mode.textScale ?? mode.scale ?? mode.factor ?? DEFAULT_TEXT_SCALE;
          return makeModeState('Text', sourceScale);
        }
        return makeModeState(candidateName);
      }
    }

    return makeModeState('Text');
  }

  function interpretModeKeyword(keyword, arg = '') {
    if (!keyword) return null;
    const normalized = keyword.trim();
    if (!normalized) return null;
    const lower = normalized.toLowerCase();

    if (lower === 'bigtext' || lower === 'big') return makeModeState('BigText');
    if (lower === 'smalltext' || lower === 'small') return makeModeState('SmallText');
    if (lower === 'tinytext' || lower === 'tiny') return makeModeState('TinyText');

    if (lower === 'text' || lower === 'normal') {
      const numericArg = parseFloat((arg || '').replace(',', '.'));
      if (Number.isFinite(numericArg)) {
        return makeModeState('Text', numericArg);
      }
      return makeModeState('Text');
    }

    const match = lower.match(/^text(?:(\d+(?:\.\d+)?)|(\.\d+))$/);
    if (match) {
      const scaleStr = match[1] ?? match[2];
      const parsedScale = parseFloat(scaleStr);
      if (Number.isFinite(parsedScale)) {
        return makeModeState('Text', parsedScale);
      }
    }

    return null;
  }

  function interpretInlineDirective(keyword, arg = '') {
    if (!keyword) return null;
    const lower = keyword.toLowerCase();

    if (lower === 'break') {
      const amount = parseFloat((arg || '').replace(',', '.'));
      const lines = Number.isFinite(amount) && amount > 0 ? amount : 1;
      return { action: 'break', lines };
    }

    const modeState = interpretModeKeyword(keyword, arg);
    if (modeState) {
      return { action: 'mode', mode: resolveModeState(modeState) };
    }

    return null;
  }

  
/* ═══════════════════════════════════════════════════════════════
                          APPLICATION STATE
     ═══════════════════════════════════════════════════════════════ */

  const state = {
    // Mode flags
    editMode: false,
    wakeLock: null,
    hasChanges: false, // Simple flag to track if there are any unsaved changes.
    currentFilename: null,

    // Presentation data
    xmlDoc: null, // The single source of truth for the entire presentation.

    // Navigation state
    slideEls: [],
    visibleSlideIndices: [],
    currentVisibleSlideIndex: 0,
    currentAbsoluteSlideIndex: 0,

    // Undo/redo state
    undoStack: [],
    redoStack: [],
    maxUndoDepth: 5,
    isRestoringSnapshot: false,

    // Drag state
    draggedThumbIndex: null,
    placeholder: null,
    thumbnailRefreshPromise: null,
    pendingThumbScrollIndex: null,

    // Overflow measurement
    pendingOverflowFrame: null,

    // Available themes
    availableThemes: [],

    // Presenter window
    presenterWindow: null,
    presenterTimerInterval: null,

    // Editor status messaging
    statusTimeout: null,
    lastStatusMessage: ''
  };

  function sanitizeDeckName(input) {
    const fallback = 'New Presentation';
    const cleaned = (input ?? '').replace(/[\r\n]+/g, ' ').trim();
    return cleaned || fallback;
  }

  function escapeAttributeValue(value) {
    return value
      .replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/'/g, '&apos;');
  }

  function buildNewPresentationXML(name) {
    const cleanName = sanitizeDeckName(name);
    const escapedAttr = escapeAttributeValue(cleanName);
    let xml = MINIMAL_NEW_XML.replace(/title="[^"]*"/, `title="${escapedAttr}"`);
    xml = xml.replace(/Title: [^\r\n]*/, `Title: ${cleanName}`);
    return xml;
  }

  function getDeckIdentityFromState() {
    const titleAttr = state.xmlDoc?.documentElement?.getAttribute('title');
    const fallbackName = state.currentFilename;
    const name = sanitizeDeckName(titleAttr || fallbackName);
    return { id: name.toLowerCase(), label: name };
  }

  function parseDeckIdentityMeta(raw) {
    if (!raw) return null;
    try {
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed.id === 'string' && typeof parsed.label === 'string') {
        return parsed;
      }
    } catch (err) {}
    return null;
  }

  function extractDeckIdentityFromXML(xmlString) {
    if (!xmlString) return null;
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlString, 'text/xml');
      if (doc.getElementsByTagName('parsererror').length > 0) return null;
      const titleAttr = doc.documentElement?.getAttribute('title');
      if (!titleAttr) return null;
      const name = sanitizeDeckName(titleAttr);
      return { id: name.toLowerCase(), label: name };
    } catch (err) {
      return null;
    }
  }


/* ────────────────────────────────
   IMAGE STORAGE (IndexedDB)
   ──────────────────────────────── */

const ImageStore = {
  db: null,
  // id → blob: URL (kept alive as long as the page is open)
  idToURL: new Map(),

  async init() {
    if (!('indexedDB' in window)) {
      console.warn('IndexedDB not available; local images will not persist.');
      return;
    }
    await new Promise((resolve, reject) => {
      const req = indexedDB.open('ModernSlidesImages', 1);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('images')) {
          db.createObjectStore('images', { keyPath: 'id' });
        }
      };
      req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
      req.onerror = () => reject(req.error);
    });

    // Pre-cache blob: URLs for all stored images so resolveImagePath can be sync.
    try {
      const all = await this.getAllImages();
      all.forEach(rec => {
        if (!this.idToURL.has(rec.id)) {
          this.idToURL.set(rec.id, URL.createObjectURL(rec.blob));
        }
      });
    } catch (err) {
      console.warn('ImageStore init could not hydrate cache:', err);
    }
  },

  async downscaleImage(blob) {
    // Keep small images as-is; downscale larger to fit within 1024×1024.
    return new Promise((resolve) => {
      const img = new Image();
      const u = URL.createObjectURL(blob);
      img.onload = () => {
        URL.revokeObjectURL(u);
        const MAX = 1024;
        let { width, height } = img;
        if (width <= MAX && height <= MAX) { resolve(blob); return; }

        if (width > height) { height = Math.round(height * (MAX / img.width)); width = MAX; }
        else { width = Math.round(width * (MAX / img.height)); height = MAX; }

        const c = document.createElement('canvas');
        c.width = width; c.height = height;
        const ctx = c.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);

        const isJPEG = (blob.type || '').includes('jpeg') || (blob.type || '').includes('jpg');
        c.toBlob((b) => resolve(b || blob), isJPEG ? 'image/jpeg' : blob.type || 'image/png', 0.9);
      };
      img.onerror = () => { URL.revokeObjectURL(u); resolve(blob); };
      img.src = u;
    });
  },

  async storeImage(blob, originalName = 'pasted-image') {
    const downscaled = await this.downscaleImage(blob);
    const extRaw = (downscaled.type || 'image/jpeg').split('/')[1] || 'jpg';
    const ext = extRaw.toLowerCase() === 'jpeg' ? 'jpg' : extRaw.toLowerCase();
    const id = `local-img-${Date.now()}-${Math.random().toString(36).slice(2, 9)}.${ext}`;

    await new Promise((resolve, reject) => {
      const tx = this.db.transaction('images', 'readwrite');
      tx.objectStore('images').put({
        id,
        blob: downscaled,
        originalName,
        timestamp: Date.now()
      });
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });

    // Cache blob URL for synchronous resolution in UI/preview/thumbnail.
    const url = URL.createObjectURL(downscaled);
    this.idToURL.set(id, url);
    return id;
  },

  getObjectURLForId(id) {
    return this.idToURL.get(id) || '';
  },

  async getImage(id) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('images', 'readonly');
      const req = tx.objectStore('images').get(id);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  },

  async getAllImages() {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('images', 'readonly');
      const req = tx.objectStore('images').getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
  },

  async deleteImage(id) {
    // Revoke any live object URL
    const u = this.idToURL.get(id);
    if (u) { URL.revokeObjectURL(u); this.idToURL.delete(id); }

    return new Promise((resolve, reject) => {
      const tx = this.db.transaction('images', 'readwrite');
      tx.objectStore('images').delete(id);
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });
  }
};



/* ═══════════════════════════════════════════════════════════════
                          KEEP COMPUTER FROM FALLING ASLEEP
     ═══════════════════════════════════════════════════════════════ */
  
  async function requestWakeLock() {
    if ('wakeLock' in navigator) {
      try {
        state.wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake lock acquired');
        
        state.wakeLock.addEventListener('release', () => {
          console.log('Wake lock released');
        });
      } catch (err) {
        console.log(`Wake lock error: ${err.name}, ${err.message}`);
      }
    }
  }

  async function releaseWakeLock() {
    if (state.wakeLock) {
      await state.wakeLock.release();
      state.wakeLock = null;
    }
  }


/* ═══════════════════════════════════════════════════════════════
                          HELPER FOR PRINTING
     ═══════════════════════════════════════════════════════════════ */

  function fitPrintNotesToBox() {
    if (!document.body.classList.contains('print-with-notes')) return;

    const notesEls = document.querySelectorAll('.print-notes-content');
    if (!notesEls.length) return;

    notesEls.forEach((el) => {
      const pageW = el.getBoundingClientRect().width || window.innerWidth;
      const notesHeightPx = pageW * 0.18;

      el.style.setProperty('height', notesHeightPx + 'px', 'important');
      el.style.setProperty('overflow', 'hidden', 'important');

      // Start large and shrink
      let fontSizePx = 36;
      el.style.setProperty('font-size', fontSizePx + 'px', 'important');

      const minFontPx = 8;

      // Shrink until it fits
      while (el.scrollHeight > el.clientHeight && fontSizePx > minFontPx) {
        fontSizePx -= 1;
        el.style.setProperty('font-size', fontSizePx + 'px', 'important');
      }
    });
  }

/* ═══════════════════════════════════════════════════════════════
                          EVENT HANDLERS
     ═══════════════════════════════════════════════════════════════ */

  function setupEventHandlers() {
    initSelectionToolbar();
    // ensure print is small pdf w/ embedded websites
    window.addEventListener('beforeprint', () => {
      document.querySelectorAll('.slide iframe').forEach((f) => {
        f.dataset.src = f.src;        // remember
        f.src = 'about:blank';        // blank it so nothing gets rasterized
      });
      if (document.body.classList.contains('print-with-notes')) {
        fitPrintNotesToBox();
      }
    });

    window.addEventListener('afterprint', () => {
      document.querySelectorAll('.slide iframe[data-src]').forEach((f) => {
        f.src = f.dataset.src;        // restore
        delete f.dataset.src;
      });
    });

    window.addEventListener('resize', () => scheduleOverflowChecks());

    // Keyboard navigation
    // Navigate between slides using arrow keys or page up/down
    // Toggle edit mode using e
    // Go to full screen using f
    // Open presenter mode window using p
    // Exit full screen using escape
    document.addEventListener("keydown", (e) => {
      if (e.target.closest("textarea, input, select") && e.key !== "Escape") return;

      const navAction = {
        "ArrowRight": 1, " ": 1, "PageDown": 1,
        "ArrowLeft": -1, "PageUp": -1
      }[e.key];

      if (navAction) {
        e.preventDefault();
        const nextIndex = state.editMode ?
          state.currentAbsoluteSlideIndex + navAction :
          state.currentVisibleSlideIndex + navAction;
        if (state.editMode) updateGroundTruth('NAVIGATE', { from: state.currentAbsoluteSlideIndex, to: nextIndex });
        showSlide(nextIndex, !state.editMode);
      } else if (e.key === 'e' || e.key === 'E') {
        e.preventDefault();
        let indexForShowSlide = state.currentAbsoluteSlideIndex; 
        if (!state.editMode) {
          // sync currentAbsoluteSlideIndex with current visible slide
          if (state.visibleSlideIndices.length > 0 && state.currentVisibleSlideIndex >= 0) {
            state.currentAbsoluteSlideIndex = state.visibleSlideIndices[state.currentVisibleSlideIndex];
          }
          indexForShowSlide = state.currentAbsoluteSlideIndex;
        }
        state.editMode = !state.editMode;
        $("editor").classList.toggle("active", state.editMode);
        syncEditModeClass();
        if (state.editMode) {
          setupEditorUI();
          releaseWakeLock();
          highlightThumb(state.currentAbsoluteSlideIndex);
          loadTextareaForCurrentSlide();
          $("raw-text-editor").scrollTop = 0;
          // Scroll the slideshow to show the current slide
          const activeSlide = state.slideEls[state.currentAbsoluteSlideIndex];
          if (activeSlide) {
            activeSlide.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
          updateOverflowWarningForEditor();
        } else {
          // Update ground truth when leaving edit mode
          updateGroundTruth('EXIT_EDIT_MODE');
          buildSlidesFromXMLDoc();
          requestWakeLock();
          const lastAbsoluteIndex = state.currentAbsoluteSlideIndex;
          const targetVisibleIndex = resolveVisibleIndexForAbsolute(lastAbsoluteIndex);
          indexForShowSlide = targetVisibleIndex;
          updateOverflowWarningForEditor();
        }
        showSlide(indexForShowSlide, !state.editMode);
      } else if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        toggleFullscreen();
      } else if (e.key === 'p' || e.key === 'P') {
        e.preventDefault();
        openPresenterMode();
      } else if (e.key === "Escape") {
        if ($("help").classList.contains("active")) {
          $("help").classList.remove("active");
        } else if (document.fullscreenElement) {
          document.exitFullscreen();
        } else if (state.editMode) {
          const lastAbsoluteIndex = state.currentAbsoluteSlideIndex;
          state.editMode = false;
          $("editor").classList.remove("active");
          const targetVisibleIndex = resolveVisibleIndexForAbsolute(lastAbsoluteIndex);
          syncEditModeClass();
          updateOverflowWarningForEditor();
          showSlide(targetVisibleIndex, true);
        }
      }
    });


    // -------------------- EDITOR BUTTONS --------------------
    // Save button (triggered in many places including when you open presentations with the bullhorn)
    $("save-btn").onclick = () => {
      updateGroundTruth('SAVE');
      if (state.hasChanges) {
        buildSlidesFromXMLDoc(); // Re-render slides to reflect all changes
      }
      state.hasChanges = false;
      updateSaveButtonGlow();
      state.editMode = false;
      $("editor").classList.remove("active");
      syncEditModeClass();
      const targetVisibleIndex = resolveVisibleIndexForAbsolute(state.currentAbsoluteSlideIndex);
      showSlide(targetVisibleIndex, true);
      updateOverflowWarningForEditor();

      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.log('Could not enter fullscreen:', err);
        });
      }
    };


    // Add slide button
    $("add-btn").onclick = async () => {
      await insertSlideAfter(state.currentAbsoluteSlideIndex);
    };


    // Delete slides
    $("del-btn").onclick = async () => {
      await removeSlideAt(state.currentAbsoluteSlideIndex);
    };


    // Duplicate slide
    $("dup-btn").onclick = async () => {
      updateGroundTruth('SAVE');
      const currentRawText = getRawTextForSlide(state.currentAbsoluteSlideIndex);
      await insertSlideAfter(state.currentAbsoluteSlideIndex, currentRawText);
    };


    // Touch navigation on left/right for mobile
    $("slideshow").addEventListener('click', (e) => {
      // Don't navigate if in edit mode or clicking on interactive elements
      if (state.editMode) return;
      
      // Check if we clicked on an iframe or inside an iframe wrapper
      if (e.target.closest('iframe') || e.target.closest('[style*="z-index: 100"]')) return;
      
      // Navigate based on which side was clicked
      const clickX = e.clientX;
      const screenWidth = window.innerWidth;
      
      if (clickX < screenWidth / 2) {
        // Left side - go to previous slide
        const prevIndex = state.currentVisibleSlideIndex - 1;
        showSlide(prevIndex, true);
      } else {
        // Right side - go to next slide
        const nextIndex = state.currentVisibleSlideIndex + 1;
        showSlide(nextIndex, true);
      }
    });


    // toggle show/hide slide button    
    $("toggle-hide-btn").onclick = () => {
      const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
      if (!slideNode) return;

      const rawNode = slideNode.querySelector('raw');
      if (!rawNode) return;

      const rawText = rawNode.textContent || '';
      const lines = rawText.split('\n');
      let hiddenLineIndex = -1;
      let isCurrentlyHidden = false;

      // Check if Hidden directive exists
      for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(/^Hidden:\s*(.*)/i);
        if (match) {
          hiddenLineIndex = i;
          isCurrentlyHidden = match[1].trim().toLowerCase() === 'true';
          break;
        }
      }

      // Toggle the hidden state
      let newLines;
      if (isCurrentlyHidden) {
        // Currently hidden, so unhide by removing the line
        if (hiddenLineIndex >= 0) {
          newLines = lines.filter((_, index) => index !== hiddenLineIndex);
        } else {
          newLines = lines;
        }
      } else {
        // Currently visible, so hide by adding/updating the line
        if (hiddenLineIndex >= 0) {
          lines[hiddenLineIndex] = 'Hidden: true';
          newLines = lines;
        } else {
          // Add Hidden: true at the beginning (after any empty lines)
          let insertIndex = 0;
          while (insertIndex < lines.length && lines[insertIndex].trim() === '') {
            insertIndex++;
          }
          lines.splice(insertIndex, 0, 'Hidden: true');
          newLines = lines;
        }
      }

      // Update the raw text in XML - trim to avoid extra newlines
      const newRawText = newLines.join('\n').trim();
      recordSnapshot('TOGGLE_HIDE');
      rawNode.textContent = '';
      rawNode.appendChild(state.xmlDoc.createCDATASection(newRawText));

      if (!isCurrentlyHidden) {
        slideNode.setAttribute("hidden", "true");
      } else {
        slideNode.removeAttribute("hidden");
      }

      // Update the UI
      state.hasChanges = true;
      state.slideEls[state.currentAbsoluteSlideIndex].classList.toggle("hidden-in-presentation", !isCurrentlyHidden);
      updateVisibleSlideIndices();
      updateToggleHideButtonState();
      updateSingleThumbnail(state.currentAbsoluteSlideIndex);
      updateSaveButtonGlow();

      // Update the textarea if we're editing this slide
      if (state.editMode) {
        const textarea = $("raw-text-editor");
        if (textarea) {
          textarea.value = addCommandGuardsToText(newRawText);
          textarea.selectionStart = textarea.selectionEnd = 0;
          validateAndUpdateTextarea();
        }
      }
    };


    // Toggle 'show slide number' button
    $("toggle-count-btn").onclick = () => {
      const cb = $("show-count");
      cb.checked = !cb.checked;
      updateGroundTruth('TOGGLE_COUNT');
      updateToggleCountButtonState();
      updateHUD();
    };


    // Download slide txt incl any local images
$("download-txt-btn").onclick = async () => {
  updateGroundTruth('DOWNLOAD');

  const fileContents = buildRawDeck();
  const baseName = (state.currentFilename ||
    state.xmlDoc.documentElement.getAttribute('title') ||
    'presentation').replace(/\s+/g, '-');

  // Collect all local image ids (works for Image:, Background:, FullScreenImage:, and inside Columns)
  const idRE = /local-img-[a-z0-9-]+\.(?:png|jpg|jpeg|gif|webp|svg)/gi;
  const ids = Array.from(new Set((fileContents.match(idRE) || []).map(s => s.trim())));

  // If no local images, keep your previous simple text download path
  if (ids.length === 0) {
    const suggestedName = `${baseName}.txt`;
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName,
        types: [{ description: 'Modern Slides', accept: { 'text/plain': ['.txt'] } }]
      });
      const w = await handle.createWritable();
      await w.write(new Blob([fileContents], { type: 'text/plain' }));
      await w.close();
    } catch (err) {
      if (err?.name === 'AbortError') {
        console.info('Text download cancelled by user.');
        return;
      }
      console.warn("Save picker failed; falling back to anchor download.", err);
      const blob = new Blob([fileContents], { type: 'text/plain' });
      const a = Object.assign(document.createElement('a'), {
        href: URL.createObjectURL(blob),
        download: suggestedName,
        style: 'display:none'
      });
      document.body.appendChild(a); a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }
    return;
  }

  // With local images: build a ZIP (Slides.txt + images at root)
  try {
    if (!window.JSZip) {
      const s = document.createElement('script');
      s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
      await new Promise((res, rej) => { s.onload = res; s.onerror = rej; document.head.appendChild(s); });
    }

    const zip = new JSZip();
    zip.file(`${baseName}.txt`, fileContents);

    for (const imageId of ids) {
      const rec = await ImageStore.getImage(imageId);
      if (rec?.blob) {
        // Put images at ZIP root → matches text references exactly
        zip.file(imageId, rec.blob);
      }
    }

    const zipBlob = await zip.generateAsync({ type: 'blob' });
    const suggestedZip = `${baseName}.zip`;

    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: suggestedZip,
        types: [{ description: 'Modern Slides (ZIP)', accept: { 'application/zip': ['.zip'] } }]
      });
      const w = await handle.createWritable();
      await w.write(zipBlob);
      await w.close();
    } catch (err) {
      if (err?.name === 'AbortError') {
        console.info('ZIP download cancelled by user.');
        return;
      }
      console.warn("Save picker failed; falling back to anchor ZIP download.", err);
      const a = Object.assign(document.createElement('a'), {
        href: URL.createObjectURL(zipBlob),
        download: suggestedZip,
        style: 'display:none'
      });
      document.body.appendChild(a); a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }
  } catch (err) {
    console.error('Zip creation failed:', err);
    alert('Failed to create ZIP. Downloading text only.');
    const blob = new Blob([fileContents], { type: 'text/plain' });
    const a = Object.assign(document.createElement('a'), {
      href: URL.createObjectURL(blob),
      download: `${baseName}.txt`,
      style: 'display:none'
    });
    document.body.appendChild(a); a.click();
    setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }
};


    // Print with PrintNote class notes button
    $("print-notes-btn").onclick = () => {
      //  Save the current textarea 
      updateGroundTruth('SAVE');          
      buildSlidesFromXMLDoc();  

      // Add print notes class to body
      document.body.classList.add('print-with-notes');
      
      // Inject print notes into slides
      state.slideEls.forEach((slideEl, index) => {
        const rawText = getRawTextForSlide(index);
        const { attributes } = parseRawText(rawText);
        
        // Remove any existing print notes div
        const existingNotes = slideEl.querySelector('.print-notes-content');
        if (existingNotes) existingNotes.remove();
        
        if (attributes.printNotes) {
          const printNotesDiv = document.createElement('div');
          printNotesDiv.className = 'print-notes-content';
          printNotesDiv.innerHTML = plainTextToHtml(attributes.printNotes);
          slideEl.appendChild(printNotesDiv);
        }
      });

      // Clean up after print
      setTimeout(() => {
        window.print();
        document.body.classList.remove('print-with-notes');
        document.querySelectorAll('.print-notes-content').forEach(el => el.remove());
      }, 1000);
    };


    // handle opening new deck
    const newDeckModal = $("new-deck-modal");
    const newDeckInput = $("new-deck-name");
    const cancelNewDeckBtn = $("cancel-new-deck");
    const confirmNewDeckBtn = $("confirm-new-deck");

    const closeNewDeckModal = () => {
      newDeckModal?.classList.remove('active');
    };

    const handleCreateNewDeck = () => {
      const desiredName = sanitizeDeckName(newDeckInput ? newDeckInput.value : '');
      const xml = buildNewPresentationXML(desiredName);
      closeNewDeckModal();
      window.presentationBaseUrl = undefined;
      init(xml, { fileName: desiredName, slideIndex: 0, reason: 'new' });
    };

    if (cancelNewDeckBtn) {
      cancelNewDeckBtn.onclick = () => {
        closeNewDeckModal();
      };
    }

    if (confirmNewDeckBtn) {
      confirmNewDeckBtn.onclick = () => {
        handleCreateNewDeck();
      };
    }

    if (newDeckInput) {
      newDeckInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          handleCreateNewDeck();
        } else if (event.key === 'Escape') {
          event.preventDefault();
          closeNewDeckModal();
        }
      });
    }

    if (newDeckModal) {
      newDeckModal.addEventListener('click', (event) => {
        if (event.target === newDeckModal) {
          closeNewDeckModal();
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && newDeckModal.classList.contains('active')) {
          event.preventDefault();
          event.stopPropagation();
          closeNewDeckModal();
        }
      }, true);
    }

    const openNewDeckModal = () => {
      if (!newDeckModal) {
        handleCreateNewDeck();
        return;
      }
      newDeckModal.classList.add('active');
      if (newDeckInput) {
        newDeckInput.value = sanitizeDeckName('');
        setTimeout(() => {
          newDeckInput.focus();
          newDeckInput.select();
        }, 0);
      }
    };


    // New presentation button
    $("new-presentation-btn").onclick = () => {
      openNewDeckModal();
    };


    // Load presentation button
    $("load-btn").onclick = () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.slides,.txt,text/xml,text/plain';
      input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        state.currentFilename = file.name.replace(/\.[^/.]+$/, "");
        const reader = new FileReader();
        reader.onload = re => {
          const content = re.target.result;
          let newXML = content.trim().startsWith('<?xml') || content.trim().startsWith('<presentation')
            ? content
            : convertTxtToXML(content, file.name);
          init(newXML, { fileName: state.currentFilename, slideIndex: 0, reason: 'load' }); // Re-initialize with loaded file
        };
      reader.readAsText(file);
      };
      input.click();
    };


    // Restore previous slideshow
    $("restore-btn").onclick = () => {
      const btn = $("restore-btn");
      if (!btn || btn.disabled) return;

      const previousSession = localStorage.getItem(PREVIOUS_SESSION_KEY);
      const previousMeta = parseDeckIdentityMeta(localStorage.getItem(PREVIOUS_SESSION_META_KEY));
      if (!previousSession) {
        updateRestoreButtonState();
        return;
      }

      const label = previousMeta?.label || 'the previous deck';
      const proceed = confirm(`Restore ${label}? This will replace the deck you are currently editing.`);
      if (!proceed) return;

      try {
        init(previousSession, { slideIndex: 0, reason: 'restore' });
      } catch (err) {
        console.error('Failed to restore previous session', err);
      }
    };


    // Open/close help
    $("help-btn").onclick = () => $("help").classList.add("active");
    $("close-help").onclick = () => $("help").classList.remove("active");


// Local image Manager
$("manage-images-btn").onclick = async () => {
  const modal = $("image-manager");
  const listDiv = $("image-list");

  // Find all local image ids referenced anywhere in the deck text
  const deckTxt = buildRawDeck();
  const idRE = /local-img-[a-z0-9-]+\.(?:png|jpg|jpeg|gif|webp|svg)/gi;
  const used = new Set((deckTxt.match(idRE) || []).map(s => s.trim()));

  const all = await ImageStore.getAllImages();
  if (!all.length) {
    listDiv.innerHTML = '<p style="color:#999;">No images stored.</p>';
  } else {
    listDiv.innerHTML = all.map(rec => {
      const inUse = used.has(rec.id);
      const url = ImageStore.getObjectURLForId(rec.id) || URL.createObjectURL(rec.blob);
      if (!ImageStore.idToURL.has(rec.id)) { ImageStore.idToURL.set(rec.id, url); }
      const kb = (rec.blob.size / 1024).toFixed(1);
      return `
        <div style="display:flex;align-items:center;gap:1rem;padding:0.5rem 0;border-bottom:1px solid #ddd;">
          <img src="${url}" style="width:60px;height:60px;object-fit:cover;border-radius:4px;">
          <div style="flex:1;">
            <div style="font-family:monospace">${rec.id}</div>
            <div style="font-size:0.9em;color:#666;">${kb} KB ${inUse ? '• In use' : '• <span style="color:#999;">Unused</span>'}</div>
          </div>
          ${inUse ? '' : `<button data-del="${rec.id}" style="padding:0.25rem 0.5rem;">Delete</button>`}
        </div>`;
    }).join('');
  }

  // Attach delete handlers (only for unused)
  listDiv.querySelectorAll('button[data-del]').forEach(btn => {
    btn.onclick = async () => {
      const id = btn.getAttribute('data-del');
      if (confirm(`Delete ${id}?`)) {
        await ImageStore.deleteImage(id);
        $("manage-images-btn").click(); // refresh list
      }
    };
  });

  modal.classList.add("active");
};
$("close-image-manager").onclick = () => $("image-manager").classList.remove("active");

    // Text editor - this is the main source of changes.
    $("raw-text-editor").addEventListener('input', () => {
      state.hasChanges = true;
      validateAndUpdateTextarea(); // Live preview update
      updateSaveButtonGlow();
    });

// Paste images into the editor → store in IndexedDB → insert Image: local-img-... line
$("raw-text-editor").addEventListener('paste', async (e) => {
  const items = e.clipboardData?.items;
  if (!items || !items.length) return;

  const images = Array.from(items).filter(it => it.type && it.type.startsWith('image/'));
  if (images.length === 0) return;

  e.preventDefault();
  const textarea = $("raw-text-editor");
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const before = textarea.value.slice(0, start);
  const after  = textarea.value.slice(end);

  const insertLines = [];
  for (const it of images) {
    const file = it.getAsFile();
    if (!file) continue;
    const id = await ImageStore.storeImage(file, 'clipboard');
    insertLines.push(`Image: ${id}`);
  }

  const insertion = (before.endsWith('\n') || before.length === 0 ? '' : '\n') +
                    insertLines.join('\n') + '\n';
  textarea.value = before + insertion + after;
  const newCaret = (before + insertion).length;
  textarea.selectionStart = textarea.selectionEnd = newCaret;

  state.hasChanges = true;
  validateAndUpdateTextarea();
  updateSaveButtonGlow();
});

// let me drag and drop images too
    const editor = $("raw-text-editor");

    // 1. Prevent browser from opening the file
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      editor.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
      }, false);
    });

    // 2. Visual feedback (optional: you can style .dragging in CSS if you want)
    editor.addEventListener('dragover', (e) => {
      editor.classList.add('dragging'); 
      e.dataTransfer.dropEffect = 'copy'; // Explicitly show copy cursor
    });

    editor.addEventListener('dragleave', () => {
      editor.classList.remove('dragging');
    });

    // 3. Handle the drop
    editor.addEventListener('drop', async (e) => {
      editor.classList.remove('dragging');
      const files = e.dataTransfer.files;
      
      if (!files || !files.length) return;

      // Filter for images only
      const images = Array.from(files).filter(file => file.type.startsWith('image/'));
      if (images.length === 0) return;

      // Insert at current cursor position (or end if not focused)
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      const before = editor.value.slice(0, start);
      const after = editor.value.slice(end);

      const insertLines = [];
      for (const file of images) {
        // Reuse your existing ImageStore logic
        const id = await ImageStore.storeImage(file, file.name);
        // Use the filename as the initial caption
        insertLines.push(`Image: ${id}, ${file.name}`);
      }

      const insertion = (before.endsWith('\n') || before.length === 0 ? '' : '\n') +
                        insertLines.join('\n') + '\n';
      
      editor.value = before + insertion + after;
      
      // Update cursor position to be after the new text
      const newCaret = (before + insertion).length;
      editor.selectionStart = editor.selectionEnd = newCaret;

      // Trigger app updates
      state.hasChanges = true;
      validateAndUpdateTextarea();
      updateSaveButtonGlow();
    });


    // allow shortcuts in text
    $("raw-text-editor").addEventListener('keydown', (e) => {
      const textarea = e.target;

      const isBulletShortcut = (e.key === 'b' || e.key === 'B') && (e.ctrlKey || e.metaKey);
      if (isBulletShortcut) {
        e.preventDefault();

        const { selectionStart, value } = textarea;
        const bullet = '• ';
        const alreadyPresent =
          selectionStart >= bullet.length &&
          value.slice(selectionStart - bullet.length, selectionStart) === bullet;

        if (alreadyPresent) {
          textarea.selectionStart = textarea.selectionEnd = selectionStart;
          return;
        }

        textarea.value =
          value.slice(0, selectionStart) +
          bullet +
          value.slice(selectionStart);
        const newCaret = selectionStart + bullet.length;
        textarea.selectionStart = textarea.selectionEnd = newCaret;
        textarea.dispatchEvent(new Event('input'));
        return;
      }

      // Check if user just typed a colon after a single letter at line start
      if (e.key !== ':') return;

      const cursorPos = textarea.selectionStart;
      const textBefore = textarea.value.substring(0, cursorPos);

      // Check if we're at the start of a line with just a single letter
      const lines = textBefore.split('\n');
      const currentLine = lines[lines.length - 1];

      // Match single letter at start of line
      if (currentLine.length !== 1) return;

      const letter = currentLine;
      const shortcuts = {
        'b': 'BigText',
        'C': 'Columns:\n  ',
        'I': 'Image',
        'q': 'Blockquote()',
        'T': 'Table:\n  ',
        'W': 'FullScreenWebsite',
        'n': 'Notes',
        's': 'SmallText',
        'y': 'TinyText',
        'h': 'Header',
        't': 'Title',
        'x': 'Text',
        'P': 'PrintNote',
        'S': 'SpeakerNote',
        'F': 'FullScreenImage',
        'B': 'Background'
      };

      if (shortcuts[letter]) {
        e.preventDefault();

        // Replace the letter with the full directive
        const lineStartPos = cursorPos - 1;
        const before = textarea.value.substring(0, lineStartPos);
        const after = textarea.value.substring(cursorPos);

        const precomposed = new Set(['C','T']);
        const insertion = precomposed.has(letter) ? shortcuts[letter]
          : shortcuts[letter] + ': ';

        textarea.value = before + insertion + after;
        textarea.selectionStart = textarea.selectionEnd = before.length + insertion.length;

        // Trigger input event for live preview
        textarea.dispatchEvent(new Event('input'));
      }
    });


    // Change slideshow style
    $("theme-selector").onchange = async () => {
      const selector = $("theme-selector");
      const themeValue = selector.value;
      updateGroundTruth('THEME_CHANGE', { theme: themeValue });
      state.pendingThumbScrollIndex = state.currentAbsoluteSlideIndex;
      await applyTheme(themeValue);
      const label = selector.options[selector.selectedIndex]?.textContent?.trim() || themeValue;
      setEditorStatus(`Theme changed to ${label}.`);
    };


    // Toggle fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.log(`Error attempting to enable fullscreen: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    }


    // undo last task
    const undoBtn = $("undo-btn");
    if (undoBtn) {
      undoBtn.addEventListener('click', () => {
        handleUndo().catch(err => console.error(err));
      });
    }


    // redo last task
    const redoBtn = $("redo-btn");
    if (redoBtn) {
      redoBtn.addEventListener('click', () => {
        handleRedo().catch(err => console.error(err));
      });
    }

    syncEditModeClass();
    updateUndoRedoButtons();
    updateOverflowWarningForEditor();
    updateRestoreButtonState();
  }
  
  /* ═══════════════════════════════════════════════════════════════
                          IMPORT SLIDESHOW
     ═══════════════════════════════════════════════════════════════ */
  
  function convertTxtToXML(txtContent, filename) {
    let title = filename.replace(/\.(txt|xml)$/i, '') || "Imported Presentation";
    let theme = DEFAULT_THEME;
    let showSlideCount = "true";
    let logoUrl = "";
    
    let contentToProcess = txtContent;
    if (txtContent.trim().startsWith('# METADATA:')) {
      const metadataEndIndex = txtContent.indexOf('\n# Slide(');
      if (metadataEndIndex !== -1) {
        const metadataSection = txtContent.substring(0, metadataEndIndex);
        contentToProcess = txtContent.substring(metadataEndIndex);
        
        const metadataLines = metadataSection.split('\n');
        metadataLines.forEach(line => {
          const match = line.match(/^(\w+):\s*(.*)$/);
          if (match) {
            const [, key, value] = match;
            switch(key) {
              case 'Title': title = value.trim(); break;
              case 'Theme': theme = value.trim(); break;
              case 'ShowSlideCount': showSlideCount = value.trim(); break;
              case 'LogoUrl': logoUrl = value.trim(); break;
            }
          }
        });
      }
    }
    
    const parts = contentToProcess.split(/^# Slide\(\d+\):\s*$/m);
    const slideMatches = parts.filter(part => part.trim() !== '');
    
    let xml = `<presentation title="${escapeHtml(title)}" showSlideCount="${showSlideCount}" theme="${theme}"`;
    if (logoUrl) {
      xml += ` logoUrl="${escapeHtml(logoUrl)}"`;
    }
    xml += `>`;
    
    slideMatches.forEach(slideContent => {
      const cleanContent = slideContent.trim();
      if (cleanContent) {
        xml += `\n  <slide>\n    <raw><![CDATA[\n${cleanContent}\n    ]]></raw>\n  </slide>`;
      }
    });
    
    xml += '\n</presentation>';
    return xml;
  }
  
  /* ==================================================================
                        PRESENTER MODE
  ================================================================= */

  function disposePresenterTimer() {
    if (state.presenterTimerInterval) {
      clearInterval(state.presenterTimerInterval);
      state.presenterTimerInterval = null;
    }
  }

  function cleanupPresenterWindowReference() {
    disposePresenterTimer();
    if (state.presenterWindow && !state.presenterWindow.closed) {
      try {
        state.presenterWindow.close();
      } catch (err) {
        console.warn('Unable to close presenter window cleanly.', err);
      }
    }
    state.presenterWindow = null;
  }

  function openPresenterMode() {
    // Open a new window for presenter view
    if (state.presenterWindow && !state.presenterWindow.closed) {
      state.presenterWindow.focus();
      return;
    }

    disposePresenterTimer();
    const presenterWindow = window.open('', 'presenter', 'width=1200,height=800');

    if (!presenterWindow) {
      alert('Please allow popups to use presenter mode');
      return;
    }
    
    // Set up presenter view HTML
    presenterWindow.document.write(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Presenter View</title>
        <style>
          ${document.getElementById('core-styles').textContent}
        </style>
      </head>
      <body class="presenter-body">
        <div class="presenter-slide-container">
          <div class="presenter-slide-label">Current Slide</div>
          <iframe id="current-slide"></iframe>
        </div>
        <div class="presenter-slide-container">
          <div class="presenter-slide-label">Next Slide</div>
          <iframe id="next-slide"></iframe>
        </div>
        <div class="presenter-notes-section">
          <h3>Speaker Notes</h3>
          <div id="notes-content">No notes for this slide</div>
        </div>
        <div class="presenter-timer-section">
          <div>Elapsed Time</div>
          <div class="presenter-timer" id="timer">00:00</div>
        </div>
        <div class="presenter-controls">
          <button onclick="window.opener.prevSlide()">Previous</button>
          <button onclick="window.opener.nextSlide()">Next</button>
        </div>
      </body>
      </html>
    `);

    // Store reference to presenter window
    state.presenterWindow = presenterWindow;
    presenterWindow.addEventListener('beforeunload', cleanupPresenterWindowReference, { once: true });

    // Start timer
    let startTime = Date.now();
    state.presenterTimerInterval = window.setInterval(() => {
      if (!state.presenterWindow || state.presenterWindow.closed) {
        cleanupPresenterWindowReference();
        return;
      }
      const elapsed = Date.now() - startTime;
      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      presenterWindow.document.getElementById('timer').textContent =
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
    
    // Update presenter view when slides change
    updatePresenterView();
  }

  function updatePresenterView() {
    if (!state.presenterWindow || state.presenterWindow.closed) return;
    
    const currentIndex = state.currentAbsoluteSlideIndex;
    let nextIndex;
    const currentVisiblePosition = state.visibleSlideIndices.indexOf(currentIndex);

    // Check if the current slide is visible and not the last one.
    if (currentVisiblePosition !== -1 && currentVisiblePosition < state.visibleSlideIndices.length - 1) {
        // If so, the next slide is the next one in the visible list.
        nextIndex = state.visibleSlideIndices[currentVisiblePosition + 1];
    } else {
        // Otherwise (if on the last visible slide or a hidden slide), just show the current slide again in the "Next" preview.
        nextIndex = currentIndex;
    }
    
    // Get current and next slide HTML
    const currentSlideHTML = state.slideEls[currentIndex].outerHTML;
    const nextSlideHTML = state.slideEls[nextIndex].outerHTML;
    
    // Get theme CSS
    const themeId = AVAILABLE_THEMES.find(name => document.body.classList.contains(name)) || DEFAULT_THEME;
    const themeLink = document.getElementById(`${themeId}-stylesheet`);
    const themeHref = themeLink ? themeLink.href : '';
    
    // Create standalone HTML for iframes
const slideTemplate = (slideHTML) => `
  <!DOCTYPE html>
  <html>
  <head>
    <base href="${document.baseURI}">
<style>
  ${document.getElementById('core-styles').textContent}
  body { margin: 0; overflow: hidden; }
  .slide-wrapper {
    position: relative;
    width: 100%;
    height: auto;
    aspect-ratio: 16 / 9;
    container-type: inline-size;
    container-name: slideshow;
    font-size: var(--slide-base-font-size);
  }
  #slideshow { position: absolute; inset: 0; }
  .slide { position: absolute; inset: 0; display: flex !important; opacity: 1 !important; }
</style>
    <link rel="stylesheet" href="${themeHref}">
  </head>
  <body class="${themeId}">
    <div class="slide-wrapper">
      <div id="slideshow">${slideHTML}</div>
    </div>
  </body>
  </html>
`;
    
    // Update iframes
    state.presenterWindow.document.getElementById('current-slide').srcdoc = slideTemplate(currentSlideHTML);
    state.presenterWindow.document.getElementById('next-slide').srcdoc = slideTemplate(nextSlideHTML);
    
    // Update notes
    const rawText = getRawTextForSlide(currentIndex);
    const { attributes } = parseRawText(rawText);
    const notesElement = state.presenterWindow.document.getElementById('notes-content');
    notesElement.textContent = attributes.speakerNote || 'No notes for this slide';
  }

  // Add these helper functions to expose navigation to presenter window
  window.nextSlide = function() {
    const nextIndex = state.editMode ? 
      state.currentAbsoluteSlideIndex + 1 : 
      state.currentVisibleSlideIndex + 1;
    showSlide(nextIndex, !state.editMode);
  };

  window.prevSlide = function() {
    const prevIndex = state.editMode ? 
      state.currentAbsoluteSlideIndex - 1 : 
      state.currentVisibleSlideIndex - 1;
    showSlide(prevIndex, !state.editMode);
  };  

/* ═══════════════════════════════════════════════════════════════
                          DRAG AND DROP THUMBNAILS IN EDIT MODE
     ═══════════════════════════════════════════════════════════════ */
  
  function makeThumbnailsDraggable() {
    const thumbsContainer = document.getElementById('thumbs');
    
    // Clean up any existing placeholder completely
    const existingPlaceholders = thumbsContainer.querySelectorAll('.thumb-placeholder');
    existingPlaceholders.forEach(p => p.remove());
    
    // Reset the placeholder reference
    if (state.placeholder) {
      if (state.placeholder.parentNode) {
        state.placeholder.parentNode.removeChild(state.placeholder);
      }
      state.placeholder = null;
    }
    
    // Create new placeholder
    state.placeholder = document.createElement('div');
    state.placeholder.className = 'thumb-placeholder';
    state.placeholder.style.display = 'none';
    
    // Remove any existing event listeners before adding new ones
    const thumbs = thumbsContainer.querySelectorAll('.thumb');
    thumbs.forEach((thumb) => {
      // Clone node to remove all event listeners
      const newThumb = thumb.cloneNode(true);
      thumb.parentNode.replaceChild(newThumb, thumb);
      
      // Add fresh event listeners
      newThumb.draggable = true;
      newThumb.addEventListener('dragstart', handleDragStart);
      newThumb.addEventListener('dragend', handleDragEnd);

      // Re-attach click handler
      const index = parseInt(newThumb.dataset.index);
      newThumb.onclick = () => showSlide(index);

      const controls = newThumb.querySelector('.thumb-controls');
      if (controls) {
        const addControl = controls.querySelector('[data-action="add"]');
        if (addControl) {
          addControl.addEventListener('click', async (event) => {
            event.stopPropagation();
            await insertSlideAfter(index);
          });
        }

        const deleteControl = controls.querySelector('[data-action="delete"]');
        if (deleteControl) {
          const disableDelete = state.slideEls.length <= 1;
          deleteControl.disabled = disableDelete;
          deleteControl.title = disableDelete ? 'Cannot delete the only slide' : 'Delete slide';
          deleteControl.addEventListener('click', async (event) => {
            event.stopPropagation();
            await removeSlideAt(index);
          });
        }
      }
    });
    
    // Remove old container event listeners and add fresh ones
    const newContainer = thumbsContainer.cloneNode(false);
    while (thumbsContainer.firstChild) {
      newContainer.appendChild(thumbsContainer.firstChild);
    }
    thumbsContainer.parentNode.replaceChild(newContainer, thumbsContainer);
    
    // Add container event listeners
    newContainer.addEventListener('dragover', handleDragOver);
    newContainer.addEventListener('drop', handleDrop);
  }
  
  function handleDragStart(e) {
    const thumbsContainer = document.getElementById('thumbs');
    state.draggedThumbIndex = Array.from(thumbsContainer.querySelectorAll('.thumb')).indexOf(e.target);
    
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', '');
    
    state.placeholder.style.height = e.target.offsetHeight + 'px';
    state.placeholder.style.width = e.target.offsetWidth + 'px';
  }
  
  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    if (state.draggedThumbIndex === null) return;
    
    const thumbsContainer = e.currentTarget;
    const afterElement = getDragAfterElement(thumbsContainer, e.clientY);
    
    if (state.placeholder.style.display === 'none') {
      state.placeholder.style.display = 'block';
    }
    
    if (afterElement == null) {
      thumbsContainer.appendChild(state.placeholder);
    } else {
      thumbsContainer.insertBefore(state.placeholder, afterElement);
    }
    
    const rect = thumbsContainer.getBoundingClientRect();
    const scrollSpeed = 5;
    const scrollMargin = 50;
    
    if (e.clientY < rect.top + scrollMargin) {
      thumbsContainer.scrollTop -= scrollSpeed;
    } else if (e.clientY > rect.bottom - scrollMargin) {
      thumbsContainer.scrollTop += scrollSpeed;
    }
  }
  
  async function handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (state.draggedThumbIndex === null) return;
    
    const thumbsContainer = document.getElementById('thumbs');
    const allChildren = Array.from(thumbsContainer.children);
    const placeholderIndex = allChildren.indexOf(state.placeholder);
    
    if (placeholderIndex === -1) return;
    
    const thumbsBeforePlaceholder = allChildren.slice(0, placeholderIndex)
      .filter(el => el.classList.contains('thumb')).length;
    
    let newIndex = thumbsBeforePlaceholder;
    
    if (state.draggedThumbIndex < newIndex) {
      newIndex--;
    }
    
    if (state.draggedThumbIndex !== newIndex) {
      await reorderSlides(state.draggedThumbIndex, newIndex);
    }
    
    cleanupDrag();
  }
  
  function handleDragEnd(e) {
    e.target.classList.remove('dragging');
    cleanupDrag();
  }
  
  function cleanupDrag() {
    // Remove placeholder from DOM completely
    if (state.placeholder && state.placeholder.parentNode) {
      state.placeholder.parentNode.removeChild(state.placeholder);
    }
    
    // Hide it just in case
    if (state.placeholder) {
      state.placeholder.style.display = 'none';
    }
    
    // Reset drag state
    state.draggedThumbIndex = null;
    
    // Remove dragging class from any thumb that might still have it
    document.querySelectorAll('.thumb.dragging').forEach(thumb => {
      thumb.classList.remove('dragging');
    });
  }
  
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.thumb:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
  
  async function reorderSlides(fromIndex, toIndex) {
    if (fromIndex === toIndex) return;
    
    updateGroundTruth('REORDER', { fromIndex, toIndex });

    await buildSlidesFromXMLDoc();
    state.pendingThumbScrollIndex = toIndex;
    await refreshThumbnails();
    let newCurrentIndex = toIndex;
    showSlide(newCurrentIndex);
    setEditorStatus(`Slide moved to position ${toIndex + 1}.`);
  }


/* ═══════════════════════════════════════════════════════════════
                          EDITOR FUNCTIONS
     ═══════════════════════════════════════════════════════════════ */

  function setupEditorUI() {
    const p = state.xmlDoc.querySelector("presentation");
    if (!p) return;

    const editorTextarea = $("raw-text-editor");
    if (editorTextarea) {
      editorTextarea.setAttribute('spellcheck', 'true');
      editorTextarea.spellcheck = true;
      editorTextarea.setAttribute('lang', 'en-US');
      editorTextarea.lang = 'en-US';
      editorTextarea.setAttribute('autocapitalize', 'off');
      editorTextarea.setAttribute('autocomplete', 'off');
      editorTextarea.setAttribute('autocorrect', 'off');
    }

    $("show-count").checked = p.getAttribute("showSlideCount") !== "false";
    $("theme-selector").value = p.getAttribute("theme") || DEFAULT_THEME;

    state.pendingThumbScrollIndex = state.currentAbsoluteSlideIndex;
    refreshThumbnails();
    loadTextareaForCurrentSlide();
    updateSaveButtonGlow();
  }

  async function refreshThumbnails() {
    // 1) Bail out if already running to prevent concurrent updates
    if (state.thumbnailRefreshPromise) {
      return state.thumbnailRefreshPromise;
    }

    // 2) The core logic is wrapped in a new Promise that we control
    const promise = new Promise(async (resolve) => {
      const thumbsContainer = $("thumbs");

      // Clear old iframes
      thumbsContainer.querySelectorAll('iframe').forEach(iframe => {
        iframe.src = 'about:blank';
        iframe.remove();
      });

      // Clear old thumbnails. This is what causes the scroll jump.
      thumbsContainer.innerHTML = ''; 
      
      const slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");
      const theme = $("theme-selector").value || DEFAULT_THEME;

      // 3) Rebuild the DOM elements
      for (let i = 0; i < slideNodes.length; i++) {
        const rawText = slideNodes[i].querySelector('raw')?.textContent || '';

        const thumbDiv = document.createElement("div");
        thumbDiv.className = "thumb" + (i === state.currentAbsoluteSlideIndex ? " selected" : "");
        if (slideNodes[i].getAttribute("hidden") === "true") {
          thumbDiv.classList.add("hidden-slide");
        }
        thumbDiv.dataset.index = i;

        const num = document.createElement('div');
        num.className = 'thumb-number';
        num.textContent = i + 1;

        const iframe = document.createElement('iframe');
        iframe.className = 'thumb-iframe';
        iframe.scrolling = "no";
        iframe.loading = "lazy";
        // This await is fine, it just populates the content
        iframe.srcdoc = await getThumbnailHTML(rawText, theme);

        const controls = document.createElement('div');
        controls.className = 'thumb-controls';

        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.title = 'Add slide after';
        addBtn.dataset.action = 'add';
        addBtn.setAttribute('aria-label', 'Add slide after');
        addBtn.innerHTML = '<i class="fa-solid fa-plus"></i>';
        addBtn.addEventListener('click', async (event) => {
          event.stopPropagation();
          await insertSlideAfter(i);
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.title = state.slideEls.length <= 1 ? 'Cannot delete the only slide' : 'Delete slide';
        deleteBtn.dataset.action = 'delete';
        deleteBtn.setAttribute('aria-label', 'Delete slide');
        deleteBtn.innerHTML = '<i class="fa-solid fa-minus"></i>';
        deleteBtn.disabled = state.slideEls.length <= 1;
        deleteBtn.addEventListener('click', async (event) => {
          event.stopPropagation();
          await removeSlideAt(i);
        });

        controls.append(addBtn, deleteBtn);

        thumbDiv.append(num, iframe, controls);
        thumbsContainer.appendChild(thumbDiv);
        thumbDiv.onclick = () => showSlide(i);
      }

      makeThumbnailsDraggable();

      // Wait for the browser's next painting cycle. This gives the browser
      // time to render the new thumbnails and calculate the new scroll height.
      requestAnimationFrame(() => {
        let targetIndex = state.pendingThumbScrollIndex;
        if (!Number.isInteger(targetIndex)) {
          targetIndex = state.currentAbsoluteSlideIndex;
        }

        if (Number.isInteger(targetIndex)) {
          highlightThumb(targetIndex);
        } else {
          const selectedThumb = thumbsContainer.querySelector('.thumb.selected');
          if (selectedThumb) {
            selectedThumb.scrollIntoView({ block: 'nearest', inline: 'nearest' });
          }
        }

        state.pendingThumbScrollIndex = null;
        resolve();
      });
    });

    state.thumbnailRefreshPromise = promise;
    
    // Wait for the process to finish and then clear the lock
    try {
      await promise;
    } finally {
      state.thumbnailRefreshPromise = null;
    }
  }

  function collectSelectionSegments(textarea) {
    if (!textarea) return [];
    const value = textarea.value;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    if (start === end) return [];

    const segments = [];
    let cursor = value.lastIndexOf('\n', start - 1);
    cursor = cursor === -1 ? 0 : cursor + 1;

    while (cursor < end) {
      const lineBreakIdx = value.indexOf('\n', cursor);
      const lineEnd = lineBreakIdx === -1 ? value.length : lineBreakIdx;
      const selStart = Math.max(start, cursor);
      const selEnd = Math.min(end, lineEnd);

      if (selStart < selEnd) {
        let segStart = selStart;
        let segEnd = selEnd;
        const colonIdx = value.indexOf(':', cursor);
        if (colonIdx !== -1 && colonIdx < lineEnd && segStart <= colonIdx) {
          segStart = Math.max(segStart, colonIdx + 1);
          while (segStart < segEnd && /\s/.test(value[segStart])) {
            segStart++;
          }
        }

        while (segEnd > segStart && /\s/.test(value[segEnd - 1])) {
          segEnd--;
        }

        if (segStart < segEnd) {
          segments.push({ start: segStart, end: segEnd });
        }
      }

      if (lineBreakIdx === -1) {
        break;
      }
      cursor = lineEnd + 1;
    }

    return segments;
  }

  function applyMarkersForSelection(textarea, segments, config) {
    if (!segments.length || !config) return;

    const {
      open,
      close,
      combined = false,
      padWithSpaces = false,
      extraBeforeVariants = [],
      extraAfterVariants = [],
      alignTokens = null
    } = config;

    const beforeMarker = padWithSpaces ? `${open} ` : open;
    const afterMarker = padWithSpaces ? ` ${close}` : close;
    const beforeVariants = [beforeMarker, ...extraBeforeVariants.filter(Boolean)];
    const afterVariants = [afterMarker, ...extraAfterVariants.filter(Boolean)];
    if (!beforeVariants.includes(open)) beforeVariants.push(open);
    if (!afterVariants.includes(close)) afterVariants.push(close);
    const scrollTop = textarea.scrollTop;
    let value = textarea.value;
    const alignTokensSet = Array.isArray(alignTokens) && alignTokens.length
      ? new Set(alignTokens)
      : null;

    const identifyAlignMarker = (marker) => {
      if (!marker || !alignTokensSet) return null;
      for (const token of alignTokensSet) {
        if (marker.includes(token)) return token;
      }
      return null;
    };

    const sliceMatches = (source, start, markerList) => {
      if (start < 0) return false;
      return markerList.some(marker =>
        marker && start >= marker.length && source.slice(start - marker.length, start) === marker
      );
    };

    const sliceMatchesAfter = (source, start, markerList) => {
      return markerList.some(marker =>
        marker && source.slice(start, start + marker.length) === marker
      );
    };

    const removeRange = (source, start, end, beforeList, afterList) => {
      const beforeMarker = beforeList.find(marker => marker && start >= marker.length && source.slice(start - marker.length, start) === marker);
      const afterMarker = afterList.find(marker => marker && source.slice(end, end + marker.length) === marker);
      if (!beforeMarker || !afterMarker) {
        return null;
      }

      const beforeStart = start - beforeMarker.length;
      const afterEnd = end + afterMarker.length;
      const inner = source.slice(start, end);
      const value = source.slice(0, beforeStart) + inner + source.slice(afterEnd);
      return {
        value,
        selectionStart: beforeStart,
        selectionEnd: beforeStart + inner.length,
        removedBefore: beforeMarker,
        removedAfter: afterMarker
      };
    };

    if (combined) {
      const first = segments[0];
      const last = segments[segments.length - 1];
      const removeResult = removeRange(value, first.start, last.end, beforeVariants, afterVariants);
      let workingValue = value;
      let selectionStart = first.start;
      let selectionEnd = last.end;
      const removedAlign = removeResult
        ? (identifyAlignMarker(removeResult.removedBefore) || identifyAlignMarker(removeResult.removedAfter))
        : null;

      if (removeResult) {
        workingValue = removeResult.value;
        selectionStart = removeResult.selectionStart;
        selectionEnd = removeResult.selectionEnd;
      }

      if (alignTokensSet) {
        const shouldInsert = removedAlign !== open;
        if (shouldInsert) {
          const insertionStart = selectionStart;
          const closingPos = selectionEnd;
          workingValue = workingValue.slice(0, insertionStart)
            + beforeMarker
            + workingValue.slice(insertionStart);
          const afterOpenEnd = closingPos + beforeMarker.length;
          workingValue = workingValue.slice(0, afterOpenEnd)
            + afterMarker
            + workingValue.slice(afterOpenEnd);
          selectionStart = insertionStart + beforeMarker.length;
          selectionEnd = afterOpenEnd;
        }

        textarea.value = workingValue;
        textarea.selectionStart = selectionStart;
        textarea.selectionEnd = selectionEnd;
      } else if (removeResult) {
        textarea.value = workingValue;
        textarea.selectionStart = selectionStart;
        textarea.selectionEnd = selectionEnd;
      } else {
        const insertionStart = first.start;
        workingValue = workingValue.slice(0, insertionStart) + beforeMarker + workingValue.slice(insertionStart);
        const closingPos = last.end + beforeMarker.length;
        workingValue = workingValue.slice(0, closingPos) + afterMarker + workingValue.slice(closingPos);
        textarea.value = workingValue;
        const selectionStartAfter = insertionStart + beforeMarker.length;
        textarea.selectionStart = selectionStartAfter;
        textarea.selectionEnd = closingPos;
      }

      value = textarea.value;
    } else {
      segments = segments.map(seg => {
        let start = seg.start;
        let end = seg.end;

        for (const marker of ALIGNMENT_MARKERS) {
          const leadingWithSpace = `${marker} `;
          if (value.slice(start, start + leadingWithSpace.length) === leadingWithSpace) {
            start += leadingWithSpace.length;
            continue;
          }
          if (value.slice(start, start + marker.length) === marker) {
            start += marker.length;
          }
        }

        for (const marker of ALIGNMENT_MARKERS) {
          const trailingWithSpace = ` ${marker}`;
          if (end - trailingWithSpace.length >= start && value.slice(end - trailingWithSpace.length, end) === trailingWithSpace) {
            end -= trailingWithSpace.length;
            continue;
          }
          if (end - marker.length >= start && value.slice(end - marker.length, end) === marker) {
            end -= marker.length;
          }
        }

        if (start >= end) {
          return null;
        }
        return { start, end };
      }).filter(Boolean);

      if (!segments.length) {
        textarea.scrollTop = scrollTop;
        return;
      }

      const existingWraps = segments.map(seg => {
        const beforeMatch = beforeVariants.find(marker => marker && value.slice(seg.start - marker.length, seg.start) === marker);
        const afterMatch = afterVariants.find(marker => marker && value.slice(seg.end, seg.end + marker.length) === marker);
        if (beforeMatch && afterMatch) {
          return { type: 'outside', segStart: seg.start, segEnd: seg.end, beforeMatch, afterMatch };
        }

        const insideBefore = beforeVariants.find(marker => marker && value.slice(seg.start, seg.start + marker.length) === marker);
        const insideAfter = afterVariants.find(marker => marker && value.slice(seg.end - marker.length, seg.end) === marker);
        if (insideBefore && insideAfter) {
          return { type: 'inside', segStart: seg.start, segEnd: seg.end, beforeMatch: insideBefore, afterMatch: insideAfter };
        }

        return null;
      });

      const allWrapped = existingWraps.every(Boolean);

      if (allWrapped) {
        for (let i = segments.length - 1; i >= 0; i--) {
          const info = existingWraps[i];
          if (!info) continue;
          if (info.type === 'outside') {
            const beforeStart = info.segStart - info.beforeMatch.length;
            const afterStart = info.segEnd;
            value = value.slice(0, afterStart) + value.slice(afterStart + info.afterMatch.length);
            value = value.slice(0, beforeStart) + value.slice(beforeStart + info.beforeMatch.length);
          } else {
            const beforeStart = info.segStart;
            const afterStart = info.segEnd - info.afterMatch.length;
            value = value.slice(0, afterStart) + value.slice(afterStart + info.afterMatch.length);
            value = value.slice(0, beforeStart) + value.slice(beforeStart + info.beforeMatch.length);
          }
        }

        textarea.value = value;

        const originalRangeStart = segments[0].start;
        const originalRangeEnd = segments[segments.length - 1].end;
        const originalRangeLength = originalRangeEnd - originalRangeStart;

        const firstInfo = existingWraps[0];
        let startAdjustment = 0;
        if (firstInfo?.type === 'outside') {
          const beforePos = firstInfo.segStart - firstInfo.beforeMatch.length;
          if (beforePos < originalRangeStart) {
            startAdjustment = firstInfo.beforeMatch.length;
          }
        }

        let removalWithinRange = 0;
        existingWraps.forEach(info => {
          if (!info) return;
          if (info.type === 'outside') {
            const beforePos = info.segStart - info.beforeMatch.length;
            if (beforePos >= originalRangeStart) {
              removalWithinRange += info.beforeMatch.length;
            }
            const afterPos = info.segEnd;
            if (afterPos <= originalRangeEnd) {
              removalWithinRange += info.afterMatch.length;
            }
          } else {
            removalWithinRange += info.beforeMatch.length + info.afterMatch.length;
          }
        });

        const newSelectionStart = originalRangeStart - startAdjustment;
        const newSelectionEnd = newSelectionStart + (originalRangeLength - removalWithinRange);
        textarea.selectionStart = newSelectionStart;
        textarea.selectionEnd = Math.max(newSelectionStart, newSelectionEnd);
      } else {
        let insertedTotal = 0;
        for (let i = segments.length - 1; i >= 0; i--) {
          const seg = segments[i];
          const hasOuterWrap = sliceMatches(value, seg.start, beforeVariants) && sliceMatchesAfter(value, seg.end, afterVariants);
          const hasInnerWrap = beforeVariants.some(marker => marker && value.slice(seg.start, seg.start + marker.length) === marker)
            && afterVariants.some(marker => marker && value.slice(seg.end - marker.length, seg.end) === marker);
          if (hasOuterWrap || hasInnerWrap) {
            continue;
          }
          value = value.slice(0, seg.start) + beforeMarker + value.slice(seg.start, seg.end) + afterMarker + value.slice(seg.end);
          insertedTotal += beforeMarker.length + afterMarker.length;
        }
        textarea.value = value;
        const selectionStart = segments[0].start;
        const selectionEnd = segments[segments.length - 1].end + insertedTotal;
        textarea.selectionStart = selectionStart;
        textarea.selectionEnd = selectionEnd;
      }
    }

    textarea.scrollTop = scrollTop;
    textarea.dispatchEvent(new Event('input'));
  }

  function applySelectionFormatting(action) {
    const textarea = $("raw-text-editor");
    if (!textarea) return;
    const segments = collectSelectionSegments(textarea);
    if (!segments.length) return;

    textarea.focus({ preventScroll: true });

    switch (action) {
      case 'bold':
        applyMarkersForSelection(textarea, segments, {
          open: '**',
          close: '**'
        });
        break;
      case 'italic':
        applyMarkersForSelection(textarea, segments, {
          open: '*',
          close: '*'
        });
        break;
      case 'bolditalic':
        applyMarkersForSelection(textarea, segments, {
          open: '***',
          close: '***'
        });
        break;
      case 'align-left':
        applyMarkersForSelection(textarea, segments, {
          open: '<<<',
          close: '<<<',
          combined: true,
          padWithSpaces: true,
          extraBeforeVariants: ['||| ', '>>> ', '<<<', '|||', '>>>'],
          extraAfterVariants: [' |||', ' >>>', '<<<', '|||', '>>>'],
          alignTokens: ALIGNMENT_MARKERS
        });
        break;
      case 'align-center':
        applyMarkersForSelection(textarea, segments, {
          open: '|||',
          close: '|||',
          combined: true,
          padWithSpaces: true,
          extraBeforeVariants: ['<<< ', '>>> ', '<<<', '|||', '>>>'],
          extraAfterVariants: [' <<<', ' >>>', '<<<', '|||', '>>>'],
          alignTokens: ALIGNMENT_MARKERS
        });
        break;
      case 'align-right':
        applyMarkersForSelection(textarea, segments, {
          open: '>>>',
          close: '>>>',
          combined: true,
          padWithSpaces: true,
          extraBeforeVariants: ['<<< ', '||| ', '<<<', '|||', '>>>'],
          extraAfterVariants: [' <<<', ' |||', '<<<', '|||', '>>>'],
          alignTokens: ALIGNMENT_MARKERS
        });
        break;
      default:
        break;
    }
  }

  function initSelectionToolbar() {
    const textarea = $("raw-text-editor");
    const toolbar = $("selection-toolbar");
    if (!textarea || !toolbar) return;

    const hideToolbar = () => {
      toolbar.classList.remove('visible');
      toolbar.setAttribute('aria-hidden', 'true');
    };

    const updateToolbar = () => {
      if (textarea.selectionStart === textarea.selectionEnd) {
        hideToolbar();
        return;
      }
      toolbar.classList.add('visible');
      toolbar.setAttribute('aria-hidden', 'false');
    };

    const scheduleUpdate = () => {
      requestAnimationFrame(updateToolbar);
    };

    textarea.addEventListener('select', scheduleUpdate);
    textarea.addEventListener('keyup', scheduleUpdate);
    textarea.addEventListener('mouseup', scheduleUpdate);
    textarea.addEventListener('input', scheduleUpdate);
    textarea.addEventListener('blur', hideToolbar);

    toolbar.addEventListener('mousedown', (event) => {
      event.preventDefault();
    });

    toolbar.addEventListener('click', (event) => {
      const button = event.target.closest('button[data-format]');
      if (!button) return;
      event.preventDefault();
      applySelectionFormatting(button.dataset.format);
      scheduleUpdate();
    });
  }

  function highlightThumb(index) {
    const thumbs = document.querySelectorAll("#thumbs .thumb");
    thumbs.forEach((t, i) =>
      t.classList.toggle("selected", i === index)
    );
    const selected = document.querySelector("#thumbs .thumb.selected");
    if (selected) selected.scrollIntoView({ block: 'nearest', inline: 'nearest' });
  }

  function buildRawDeck() {
    const p = state.xmlDoc.documentElement;
    let txt = `# METADATA:
Title: ${p.getAttribute('title')            || ''}
Theme: ${p.getAttribute('theme')            || 'tufte-base'}
ShowSlideCount: ${p.getAttribute('showSlideCount') || 'true'}
LogoUrl: ${p.getAttribute('logoUrl')        || ''}`;

  Array.from(p.querySelectorAll('slide')).forEach((s, i) => {
    txt += `

# Slide(${i + 1}):

${(s.querySelector('raw')?.textContent || '').trim()}`;
  });

    return txt.trim();
  }

  function getRawTextForSlide(index) {
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
    return slideNode?.querySelector("raw")?.textContent || "";
  }

  function loadTextareaForCurrentSlide() {
    // Always load directly from the single source of truth: the xmlDoc.
    const textarea = $("raw-text-editor");
    if (!textarea) return;
    const raw = getRawTextForSlide(state.currentAbsoluteSlideIndex);
    textarea.value = addCommandGuardsToText(raw);
    textarea.selectionStart = textarea.selectionEnd = 0;
    validateAndUpdateTextarea();
  }

  async function validateAndUpdateTextarea() {
    const textarea = $("raw-text-editor");
    if (!textarea) return;
    const rawText = normalizeTextareaCommandGuards(textarea);

    // Update the live thumbnail preview without mutating XML.
    const thumbIframe = document.querySelector(
      `#thumbs .thumb[data-index="${state.currentAbsoluteSlideIndex}"] iframe`
    );
    if (thumbIframe) {
      const theme = $("theme-selector").value || DEFAULT_THEME;
      thumbIframe.srcdoc = await getThumbnailHTML(rawText, theme);
    }

    // Reflect edits immediately in the main slide canvas so overflow checks stay fresh.
    const slideEl = state.slideEls[state.currentAbsoluteSlideIndex];
    if (slideEl && slideEl.parentElement) {
      const wasActive = slideEl.classList.contains('active');
      const replacement = createSlideElement(rawText);
      if (wasActive) replacement.classList.add('active');
      slideEl.parentElement.replaceChild(replacement, slideEl);
      state.slideEls[state.currentAbsoluteSlideIndex] = replacement;
    }

    scheduleOverflowChecks();
  }

  function captureCurrentSnapshot() {
    if (!state.xmlDoc) return null;
    const serializer = new XMLSerializer();
    return {
      xmlString: serializer.serializeToString(state.xmlDoc),
      currentAbsoluteSlideIndex: state.currentAbsoluteSlideIndex,
      hasChanges: state.hasChanges
    };
  }

  function recordSnapshot(reason) {
    if (state.isRestoringSnapshot) return;
    const snapshot = captureCurrentSnapshot();
    if (!snapshot) return;
    snapshot.reason = reason;
    state.undoStack.push(snapshot);
    if (state.undoStack.length > state.maxUndoDepth) {
      state.undoStack.shift();
    }
    state.redoStack = [];
    updateUndoRedoButtons();
  }

  async function handleUndo() {
    if (state.undoStack.length === 0) return;
    const snapshot = state.undoStack.pop();
    const current = captureCurrentSnapshot();
    if (current) {
      state.redoStack.push(current);
      if (state.redoStack.length > state.maxUndoDepth) {
        state.redoStack.shift();
      }
    }
    await applySnapshot(snapshot);
    updateUndoRedoButtons();
  }

  async function handleRedo() {
    if (state.redoStack.length === 0) return;
    const snapshot = state.redoStack.pop();
    if (!snapshot) return;
    const current = captureCurrentSnapshot();
    if (current) {
      state.undoStack.push(current);
      if (state.undoStack.length > state.maxUndoDepth) {
        state.undoStack.shift();
      }
    }
    await applySnapshot(snapshot);
    updateUndoRedoButtons();
  }

  async function applySnapshot(snapshot) {
    if (!snapshot) return;
    state.isRestoringSnapshot = true;
    try {
      await init(snapshot.xmlString, {
        slideIndex: snapshot.currentAbsoluteSlideIndex,
        fileName: state.currentFilename,
        reason: 'snapshot',
        suppressStatus: true
      });
    } finally {
      state.isRestoringSnapshot = false;
    }

    state.currentAbsoluteSlideIndex = snapshot.currentAbsoluteSlideIndex;
    state.hasChanges = snapshot.hasChanges;
    updateSaveButtonGlow();
    updateToggleHideButtonState();
    updateOverflowWarningForEditor();
  }

  function saveCurrentSlideText(sourceText, reason) {
    if (!state.xmlDoc) return false;
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
    if (!slideNode) return false;
    const rawNode = slideNode.querySelector('raw');
    if (!rawNode) return false;

    const previous = rawNode.textContent || '';
    const next = typeof sourceText === 'string'
      ? stripCommandSpellcheckGuards(sourceText)
      : previous;
    if (previous === next) return false;

    recordSnapshot(reason);
    rawNode.textContent = '';
    rawNode.appendChild(state.xmlDoc.createCDATASection(next));
    state.hasChanges = true;
    return true;
  }

  function updateUndoRedoButtons() {
    const undoBtn = $("undo-btn");
    const redoBtn = $("redo-btn");
    if (!undoBtn || !redoBtn) return;
    undoBtn.disabled = state.undoStack.length === 0;
    redoBtn.disabled = state.redoStack.length === 0;
  }

  const OVERFLOW_SNIPPET_LIMIT = 20;
  const OVERFLOW_TOLERANCE_PX = 1;
  const OVERFLOW_STAGE_WIDTH = 1280;
  const OVERFLOW_STAGE_HEIGHT = 720;
  let overflowMeasureContext = null;

  function getOverflowMeasureContext() {
    if (overflowMeasureContext) {
      return overflowMeasureContext;
    }

    const stage = document.createElement('div');
    stage.id = 'overflow-measure-stage';
    stage.className = 'presentation-viewport';
    stage.style.width = `${OVERFLOW_STAGE_WIDTH}px`;
    stage.style.height = `${OVERFLOW_STAGE_HEIGHT}px`;

    const scaler = document.createElement('div');
    scaler.className = 'presentation-scaler';
    scaler.style.width = '100%';
    scaler.style.height = '100%';

    const wrapper = document.createElement('div');
    wrapper.className = 'slide-wrapper';

    scaler.appendChild(wrapper);
    stage.appendChild(scaler);
    document.body.appendChild(stage);

    overflowMeasureContext = { stage, scaler, wrapper };
    return overflowMeasureContext;
  }

  function measureOverflowForSlide(slideEl) {
    const { wrapper } = getOverflowMeasureContext();
    wrapper.innerHTML = '';

    const clone = slideEl.cloneNode(true);
    clone.classList.remove('has-overflow');
    clone.removeAttribute('data-overflow-snippets');
    clone.querySelectorAll('.overflow-indicator').forEach(node => node.remove());
    const notes = clone.querySelector('.notes');
    if (notes) notes.remove();

    wrapper.appendChild(clone);

    const content = clone.querySelector('.slide-flow-content');
    if (!content) {
      return { hasOverflow: false, snippets: [] };
    }

    const contentRect = content.getBoundingClientRect();
    if (!contentRect.width || !contentRect.height) {
      return { hasOverflow: false, snippets: [] };
    }

    const overflowVert = Math.ceil(content.scrollHeight - content.clientHeight) > OVERFLOW_TOLERANCE_PX;
    const overflowHoriz = Math.ceil(content.scrollWidth - content.clientWidth) > OVERFLOW_TOLERANCE_PX;

    if (!overflowVert && !overflowHoriz) {
      return { hasOverflow: false, snippets: [] };
    }

    const snippets = collectOverflowSnippets(content, contentRect);
    return { hasOverflow: true, snippets };
  }

  function collectOverflowSnippets(container, containerRect) {
    const snippets = [];
    if (!container) return snippets;

    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode(node) {
          return node.textContent && node.textContent.trim()
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_REJECT;
        }
      }
    );

    while (walker.nextNode()) {
      const node = walker.currentNode;
      const range = document.createRange();
      range.selectNodeContents(node);
      const rects = Array.from(range.getClientRects());
      const isOverflowing = rects.some(rect =>
        Math.ceil(rect.bottom - containerRect.bottom) > OVERFLOW_TOLERANCE_PX ||
        Math.ceil(rect.right - containerRect.right) > OVERFLOW_TOLERANCE_PX
      );
      if (isOverflowing) {
        const snippet = node.textContent.trim().replace(/\s+/g, ' ');
        if (snippet) {
          snippets.push(snippet);
          if (snippets.length >= 3) break;
        }
      }
    }

    return snippets;
  }

  function markOverflowForSlide(slideEl) {
    if (!slideEl) return;

    const indicator = slideEl.querySelector('.overflow-indicator');
    if (indicator) indicator.remove();
    slideEl.classList.remove('has-overflow');
    delete slideEl.dataset.overflowSnippets;

    const measurement = measureOverflowForSlide(slideEl);
    if (!measurement.hasOverflow) {
      return;
    }

    const snippets = measurement.snippets;
    slideEl.classList.add('has-overflow');
    slideEl.dataset.overflowSnippets = JSON.stringify(snippets);
  }

  function scheduleOverflowChecks() {
    if (state.pendingOverflowFrame) {
      cancelAnimationFrame(state.pendingOverflowFrame);
    }
    state.pendingOverflowFrame = requestAnimationFrame(() => {
      state.pendingOverflowFrame = null;
      state.slideEls.forEach(markOverflowForSlide);
      updateOverflowWarningForEditor();
    });
  }

  function updateOverflowWarningForEditor() {
    const warning = $("overflow-warning");
    if (!warning) return;

    if (!state.editMode) {
      warning.textContent = '';
      return;
    }

    const slide = state.slideEls[state.currentAbsoluteSlideIndex];
    if (!slide || !slide.classList.contains('has-overflow')) {
      warning.textContent = '';
      return;
    }

    let snippets = [];
    try {
      snippets = slide.dataset.overflowSnippets ? JSON.parse(slide.dataset.overflowSnippets) : [];
    } catch (err) {
      snippets = [];
    }

    if (snippets.length === 0) {
      warning.textContent = 'Content extends beyond the 16×9 frame.';
      return;
    }

    const summary = snippets
      .map(snippet => snippet.slice(0, OVERFLOW_SNIPPET_LIMIT).trim())
      .filter(Boolean)
      .join(' • ');

    warning.textContent = `Content past frame: ${summary}`;
  }

  function setEditorStatus(message, { persist = false, duration = 6000 } = {}) {
    const statusEl = $("editor-status");
    if (!statusEl) return;

    if (state.statusTimeout) {
      clearTimeout(state.statusTimeout);
      state.statusTimeout = null;
    }

    const text = message?.trim() || '';
    state.lastStatusMessage = text;
    statusEl.textContent = text;

    if (text && !persist && duration > 0) {
      state.statusTimeout = window.setTimeout(() => {
        if (state.lastStatusMessage === text) {
          state.lastStatusMessage = '';
          statusEl.textContent = '';
        }
        state.statusTimeout = null;
      }, duration);
    }
  }

  function announceSessionStatus(options = {}) {
    if (options.suppressStatus) {
      setEditorStatus('');
      return;
    }

    const reason = options.reason || '';
    const docTitle = state.xmlDoc?.documentElement?.getAttribute('title')?.trim();
    const filename = (options.fileName || state.currentFilename || '').trim();
    const deckName = docTitle || filename || 'this deck';

    let message = '';
    let persist = false;

    switch (reason) {
      case 'restore':
        message = `Restored ${deckName}.`;
        break;
      case 'restored-last':
      case 'autoload':
        message = `Restored ${deckName} from last session.`;
        break;
      case 'new':
        message = 'Starting a fresh deck.';
        break;
      case 'default':
        message = "Click [?] for help.";
        persist = true;
        break;
      case 'load':
        message = `Loaded ${deckName} from file.`;
        break;
      case 'url':
        message = `Loaded ${deckName} from link.`;
        break;
      case 'snapshot':
        message = '';
        break;
      default:
        if (!reason) {
          message = '';
        }
    }

    if (message) {
      setEditorStatus(message, { persist });
    } else if (options.clearOnEmpty) {
      setEditorStatus('');
    }
  }

  function syncEditModeClass() {
    document.body.classList.toggle('is-edit-mode', !!state.editMode);
  }

  function updateSaveButtonGlow() {
      // The glow is now controlled entirely by the simple hasChanges flag.
      $("save-btn").classList.toggle("glow", state.hasChanges);
  }

  function updateRestoreButtonState() {
    const restoreBtn = $("restore-btn");
    if (!restoreBtn) return;
    const hasPreviousSession = !!localStorage.getItem(PREVIOUS_SESSION_KEY);
    const previousMeta = parseDeckIdentityMeta(localStorage.getItem(PREVIOUS_SESSION_META_KEY));
    const restoreLabel = previousMeta?.label ? `Restore ${previousMeta.label}` : 'Restore most recently saved';
    restoreBtn.disabled = !hasPreviousSession;
    restoreBtn.title = hasPreviousSession ? restoreLabel : 'Nothing to restore yet';
    restoreBtn.setAttribute('aria-label', hasPreviousSession ? `${restoreLabel} slideshow` : 'Restore button disabled until another slideshow is saved');
  }

  function updateToggleHideButtonState() {
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
    const btn = $("toggle-hide-btn");
    const isHidden = slideNode?.getAttribute("hidden") === "true";
    btn.innerHTML = isHidden
      ? '<i class="fa-solid fa-eye"></i>'
      : '<i class="fa-solid fa-eye-slash"></i>';
    btn.title = isHidden ? "Show Slide" : "Hide Slide";
    $("toggle-hide-btn").disabled = !slideNode;
  }

  function updateSlideActionButtons() {
    const totalSlides = state.xmlDoc?.querySelectorAll('presentation > slide').length ?? 0;
    const deleteBtn = $("del-btn");
    if (deleteBtn) {
      const disableDelete = totalSlides <= 1;
      deleteBtn.disabled = disableDelete;
      deleteBtn.title = disableDelete ? "Delete Slide (add more slides to enable)" : "Delete Slide";
    }
  }

  async function insertSlideAfter(index, content = DEFAULT_NEW_SLIDE_CONTENT) {
    const totalSlides = Array.isArray(state.slideEls) ? state.slideEls.length : 0;
    const targetIndex = Math.max(0, Math.min(index + 1, totalSlides));
    updateGroundTruth('ADD_SLIDE', { index: targetIndex, content });
    await buildSlidesFromXMLDoc();
    state.pendingThumbScrollIndex = targetIndex;
    await refreshThumbnails();
    showSlide(targetIndex);
    setEditorStatus(`Slide added at position ${targetIndex + 1}.`);
  }

  async function removeSlideAt(index) {
    const totalSlides = Array.isArray(state.slideEls) ? state.slideEls.length : 0;
    if (totalSlides <= 1) return;
    const clampedIndex = Math.max(0, Math.min(index, totalSlides - 1));
    const nextIndex = clampedIndex >= totalSlides - 1 ? clampedIndex - 1 : clampedIndex;
    updateGroundTruth('DELETE_SLIDE', { index: clampedIndex });
    await buildSlidesFromXMLDoc();
    const targetIndex = Math.max(0, nextIndex);
    state.pendingThumbScrollIndex = targetIndex;
    await refreshThumbnails();
    showSlide(targetIndex, false, { skipEditorSave: true });
    setEditorStatus(`Slide deleted. Now viewing slide ${targetIndex + 1}.`);
  }

  function updateToggleCountButtonState() {
    const btn = $("toggle-count-btn");
    const isOn = $("show-count").checked;
    btn.innerHTML = isOn
      ? '<i class="fa-solid fa-sort-numeric-asc"></i>'
      : '<i class="fa-solid fa-sort-numeric-asc" style="opacity:0.3;"></i>';
    btn.title = isOn ? "Hide Slide Numbers" : "Show Slide Numbers";
  }
 
/* ═══════════════════════════════════════════════════════════════
                    CENTRALIZED STATE UPDATE
   ═══════════════════════════════════════════════════════════════ */

  function updateGroundTruth(action, data = {}) {
    console.log(`[updateGroundTruth] Action: ${action}`, data);

    const editorEl = $("raw-text-editor");
    const editorValue = editorEl ? editorEl.value : null;
    let textPersisted = false;

    if ((action === 'DOWNLOAD' || action === 'SAVE' || action === 'EXIT_EDIT_MODE') && editorValue !== null) {
      textPersisted = saveCurrentSlideText(editorValue, action);
      if (textPersisted) {
        console.log(`[updateGroundTruth] Saved current slide text for ${action}`);
      }
    }

    // 1. Create DOM if needed (for new/load/init actions)
    if (action === 'INIT' || action === 'LOAD' || action === 'NEW') {
      const xmlString = data.xmlString || MINIMAL_NEW_XML;
      const parser = new DOMParser();
      const tempDoc = parser.parseFromString(xmlString, "text/xml");

      if (tempDoc.getElementsByTagName("parsererror").length > 0) {
        alert("Error parsing presentation XML. Loading default.");
        state.xmlDoc = parser.parseFromString(MINIMAL_NEW_XML, "text/xml");
      } else {
        state.xmlDoc = tempDoc;
      }

      // Reset other state
      state.hasChanges = false;
      state.visibleSlideIndices = [];
      state.slideEls = [];
      const slideNodes = state.xmlDoc.querySelectorAll('presentation > slide');
      const parsedIndex = Number.isFinite(Number(data.slideIndex)) ? Number(data.slideIndex) : 0;
      const requestedIndex = Math.trunc(parsedIndex);
      const maxIndex = Math.max(0, slideNodes.length - 1);
      const clampedIndex = Math.max(0, Math.min(requestedIndex, maxIndex));
      state.currentAbsoluteSlideIndex = clampedIndex;
      state.currentVisibleSlideIndex = clampedIndex;
      if (action === 'NEW') {
        state.currentFilename = 'New Presentation';
      }

      if (!state.isRestoringSnapshot) {
        state.undoStack = [];
        state.redoStack = [];
        updateUndoRedoButtons();
      }
      const docTitle = state.xmlDoc.documentElement?.getAttribute('title');
      if (data.fileName) {
        state.currentFilename = data.fileName;
      } else if (docTitle) {
        state.currentFilename = docTitle;
      } else if (!state.currentFilename) {
        state.currentFilename = 'New Presentation';
      }
      console.log(`[updateGroundTruth] Created new XML DOM from ${action}`);
    }

    // 2. Update current slide text (for most actions except init)
    if (!textPersisted && action !== 'INIT' && action !== 'LOAD' && action !== 'NEW' && state.editMode && editorValue !== null) {
      if (saveCurrentSlideText(editorValue, action)) {
        textPersisted = true;
        console.log(`[updateGroundTruth] Updated slide ${state.currentAbsoluteSlideIndex} text`);
      }
    }

    // 3. Handle reordering (add, delete, rearrange)
    if (action === 'REORDER') {
      const { fromIndex, toIndex } = data;

      recordSnapshot('REORDER');

      // keep a handle on whichever slide is *currently* selected
      const curSlideNode =
        state.xmlDoc.querySelectorAll('presentation > slide')[state.currentAbsoluteSlideIndex];

      const pres   = state.xmlDoc.querySelector('presentation');
      const slides = Array.from(pres.querySelectorAll('slide'));
      const moved  = slides[fromIndex];

      // physically move the node
      pres.insertBefore(
        moved,
        (fromIndex < toIndex) ? slides[toIndex].nextSibling : slides[toIndex]
      );

      // recompute where the current slide ended up
      const newOrder = Array.from(pres.querySelectorAll('slide'));
      state.currentAbsoluteSlideIndex = newOrder.indexOf(curSlideNode);

      state.hasChanges = true;
      console.log(
        `[updateGroundTruth] Reordered slide ${fromIndex} → ${toIndex}. ` +
        `Current slide is now ${state.currentAbsoluteSlideIndex}`
      );
    }

    if (action === 'ADD_SLIDE') {
      const { index, content } = data;
      recordSnapshot('ADD_SLIDE');
      const newSlideNode = state.xmlDoc.createElement('slide');
      const rawNode = state.xmlDoc.createElement('raw');
      rawNode.appendChild(state.xmlDoc.createCDATASection(content));
      newSlideNode.appendChild(rawNode);

      const slides = state.xmlDoc.querySelectorAll("presentation > slide");
      state.xmlDoc.querySelector("presentation").insertBefore(
        newSlideNode, 
        slides[index] || null
      );
      
      state.hasChanges = true;
      console.log(`[updateGroundTruth] Added slide at index ${index}`);
    }

    if (action === 'DELETE_SLIDE') {
      const { index } = data;
      recordSnapshot('DELETE_SLIDE');
      state.xmlDoc.querySelectorAll("presentation > slide")[index].remove();
      state.hasChanges = true;
      console.log(`[updateGroundTruth] Deleted slide at index ${index}`);
    }

  // 4. Update theme and other metadata
    if (action === 'THEME_CHANGE' || action === 'TOGGLE_COUNT' || action === 'SAVE' || action === 'EXIT_EDIT_MODE') {
      const presNode = state.xmlDoc.querySelector("presentation");
      let metadataChanged = false;

      if (action === 'THEME_CHANGE') {
        if (presNode.getAttribute("theme") !== data.theme) {
          recordSnapshot('THEME_CHANGE');
          presNode.setAttribute("theme", data.theme);
          metadataChanged = true;
        }
      }

      if (action === 'TOGGLE_COUNT') {
        const newValue = $("show-count").checked ? "true" : "false";
        if (presNode.getAttribute("showSlideCount") !== newValue) {
          recordSnapshot('TOGGLE_COUNT');
          presNode.setAttribute("showSlideCount", newValue);
          metadataChanged = true;
        }
      }

      // Scan all slides for the last "Logo:" directive to set it globally.
      let lastLogoUrl = null;
      const logoRegex = /^Logo:\s*(.*)/im;
      state.xmlDoc.querySelectorAll("presentation > slide raw").forEach(raw => {
          const match = (raw.textContent || '').match(logoRegex);
          if (match && match[1].trim()) {
              lastLogoUrl = match[1].trim();
          }
      });

      const previousLogo = presNode.getAttribute("logoUrl") || '';
      if (lastLogoUrl) {
          presNode.setAttribute("logoUrl", lastLogoUrl);
      } else {
          presNode.removeAttribute("logoUrl");
      }
      const currentLogo = presNode.getAttribute("logoUrl") || '';
      if (currentLogo !== previousLogo) {
        metadataChanged = true;
      }

      if (metadataChanged) {
        state.hasChanges = true;
      }
    }
    
    // Log current state
    console.log(`[updateGroundTruth] Current state:`, {
      slides: state.xmlDoc.querySelectorAll("presentation > slide").length,
      currentSlide: state.currentAbsoluteSlideIndex,
      hasChanges: state.hasChanges,
      theme: state.xmlDoc.documentElement.getAttribute("theme"),
      logoUrl: state.xmlDoc.documentElement.getAttribute("logoUrl")
    });

    // Finally, save the entire presentation to local storage on every update.
    try {
      const serializer = new XMLSerializer();
      const xmlString = serializer.serializeToString(state.xmlDoc);
      const previousXml = localStorage.getItem(LAST_SESSION_KEY);
      const previousMetaRaw = localStorage.getItem(LAST_SESSION_META_KEY);
      const previousIdentity = parseDeckIdentityMeta(previousMetaRaw) || extractDeckIdentityFromXML(previousXml);
      const currentIdentity = getDeckIdentityFromState();

      if (previousXml && previousXml !== xmlString) {
        if (!previousIdentity || previousIdentity.id !== currentIdentity.id) {
          localStorage.setItem(PREVIOUS_SESSION_KEY, previousXml);
          if (previousIdentity) {
            localStorage.setItem(PREVIOUS_SESSION_META_KEY, JSON.stringify(previousIdentity));
          } else {
            localStorage.removeItem(PREVIOUS_SESSION_META_KEY);
          }
        }
      }

      localStorage.setItem(LAST_SESSION_KEY, xmlString);
      localStorage.setItem(LAST_SESSION_META_KEY, JSON.stringify(currentIdentity));
      console.log('[localStorage] Session saved.');
    } catch (e) {
      console.error('[localStorage] Failed to save session:', e);
    }

    updateRestoreButtonState();
    updateSaveButtonGlow();
  }

  /* ═══════════════════════════════════════════════════════════════
                          NAVIGATION & DISPLAY
     ═══════════════════════════════════════════════════════════════ */
  
  function showSlide(absIndex, fromPresentationNav = false, options = {}) {
    const { skipEditorSave = false } = options || {};

    if (state.editMode && !skipEditorSave) {
      saveCurrentSlideText($("raw-text-editor").value, 'THUMB_CLICK');
    }
    let targetAbsIndex = absIndex;

    if (state.editMode &&
        state.currentAbsoluteSlideIndex >= 0 && absIndex !== state.currentAbsoluteSlideIndex && state.currentAbsoluteSlideIndex < state.slideEls.length) {
      updateGroundTruth('NAVIGATE', { from: state.currentAbsoluteSlideIndex, to: absIndex });
    }
    
    if (fromPresentationNav && !state.editMode) {
      let targetVisibleIndex = Math.max(0, Math.min(absIndex, state.visibleSlideIndices.length - 1));
      targetAbsIndex = state.visibleSlideIndices.length > 0 ? 
        state.visibleSlideIndices[targetVisibleIndex] : 0;
      state.currentVisibleSlideIndex = targetVisibleIndex;
    } else {
      targetAbsIndex = Math.max(0, Math.min(absIndex, state.slideEls.length - 1));
    }
    
    state.slideEls.forEach((s, i) => s.classList.toggle("active", i === targetAbsIndex));
    state.currentAbsoluteSlideIndex = targetAbsIndex;

    // Save current slide index to localStorage (skip during initialization)
    if (!skipEditorSave && state.slideEls.length > 0) {
      localStorage.setItem(LAST_SLIDE_INDEX_KEY, state.currentAbsoluteSlideIndex.toString());
    }

    if (!fromPresentationNav || state.editMode) {
      const visibleIdx = state.visibleSlideIndices.indexOf(state.currentAbsoluteSlideIndex);
      state.currentVisibleSlideIndex = visibleIdx !== -1
        ? visibleIdx
        : resolveVisibleIndexForAbsolute(state.currentAbsoluteSlideIndex);
    }
 
    // This block forces GIFs to restart when a slide becomes active.
    const activeSlide = state.slideEls[targetAbsIndex];
    if (activeSlide) {
      // 1. For GIFs in <img> tags
      const imgGifs = activeSlide.querySelectorAll('img[src*=".gif"]');
      imgGifs.forEach(gif => {
        const originalSrc = gif.src;
        // This trick forces the browser to reload the image and restart the animation
        gif.src = '';
        gif.src = originalSrc;
      });

      // 2. For GIFs used as a background-image
      if (activeSlide.style.backgroundImage.includes('.gif')) {
        const originalBg = activeSlide.style.backgroundImage;
        // Temporarily remove the background, then add it back in the next frame
        activeSlide.style.backgroundImage = 'none';
        requestAnimationFrame(() => {
          activeSlide.style.backgroundImage = originalBg;
        });
      }
    }
    
    updateHUD();
    updatePresenterView();
    
    if (state.editMode) {
      highlightThumb(state.currentAbsoluteSlideIndex);
      loadTextareaForCurrentSlide();
      updateToggleHideButtonState();
    }

    updateOverflowWarningForEditor();
    scheduleOverflowChecks();
  }

  function resolveVisibleIndexForAbsolute(absIndex) {
    if (!Array.isArray(state.visibleSlideIndices) || state.visibleSlideIndices.length === 0) {
      return 0;
    }

    const existingIndex = state.visibleSlideIndices.indexOf(absIndex);
    if (existingIndex !== -1) {
      return existingIndex;
    }

    for (let i = 0; i < state.visibleSlideIndices.length; i++) {
      if (state.visibleSlideIndices[i] > absIndex) {
        return i;
      }
    }

    return state.visibleSlideIndices.length - 1;
  }
  
  function updateHUD() {
    const presNode = state.xmlDoc.querySelector("presentation");
    if (!presNode) return;
    
    const showCount = presNode.getAttribute("showSlideCount") !== "false";
    $("slide-counter").style.display = showCount ? "block" : "none";
    $("progress-bar").style.display = showCount ? "block" : "none";
    
    const logoUrl = presNode.getAttribute("logoUrl");
    const logoEl = $("company-logo");
    logoEl.src = logoUrl || '';
    logoEl.style.display = logoUrl ? "block" : "none";
    
    const numVisibleSlides = state.visibleSlideIndices.length;
    const displayCur = numVisibleSlides > 0 ? state.currentVisibleSlideIndex + 1 : 0;
    const displayTot = numVisibleSlides;
    
    $("cur").textContent = state.editMode ? 
      state.currentAbsoluteSlideIndex + 1 : displayCur;
    $("tot").textContent = state.editMode ? 
      state.slideEls.length : displayTot;
    
    let progressPercent = 0;
    if (state.editMode && state.slideEls.length > 0) {
      progressPercent = ((state.currentAbsoluteSlideIndex + 1) / state.slideEls.length) * 100;
    } else if (!state.editMode && numVisibleSlides > 0) {
      progressPercent = ((state.currentVisibleSlideIndex + 1) / numVisibleSlides) * 100;
    }
    $("progress-bar").style.width = `${progressPercent}%`;
  }  

  function buildSlidesFromXMLDoc() {
    state.slideEls = [];
    $("slideshow").innerHTML = "";
    let slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");

    if (slideNodes.length === 0) {
      addSlide(0, "Title: Empty Slide\n\nText: Add content or load a presentation.");
      slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");
    }

    slideNodes.forEach((slideNode) => {
      const rawText = slideNode.querySelector('raw')?.textContent || '';
      const { attributes } = parseRawText(rawText);
      slideNode.setAttribute('title', attributes.title || 'Untitled');
      attributes.hidden ? 
        slideNode.setAttribute('hidden', 'true') : 
        slideNode.removeAttribute('hidden');

      const slideDiv = createSlideElement(rawText);
      $("slideshow").appendChild(slideDiv);
      state.slideEls.push(slideDiv);
    });

    updateVisibleSlideIndices();

    if (state.slideEls.length === 0) {
      state.currentAbsoluteSlideIndex = 0;
      state.currentVisibleSlideIndex = 0;
    } else {
      state.currentAbsoluteSlideIndex = Math.max(
        0,
        Math.min(state.currentAbsoluteSlideIndex, state.slideEls.length - 1)
      );

      if (state.visibleSlideIndices.length > 0) {
        const visiblePos = state.visibleSlideIndices.indexOf(state.currentAbsoluteSlideIndex);
        state.currentVisibleSlideIndex = visiblePos !== -1
          ? visiblePos
          : resolveVisibleIndexForAbsolute(state.currentAbsoluteSlideIndex);
      } else {
        state.currentVisibleSlideIndex = 0;
      }
    }

    updateSlideActionButtons();
    const finalize = () => {
      scheduleOverflowChecks();
    };

    if (window.MathJax?.typesetPromise) {
      return MathJax.typesetPromise([$("slideshow")]).then(() => finalize());
    }

    finalize();
    return Promise.resolve();
  }
  
  function updateVisibleSlideIndices() {
    state.visibleSlideIndices = [];
    state.xmlDoc.querySelectorAll("presentation > slide").forEach((node, index) => {
      if (node.getAttribute("hidden") !== "true") {
        state.visibleSlideIndices.push(index);
      }
    });
  }
  
  /* ═══════════════════════════════════════════════════════════════
                          SLIDE MANIPULATION
     ═══════════════════════════════════════════════════════════════ */
  
  function addSlide(index, rawContent) {
    const newSlideNode = state.xmlDoc.createElement('slide');
    const rawNode = state.xmlDoc.createElement('raw');
    rawNode.appendChild(state.xmlDoc.createCDATASection(rawContent));
    newSlideNode.appendChild(rawNode);
    
    const slides = state.xmlDoc.querySelectorAll("presentation > slide");
    state.xmlDoc.querySelector("presentation").insertBefore(
      newSlideNode, 
      slides[index] || null
    );
  }
  
  async function updateSingleThumbnail(index) {
    const thumb = document.querySelector(`#thumbs .thumb[data-index="${index}"]`);
    if (!thumb) return;
    
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
    const rawText = slideNode?.querySelector('raw')?.textContent || '';
    const theme = $("theme-selector").value || DEFAULT_THEME;
    
    const iframe = thumb.querySelector('iframe');
    if (iframe) {
      iframe.srcdoc = await getThumbnailHTML(rawText, theme);
    }
    
    // Parse the raw text to check if it's hidden
    const { attributes } = parseRawText(rawText);
    if (attributes.hidden) {
      thumb.classList.add("hidden-slide");
    } else {
      thumb.classList.remove("hidden-slide");
    }
  }  

async function getThumbnailHTML(rawText, theme) {
  const slideElement = createSlideElement(rawText);

  // Remove the hidden-in-presentation class for thumbnails
  slideElement.classList.remove('hidden-in-presentation');

  slideElement.querySelectorAll('iframe').forEach((iframe) => {
    const wrapper = iframe.parentElement;
    const placeholder = wrapper?.querySelector('.website-print-placeholder');
    if (placeholder) {
      placeholder.style.display = 'flex';
    }
    iframe.remove();
  });

  const slideElementHTML = slideElement.outerHTML;
  
  // Get the theme CSS content
  const themeLink = document.getElementById(`${theme}-stylesheet`);
  const themeHref = themeLink ? themeLink.href : '';
  
  // Always use the same wrapper structure for consistency
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <base href="${window.location.href}">
  <style>
    ${document.getElementById('core-styles').textContent}
    body { margin: 0; overflow: hidden; }
    .slide-wrapper {
      position: relative;
      width: 100%;
      height: auto;
      aspect-ratio: 16 / 9;
      container-type: inline-size;
      container-name: slideshow;
      font-size: var(--slide-base-font-size);
    }
    #slideshow { position: absolute; inset: 0; }
    .slide { position: absolute; inset: 0; display: flex !important; opacity: 1 !important; }
  </style>
    <link rel="stylesheet" href="${themeHref}">
</head>
<body class="${theme}">
  <div class="slide-wrapper">
    <div id="slideshow">${slideElementHTML}</div>
  </div>
</body>
</html>`;
}
  
  /* ═══════════════════════════════════════════════════════════════
                          XML HANDLING
     ═══════════════════════════════════════════════════════════════ */
  
  function createSlideElement(rawText) {
    const { attributes, innerHTML } = parseRawText(rawText);
    const slideDiv = document.createElement("div");
    slideDiv.className = "slide";

    if (attributes.hidden) slideDiv.classList.add("hidden-in-presentation");

    let backgroundUrl = null;
    if (attributes.background) {
      const resolvedUrl = resolveImagePath(attributes.background, window.presentationBaseUrl);
      backgroundUrl = resolvedUrl;
      const cssUrl = `url("${resolvedUrl.replace(/"/g, '\\"')}")`;
      slideDiv.style.backgroundImage = cssUrl;
      slideDiv.classList.add("has-background-image");
      if (attributes.isFullScreenImage) slideDiv.classList.add("is-fullscreen-image-slide");
    }
    
    if (attributes.header) {
      const headerDiv = document.createElement("div");
      headerDiv.className = "slide-header";
      headerDiv.innerHTML = plainTextToHtml(attributes.header);
      slideDiv.appendChild(headerDiv);
    }

    // Add iframe for FullScreenWebsite
    if (attributes.fullscreenWebsite) {
      const iframeWrapper = document.createElement("div");
      iframeWrapper.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        height: 90%;
        background: white;
        box-shadow: 0 0 50px rgba(0,0,0,0.3);
        border-radius: 8px;
        overflow: hidden;
        z-index: 100;
      `;
      
      const iframe = document.createElement("iframe");
      iframe.src = attributes.fullscreenWebsite;
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 8px;
      `;
      

      // Create a print-only placeholder
      const placeholder = document.createElement("div");
      placeholder.className = "website-print-placeholder";
      placeholder.innerHTML = `<p><strong>Embedded Website:</strong><br>${escapeHtml(attributes.fullscreenWebsite)}</p>`;
      iframeWrapper.appendChild(placeholder);

      iframeWrapper.appendChild(iframe);
      slideDiv.appendChild(iframeWrapper);
      
      // Add click handler to the slide itself for navigation
      slideDiv.addEventListener('click', (e) => {
        // Get the iframe wrapper bounds
        const wrapperBounds = iframeWrapper.getBoundingClientRect();
        const clickX = e.clientX;
        const clickY = e.clientY;
        
        // Check if click is outside the iframe
        if (clickX < wrapperBounds.left || 
            clickX > wrapperBounds.right || 
            clickY < wrapperBounds.top || 
            clickY > wrapperBounds.bottom) {
          
          // Navigate based on which side was clicked
          if (clickX < window.innerWidth / 2) {
            window.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowLeft' }));
          } else {
            window.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowRight' }));
          }
        }
      });
    }
    
    const contentDiv = document.createElement("div");
    contentDiv.className = "slide-content";

    if (backgroundUrl) {
      const cssUrl = `url("${backgroundUrl.replace(/"/g, '\\"')}")`;
      const backgroundSize = attributes.isFullScreenImage ? 'contain' : 'cover';
      contentDiv.classList.add('has-background-image');
      contentDiv.style.backgroundImage = cssUrl;
      contentDiv.style.backgroundSize = backgroundSize;
      contentDiv.style.backgroundPosition = 'center';
      contentDiv.style.backgroundRepeat = 'no-repeat';
      if (attributes.isFullScreenImage) {
        contentDiv.style.backgroundColor = 'transparent';
      }
    }

    // Create the dedicated wrapper for normal flow content
    const flowContentDiv = document.createElement("div");
    flowContentDiv.className = "slide-flow-content";
    flowContentDiv.innerHTML = innerHTML;
    contentDiv.appendChild(flowContentDiv);
    
    // Check for notes and append them OUTSIDE the flow wrapper
    if (attributes.notes) {
      const notesDiv = document.createElement("div");
      notesDiv.className = "notes";
      notesDiv.innerHTML = plainTextToHtml(attributes.notes);
      contentDiv.appendChild(notesDiv); // Appended as a sibling to flowContentDiv
    }

    slideDiv.appendChild(contentDiv);

    return slideDiv;
  }  

  /* ═══════════════════════════════════════════════════════════════
                      TEXT PARSING & HTML GENERATION
     ═══════════════════════════════════════════════════════════════ */
  function maskMathSegmentsForMarkdown(text) {
    if (!text) return { masked: text, segments: [] };

    const segments = [];
    let result = '';
    let i = 0;
    const len = text.length;

    const makeToken = (idx) => `__MS_MATH_TOKEN_${idx}__`;

    while (i < len) {
      const ch = text[i];
      const next = i + 1 < len ? text[i + 1] : '';

      // $$ ... $$
      if (ch === '$' && next === '$') {
        const start = i;
        let j = i + 2;
        let found = false;
        while (j < len - 1) {
          if (text[j] === '$' && text[j + 1] === '$') {
            found = true;
            break;
          }
          j++;
        }
        if (found) {
          const seg = text.slice(start, j + 2);
          const idx = segments.length;
          segments.push(seg);
          result += makeToken(idx);
          i = j + 2;
          continue;
        }
      }

      // \[ ... \]
      if (ch === '\\' && next === '[') {
        const start = i;
        let j = i + 2;
        let found = false;
        while (j < len - 1) {
          if (text[j] === '\\' && text[j + 1] === ']') {
            found = true;
            break;
          }
          j++;
        }
        if (found) {
          const seg = text.slice(start, j + 2);
          const idx = segments.length;
          segments.push(seg);
          result += makeToken(idx);
          i = j + 2;
          continue;
        }
      }

      // \( ... \)
      if (ch === '\\' && next === '(') {
        const start = i;
        let j = i + 2;
        let found = false;
        while (j < len - 1) {
          if (text[j] === '\\' && text[j + 1] === ')') {
            found = true;
            break;
          }
          j++;
        }
        if (found) {
          const seg = text.slice(start, j + 2);
          const idx = segments.length;
          segments.push(seg);
          result += makeToken(idx);
          i = j + 2;
          continue;
        }
      }

      // $ ... $
      if (ch === '$' && next !== '$') {
        // Respect escaped \$ – leave it alone
        if (i > 0 && text[i - 1] === '\\') {
          result += ch;
          i++;
          continue;
        }
        const start = i;
        let j = i + 1;
        let found = false;
        while (j < len) {
          if (text[j] === '$' && text[j - 1] !== '\\') {
            found = true;
            break;
          }
          j++;
        }
        if (found) {
          const seg = text.slice(start, j + 1);
          const idx = segments.length;
          segments.push(seg);
          result += makeToken(idx);
          i = j + 1;
          continue;
        }
      }

      // Default: copy character through
      result += ch;
      i++;
    }

    return { masked: result, segments };
  }

  function unmaskMathSegmentsForMarkdown(text, segments) {
    if (!segments || !segments.length) return text;
    let out = text;
    segments.forEach((seg, idx) => {
      const token = `__MS_MATH_TOKEN_${idx}__`;
      // Keep escaping behaviour consistent with the rest of the pipeline
      const escapedSeg = escapeHtml(seg);
      out = out.split(token).join(escapedSeg);
    });
    return out;
  }

  function plainTextToHtml(text) {
    if (!text || !text.trim()) return "";
    
    // 1. Mask Math
    const { masked, segments } = maskMathSegmentsForMarkdown(text);
    
    // 2. Escape HTML
    let safeText = escapeHtml(masked);
    
    // 3. Process Markdown (bold/italic) and html links
    // Create links
    safeText = safeText.replace(/!https?:\/\/\S+/g, (match) => {
      let raw = match.slice(1); // remove leading "!"
        // Capture trailing punctuation without deleting it
      const m = raw.match(/^(.*?)([)\].,!?;:]+)$/);
       let url = raw;
      let trailing = "";
      if (m) {
        url = m[1];        // URL without punctuation
        trailing = m[2];   // punctuation preserved
      }
      return `<a href="${url}" target="_blank" rel="noopener">${url}</a>${trailing}`;
    });
    // Make inline bold/italic override any theme-level font-weight/style
    safeText = safeText.replace(
      /\*\*\*(.*?)\*\*\*/g,
      '<strong style="font-weight:bold;"><em style="font-style:italic;">$1</em></strong>'
    );
    safeText = safeText.replace(
      /\*\*(.*?)\*\* /g,
      '<strong style="font-weight:bold;">$1</strong> '
    );
    safeText = safeText.replace(
      /\*\*(.*?)\*\*/g,
      '<strong style="font-weight:bold;">$1</strong>'
    );
    safeText = safeText.replace(
      /\*(.*?)\*/g,
      '<em style="font-style:italic;">$1</em>'
    );

    // 4. Process Lists (before paragraph splitting)
    const listStyle = 'margin:0; padding-left:1.2em; text-align:left;';
    
    // Unordered Lists (* or •)
    safeText = safeText.replace(/(?:^|\n)((?:\s*[•*]\s+.*(?:\n|$))+)/g, (match, block) => {
        const items = block.trim().split('\n').map(l => `<li>${l.replace(/^\s*[•*]\s+/, '')}</li>`).join('');
        return `\n<ul style="${listStyle}">${items}</ul>\n`;
    });

    // Ordered Lists (1., 2. etc)
    safeText = safeText.replace(/(?:^|\n)((?:\s*\d+\.\s+.*(?:\n|$))+)/g, (match, block) => {
        const items = block.trim().split('\n').map(l => `<li>${l.replace(/^\s*\d+\.\s+/, '')}</li>`).join('');
        return `\n<ol style="${listStyle}">${items}</ol>\n`;
    });
    
    // 5. Handle Paragraphs and Breaks
    let html = safeText
      .replace(/\r\n/g, '\n')
      .split(/\n{2,}/)
      .map(p => {
        const t = p.trim();
        // Don't wrap alignment tags OR list tags in <p>
        if (t.startsWith('__ALIGN_') || t.startsWith('<ul') || t.startsWith('<ol')) return p; 
        return `<p>${p.replace(/\n/g, '<br />')}</p>`;
      })
      .join('\n');

     // 6. Unmask Math
     html = unmaskMathSegmentsForMarkdown(html, segments);
     
     return html;
  }

 function formatWithJustify(text) {
  if (!text || !text.trim()) return "";

  // Map markers to CSS classes instead of inline styles
  const ALIGN_CLASS = {
    "<<<": "ms-align-left",
    ">>>": "ms-align-right",
    "|||": "ms-align-center",
  };

  const inlineMarkers = [];

  const addAlignedPlaceholder = (token, rawBody, { block }) => {
    const key = `__ALIGN_${inlineMarkers.length}__`;
    const inner = formatWithJustify(rawBody);
    const tag = block ? 'div' : 'span';
    const cls = ALIGN_CLASS[token] || '';
    inlineMarkers.push({
      key,
      html: `<${tag} class="${cls}">${inner}</${tag}>`
    });
    return key;
  };

  const INLINE_PAIR_RE = /(<<<|>>>|\|\|\|)([\s\S]*?)\1/g;

  // First pass: turn *inline* pairs into placeholders, leave true block fences alone
  const withInlinePlaceholders = text.replace(INLINE_PAIR_RE, (match, tok, body, offset) => {
    const leadingBreak = text.lastIndexOf('\n', offset - 1);
    const beforeToken = leadingBreak === -1 ? text.slice(0, offset) : text.slice(leadingBreak + 1, offset);
    const blockOpening = /^\s*$/.test(beforeToken);

    const closingIndex = offset + tok.length + body.length;
    const closingLineBreak = text.lastIndexOf('\n', closingIndex - 1);
    const beforeClosing = closingLineBreak === -1
      ? text.slice(0, closingIndex)
      : text.slice(closingLineBreak + 1, closingIndex);
    const blockClosing = /^\s*$/.test(beforeClosing);

    if (blockOpening && blockClosing) {
      // Let the outer fence logic handle this as a block
      return match;
    }

    // Inline justified span
    return addAlignedPlaceholder(tok, body, { block: false });
  });

  const FENCES = new Set(["<<<", ">>>", "|||"]);

  const lines = withInlinePlaceholders.split(/\r?\n/);
  const out = [];
  let mode = null;
  let buf = [];

  const replaceInlineKeys = (html) => {
    let s = html;
    for (const { key, html: frag } of inlineMarkers) {
      s = s.split(key).join(frag);
    }
    return s;
  };

  const flushNormal = () => {
    if (buf.length === 0) return;
    const html = plainTextToHtml(buf.join("\n"));
    out.push(replaceInlineKeys(html));
    buf = [];
  };

  const flushBlock = (token) => {
    const bodyRaw = buf.join("\n");

    // Inline pairs *inside* this block also become placeholders
    const bodyWithPlaceholders = bodyRaw.replace(INLINE_PAIR_RE, (match, tok, body, offset) => {
      const leadingBreak = bodyRaw.lastIndexOf('\n', offset - 1);
      const beforeToken = leadingBreak === -1 ? bodyRaw.slice(0, offset) : bodyRaw.slice(leadingBreak + 1, offset);
      const blockOpening = /^\s*$/.test(beforeToken);

      const closingIndex = offset + tok.length + body.length;
      const closingLineBreak = bodyRaw.lastIndexOf('\n', closingIndex - 1);
      const beforeClosing = closingLineBreak === -1
        ? bodyRaw.slice(0, closingIndex)
        : bodyRaw.slice(closingLineBreak + 1, closingIndex);
      const blockClosing = /^\s*$/.test(beforeClosing);

      if (blockOpening && blockClosing) {
        return match;
      }

      return addAlignedPlaceholder(tok, body, { block: false });
    });

    const bodyHtml = replaceInlineKeys(plainTextToHtml(bodyWithPlaceholders));
    const cls = ALIGN_CLASS[token] || '';
    out.push(`<div class="${cls}">${bodyHtml}</div>`);
    buf = [];
  };

  for (const raw of lines) {
    const trimmed = raw.trim();
    if (FENCES.has(trimmed)) {
      if (mode === null) {
        flushNormal();
        mode = trimmed;
        buf = [];
      } else if (trimmed === mode) {
        flushBlock(mode);
        mode = null;
      } else {
        buf.push(raw);
      }
      continue;
    }
    buf.push(raw);
  }

  if (mode === null) {
    flushNormal();
  } else {
    flushBlock(mode);
  }

  return out.join("\n");
}


  function wrapHtmlWithMode(mode, html) {
    if (!html || !html.trim()) return '';

    const normalized = resolveModeState(mode);

    switch (normalized.name) {
      case 'BigText':
        return `<div class="large">${html}</div>`;
      case 'SmallText':
        return `<div class="small">${html}</div>`;
      case 'TinyText':
        return `<div class="tiny">${html}</div>`;
      case 'Text': {
        const scale = normalized.textScale ?? DEFAULT_TEXT_SCALE;
        if (Math.abs(scale - DEFAULT_TEXT_SCALE) > 1e-6) {
          return `<div class="text-scale" style="--text-scale:${scale}; font-size: calc(var(--base-font-size) * ${scale});">${html}</div>`;
        }
        return html;
      }
      default:
        return html;
    }
  }

  function renderRichTextWithModes(rawText, startingMode = 'Text') {
    if (!rawText) {
      return { html: '', mode: resolveModeState(startingMode) };
    }

    let mode = resolveModeState(startingMode);
    let html = '';
    let buffer = '';

    INLINE_MODE_DIRECTIVE_RE.lastIndex = 0;
    const tokens = [];
    let lastIndex = 0;
    let match;

    while ((match = INLINE_MODE_DIRECTIVE_RE.exec(rawText)) !== null) {
      if (match.index > lastIndex) {
        tokens.push({ type: 'text', value: rawText.slice(lastIndex, match.index) });
      }
      tokens.push({
        type: 'directive',
        keyword: match[1] || '',
        arg: (match[2] || '').trim()
      });
      lastIndex = INLINE_MODE_DIRECTIVE_RE.lastIndex;
    }

    if (lastIndex < rawText.length) {
      tokens.push({ type: 'text', value: rawText.slice(lastIndex) });
    }

    const flushBuffer = () => {
      const trimmed = buffer.trim();
      if (!trimmed) {
        buffer = '';
        return;
      }
      html += wrapHtmlWithMode(mode, formatWithJustify(trimmed));
      buffer = '';
    };

    for (const token of tokens) {
      if (token.type === 'text') {
        buffer += token.value;
        continue;
      }

      flushBuffer();

      const directiveInfo = interpretInlineDirective(token.keyword, token.arg);
      if (!directiveInfo) {
        continue;
      }

      if (directiveInfo.action === 'break') {
        html += `<div aria-hidden="true" style="display:block;height:calc(${directiveInfo.lines} * 1lh);"></div>`;
        continue;
      }

      mode = resolveModeState(directiveInfo.mode);
    }

    flushBuffer();
    return { html, mode: resolveModeState(mode) };
  }
 
  function resolveDirectiveToken(rawToken) {
    if (!rawToken) return null;

    if (METADATA_DIRECTIVES.includes(rawToken)) {
      return { name: rawToken, isMetadata: true };
    }

    if (CONTENT_DIRECTIVES.includes(rawToken)) {
      const info = { name: rawToken, isMetadata: false };
      if (rawToken === 'Text') {
        info.textScale = DEFAULT_TEXT_SCALE;
      }
      return info;
    }

    const modeState = interpretModeKeyword(rawToken);
    if (modeState && modeState.name === 'Text') {
      const lower = rawToken.toLowerCase();
      if (lower.startsWith('text') && lower !== 'text') {
        return { name: 'Text', isMetadata: false, textScale: modeState.textScale };
      }
    }

    return null;
  }

  function parseRawText(rawText) {
    const attributes = {};
    let innerHTML = '';
    const lines = (rawText || '').split('\n');

    let currentDirective = { name: 'Text', isMetadata: false, textScale: DEFAULT_TEXT_SCALE, args: null };
    let buffer = [];

    // Directives allowed to exist INSIDE a Column without breaking it
    const NESTABLE_DIRECTIVES = ['Image', 'BigText', 'SmallText', 'TinyText', 'Text', 'Break'];

    function processBuffer() {
      if (buffer.length === 0) return;
      const content = buffer.join('\n').trim();
      if (!content) return;

      const directiveName = currentDirective.name || 'Text';
      const directiveArgs = currentDirective.args;

      if (currentDirective.isMetadata || METADATA_DIRECTIVES.includes(directiveName)) {
        attributes[directiveName.toLowerCase()] = content;
        buffer = [];
        return;
      }

      switch (directiveName) {
        case "Hidden":
          if (content.toLowerCase() === 'true') attributes.hidden = true;
          break;
        case "Background":
        case "FullScreenImage":
          attributes.background = content;
          if (directiveName === "FullScreenImage") attributes.isFullScreenImage = true;
          break;
        case "Break":
          const lines = Math.max(0, parseFloat(content) || 1);
          innerHTML += `<div aria-hidden="true" style="display:block;height:calc(${lines} * 1lh);"></div>`;
          break;
        case "FullScreenWebsite":
          attributes.fullscreenWebsite = content.trim();
          break;
        case "Header":
          attributes.header = content;
          break;
        case "Title":
          attributes.title = content.split('\n')[0].trim();
          innerHTML += `<h1>${escapeHtml(content).replace(/\n/g, '<br />')}</h1>`;
          break;
        case "BigText":
          innerHTML += wrapHtmlWithMode('BigText', formatWithJustify(content));
          break;
        case "Text":
          innerHTML += wrapHtmlWithMode(
            makeModeState('Text', currentDirective.textScale),
            formatWithJustify(content)
          );
          break;
        case "SmallText":
          innerHTML += wrapHtmlWithMode('SmallText', formatWithJustify(content));
          break;
        case "TinyText":
          innerHTML += wrapHtmlWithMode('TinyText', formatWithJustify(content));
          break;
        case "Notes":
          attributes.notes = content;
          break;
        case "SpeakerNote":
          attributes.speakerNote = content;
          break;
        case "PrintNote":
          attributes.printNotes = content;
          break;
        case "Blockquote":
          innerHTML += `
            <div class="blockquote">
              <div class="quote-text">${plainTextToHtml(content)}</div>
              ${directiveArgs ? `<div class="quote-source">${plainTextToHtml(directiveArgs)}</div>` : ''}
            </div>`;
          break;
        case "Image":
          const [url, ...captionParts] = content.split(/,(.*)/s);
          const caption = (captionParts[0] || '').trim();
          const resolvedUrl = resolveImagePath(url.trim(), window.presentationBaseUrl);
          innerHTML += `<div class="img-container"><img src="${escapeHtml(resolvedUrl)}" alt="${escapeHtml(caption)}"><div class="caption">${plainTextToHtml(caption)}</div></div>`;
          break;

        case "Columns": {
          const rawLines = content.split(/\r?\n/);
          const columnSegments = [];
          let colBuffer = [];

          const flushColumn = (makeDouble = false) => {
            const raw = colBuffer.join('\n');
            // Only skip empty if it's not a forced separator
            if (!raw.trim() && !makeDouble && colBuffer.length === 0) return;
            columnSegments.push({ raw, double: makeDouble });
            colBuffer = [];
          };

          for (const rawLine of rawLines) {
            if (/^\s*----\s*$/.test(rawLine)) { flushColumn(true); continue; }
            if (/^\s*---\s*$/.test(rawLine)) { flushColumn(false); continue; }
            colBuffer.push(rawLine);
          }
          flushColumn(false);

          // Regexes for Columns parsing
          const imgLineRe = /^\s*(?:Image:\s*)?(.+\.(?:png|jpe?g|gif|webp|svg)(?:\?.*)?|data:image\/[a-zA-Z+.\-]+;base64,[^,]+|local-img-[^\s,]+)\s*(?:,\s*(.*))?$/i;
          const bqLineRe  = /^\s*Blockquote(?:\(([^)]+)\))?:\s*(.*)/i;

          const colsHtml = columnSegments.map(segment => {
            const lines = segment.raw.trim().split(/\r?\n/);
            const blocks = [];
            let pendingText = '';
            let currentMode = makeModeState('Text');
            let imageCount = 0;
            let hasTextBlock = false;

            const flushText = () => {
              if (!pendingText) { pendingText = ''; return; }
              const rendered = renderRichTextWithModes(pendingText, currentMode);
              if (rendered.html.trim()) {
                blocks.push(rendered.html);
                if (rendered.html.replace(/<[^>]*>/g, '').trim().length > 0) hasTextBlock = true;
              }
              currentMode = rendered.mode;
              pendingText = '';
            };

            for (const rawLine of lines) {
              const sanitized = rawLine.trim();

              // 1. Check for Blockquote
              const bqMatch = rawLine.match(bqLineRe);
              if (bqMatch) {
                flushText();
                const source = bqMatch[1];
                const text   = bqMatch[2];
                blocks.push(`
                  <div class="blockquote">
                    <div class="quote-text">${plainTextToHtml(text)}</div>
                    ${source ? `<div class="quote-source">${plainTextToHtml(source)}</div>` : ''}
                  </div>`);
                hasTextBlock = true;
                continue;
              }

              // 2. Check for Text Mode directives (BigText:, Text:, etc)
              if (sanitized) {
                 const dirMatch = sanitized.match(/^([A-Za-z][A-Za-z0-9.]*)\s*:\s*(.*)$/);
                 if (dirMatch) {
                    const dirName = dirMatch[1];
                    const lower = dirName.toLowerCase();
                    const isTextMode = lower === 'bigtext' || lower === 'smalltext' || lower === 'tinytext' || lower === 'text' || /^text\d/.test(lower);

                    if (isTextMode) {
                       flushText();
                       const modeState = interpretModeKeyword(dirName, dirMatch[2]);
                       currentMode = resolveModeState(modeState || 'Text');
                       pendingText = dirMatch[2] || '';
                       continue;
                    }
                 }
              }

              // 3. Check for Image
              const imgMatch = sanitized.match(imgLineRe);
              if (imgMatch) {
                flushText();
                imageCount++;
                const imageUrl = imgMatch[1].trim();
                const colCaption = (imgMatch[2] || '').trim();
                const resolvedUrl = resolveImagePath(imageUrl, window.presentationBaseUrl);
                blocks.push(`<div class="img-container"><img src="${escapeHtml(resolvedUrl)}" alt="${escapeHtml(colCaption)}"><div class="caption">${plainTextToHtml(colCaption)}</div></div>`);
                continue;
              }

              pendingText += pendingText ? `\n${rawLine}` : rawLine;
            }
            flushText();

            const onlyImages = imageCount > 0 && !hasTextBlock;
            const cls  = onlyImages ? 'column images-only' : 'column';
            const classes = segment.double ? `${cls} column--double` : cls;
            return `<div class="${classes}"${onlyImages ? ` data-imgcount="${imageCount}"` : ''}>${blocks.join('')}</div>`;
          }).join('');

          innerHTML += `<div class="columns">${colsHtml}</div>`;
          break;
        }
        case "Table":
          const rows = content.split(/^\s*---\s*$/m);
          let tableHtml = '<table>';
          if (rows.length > 0) {
            const headerCells = rows.shift().split('&').map(cell => `<th>${plainTextToHtml(cell.trim())}</th>`).join('');
            tableHtml += `<thead><tr>${headerCells}</tr></thead>`;
          }
          const bodyRows = rows.map(row => {
            const cells = row.split('&').map(cell => `<td>${plainTextToHtml(cell.trim())}</td>`).join('');
            return `<tr>${cells}</tr>`;
          }).join('');
          tableHtml += `<tbody>${bodyRows}</tbody></table>`;
          innerHTML += tableHtml;
          break;
      }
      buffer = [];
    }

    // --- MAIN PARSING LOOP ---
    for (const line of lines) {
      // Check for Directive: or Directive(Args):
      const match = line.match(/^([A-Za-z][A-Za-z0-9.]*)(?:\(([^)]+)\))?:\s*(.*)/);

      if (match) {
        const rawName = match[1];
        const token = resolveDirectiveToken(rawName);

        if (currentDirective && currentDirective.name === 'Columns') {
           if (token && NESTABLE_DIRECTIVES.includes(token.name)) {

             // 1. Are we at the start of the first column?
             // (Buffer contains only whitespace/empty lines so far)
             const isStartOfColumn = buffer.every(line => line.trim() === '');

             // 2. Are we immediately after a separator?
             const lastLine = buffer.length > 0 ? buffer[buffer.length - 1].trim() : '';
             const isAfterSeparator = (lastLine === '---' || lastLine === '----');

             // If we are at the start (modifying first col) OR right after a separator, allow nesting.
             if (isStartOfColumn || isAfterSeparator) {
                buffer.push(line);
                continue;
             }
           }
           // Otherwise, fall through to close the column
        }

        if (token) {
          processBuffer(); // Close previous directive
          const nextDirective = { ...token };
          nextDirective.args = match[2] ? match[2].trim() : null;
          if (nextDirective.name === 'Text' && typeof nextDirective.textScale !== 'number') {
            nextDirective.textScale = DEFAULT_TEXT_SCALE;
          }
          currentDirective = nextDirective;
          buffer = [];
          buffer.push(match[3] || '');
          continue;
        }
      }
      buffer.push(line);
    }
    processBuffer();

    return { attributes, innerHTML };
  }

  /* ═══════════════════════════════════════════════════════════════
                          UTILITY FUNCTIONS
     ═══════════════════════════════════════════════════════════════ */
  
  const $ = (id) => document.getElementById(id);

  const SPELLCHECK_GUARD_CHAR = String.fromCodePoint(0x200B);
  const SPELLCHECK_GUARD_CODE = SPELLCHECK_GUARD_CHAR.codePointAt(0);
  const SPELLCHECK_GUARD_STRIP_RE = new RegExp(SPELLCHECK_GUARD_CHAR, 'g');
  const COMMAND_GUARD_REGEX = /\b(BigText|SmallText|TinyText)(?=\s*:|\]\])/gi;

  const createCommandGuardRegex = () => new RegExp(COMMAND_GUARD_REGEX.source, 'gi');

  function stripCommandSpellcheckGuards(text) {
    if (!text) return '';
    return text.replace(SPELLCHECK_GUARD_STRIP_RE, '');
  }

  function getCommandGuardPositions(cleanText) {
    if (!cleanText) return [];
    const positions = [];
    const regex = createCommandGuardRegex();
    let match;
    while ((match = regex.exec(cleanText)) !== null) {
      const command = match[1] || match[0];
      const lower = command.toLowerCase();
      const splitIndex = lower.indexOf('text');
      const guardOffset = splitIndex > 0 ? splitIndex : command.length;
      positions.push(match.index + guardOffset);
    }
    return positions;
  }

  function insertCommandGuards(cleanText, positions) {
    if (!positions.length) return cleanText;
    let result = '';
    let lastIndex = 0;
    for (const pos of positions) {
      result += cleanText.slice(lastIndex, pos) + SPELLCHECK_GUARD_CHAR;
      lastIndex = pos;
    }
    result += cleanText.slice(lastIndex);
    return result;
  }

  function mapCleanIndexToGuarded(cleanIndex, positions) {
    if (!positions.length) return cleanIndex;
    let offset = 0;
    for (const pos of positions) {
      if (pos <= cleanIndex) {
        offset++;
      } else {
        break;
      }
    }
    return cleanIndex + offset;
  }

  function countGuardsBefore(text, index) {
    if (!text || index <= 0) return 0;
    let count = 0;
    const limit = Math.min(index, text.length);
    for (let i = 0; i < limit; i++) {
      if (text.codePointAt(i) === SPELLCHECK_GUARD_CODE) {
        count++;
      }
    }
    return count;
  }

  function addCommandGuardsToText(text) {
    if (!text) return '';
    const clean = stripCommandSpellcheckGuards(text);
    return insertCommandGuards(clean, getCommandGuardPositions(clean));
  }

  function normalizeTextareaCommandGuards(textarea) {
    if (!textarea) return '';
    const originalValue = textarea.value || '';
    const cleanValue = stripCommandSpellcheckGuards(originalValue);
    const guardPositions = getCommandGuardPositions(cleanValue);
    const guardedValue = insertCommandGuards(cleanValue, guardPositions);

    if (guardedValue !== originalValue) {
      const selectionStart = textarea.selectionStart ?? originalValue.length;
      const selectionEnd = textarea.selectionEnd ?? originalValue.length;
      const cleanStart = selectionStart - countGuardsBefore(originalValue, selectionStart);
      const cleanEnd = selectionEnd - countGuardsBefore(originalValue, selectionEnd);

      textarea.value = guardedValue;
      textarea.selectionStart = mapCleanIndexToGuarded(cleanStart, guardPositions);
      textarea.selectionEnd = mapCleanIndexToGuarded(cleanEnd, guardPositions);
    }

    return cleanValue;
  }
  
  const escapeHtml = (s) =>
    s.replace(/[&<>"']/g, c =>
      ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c])
    );
  
  /* ═══════════════════════════════════════════════════════════════
                        THEME DISCOVERY & LOADING
     ═══════════════════════════════════════════════════════════════ */
  
  async function discoverThemes() {
    state.availableThemes = [];
    
    for (const themeName of AVAILABLE_THEMES) {
      const filename = `${themeName}.css`;
      try {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = filename;
        link.id = `${themeName}-stylesheet`;
        link.disabled = true;
        document.head.appendChild(link);
        
        const displayName = themeName
          .replace(/-/g, ' ')
          .split(' ')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
        
        state.availableThemes.push({
          filename: filename,
          id: themeName,
          name: displayName
        });
      } catch (e) {
        console.warn(`Theme ${filename} not found`);
      }
    }
    
    const themeSelector = $('theme-selector');
    themeSelector.innerHTML = '';
    state.availableThemes.forEach(theme => {
      const option = document.createElement('option');
      option.value = theme.id;
      option.textContent = theme.name;
      themeSelector.appendChild(option);
    });
  }
  
async function applyTheme(themeId) {
  // Disable all theme stylesheets
  document.querySelectorAll('link[id$="-stylesheet"]').forEach(link => {
    link.disabled = true;
  });
  
  // Enable the selected theme
  const themeLink = document.getElementById(`${themeId}-stylesheet`);
  if (themeLink) {
    themeLink.disabled = false;
    
    // Wait for the stylesheet to actually load
    await new Promise((resolve) => {
      if (themeLink.sheet && themeLink.sheet.cssRules) {
        resolve(); // Already loaded
      } else {
        themeLink.addEventListener('load', resolve, { once: true });
        setTimeout(resolve, 500); // Timeout fallback
      }
    });
  }
  
  // Update body class without disturbing edit-mode flag
  document.body.classList.remove(...AVAILABLE_THEMES);
  document.body.classList.add(themeId);
  if (state.editMode) {
    document.body.classList.add('is-edit-mode');
  }

  // Now refresh thumbnails with loaded CSS
  await refreshThumbnails();
}

  /* ═══════════════════════════════════════════════════════════════
                          URL PARAMETER HANDLING
     ═══════════════════════════════════════════════════════════════ */
  
  function handleURLParameters() {
    const urlParams = new URLSearchParams(window.location.search);
    const inputUrl = urlParams.get('xml');
    
    // Check for a saved session in local storage first, but only if no URL is specified.
    if (!inputUrl) {
        const savedSession = localStorage.getItem(LAST_SESSION_KEY);
        const savedSlideIndex = localStorage.getItem(LAST_SLIDE_INDEX_KEY);
        const slideIndex = savedSlideIndex ? parseInt(savedSlideIndex, 10) : 0;
        if (savedSession) {
            init(savedSession, { slideIndex: slideIndex, reason: 'restored-last' });
            return; // Stop here to prevent loading the default.
        }
           // Try to load SchumpeterDemo.txt, fallback to minimal slide if missing
      fetch('SchumpeterDemo.txt')
        .then(r => {
          if (!r.ok) throw new Error('No demo found');
          return r.text();
        })
        .then(txt => {
          const xml = convertTxtToXML(txt, 'SchumpeterDemo.txt');
          init(xml, { fileName: 'SchumpeterDemo', slideIndex: 0, reason: 'default' });
        })
        .catch(() => {
          init(MINIMAL_NEW_XML, { fileName: 'New Presentation', slideIndex: 0, reason: 'new' });
        });
      return;
    }

    let textFileUrl;
    let baseFolderUrl;

    if (inputUrl.match(/dropbox\.com\/sh\//)) {
      const clean = inputUrl.split('?')[0];
      baseFolderUrl = clean.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
      textFileUrl = `${baseFolderUrl}/Slides.txt?dl=1`;
    } else if (inputUrl.match(/drive\.google\.com\/drive\/folders\//)) {
      alert('Google Drive folders aren\'t directly fetchable. Please link to your Slides.txt file, not to the folder.');
      return init(undefined, { fileName: 'New Presentation', slideIndex: 0, reason: 'default' });
    } else {
      const absoluteInputUrl = new URL(inputUrl, window.location.href).href;
      textFileUrl = absoluteInputUrl;
      baseFolderUrl = absoluteInputUrl.substring(0, absoluteInputUrl.lastIndexOf('/') + 1);
    }

    const absoluteXmlUrl = new URL(textFileUrl, window.location.href).href;
    const fetchUrl = 'proxy.php?url=' + encodeURIComponent(absoluteXmlUrl);

    window.presentationBaseUrl = baseFolderUrl;

    fetch(fetchUrl)
      .then(res => {
        if (!res.ok) throw new Error(`Load failed: ${res.status}`);
        return res.text();
      })
      .then(txt => {
        const fileLeaf = textFileUrl.split('/').pop() || 'Slides.txt';
        const cleanName = fileLeaf.replace(/\.[^.]+$/, '');
        const newXml = convertTxtToXML(txt, fileLeaf);
        state.currentFilename = cleanName;
        sessionStorage.setItem(`Slides_${cleanName}`, newXml);
        init(newXml, { fileName: cleanName, slideIndex: 0, reason: 'url' });
      })
      .catch(err => {
        console.error(err);
        alert('Failed to load presentation.');
        init(undefined, { fileName: 'New Presentation', slideIndex: 0, reason: 'default' });
      });
  }

window.resolveImagePath = function(imageSrc, baseUrl) {
  const src = (imageSrc || '').trim();

  // Our local pasted images (e.g., "local-img-...jpg")
  if (src.startsWith('local-img-')) {
    // If we have the blob in IndexedDB (editing/local case), use blob: URL.
    const local = ImageStore.getObjectURLForId(src);
    if (local) return local;

    // Otherwise (e.g., ZIP extracted on a server), treat as a relative file.
    if (baseUrl) return new URL(src, baseUrl).href;
    return src;
  }

  // Remote or data URLs
  if (!baseUrl || /^https?:\/\//i.test(src) || src.startsWith('data:')) {
    return src;
  }
  // Relative paths resolve against presentationBaseUrl
  return new URL(src, baseUrl).href;
};

  
  /* ═══════════════════════════════════════════════════════════════
                          16:9 ASPECT RATIO SETUP
     ═══════════════════════════════════════════════════════════════ */

  function wrapSlideshowFor16x9() {
    const slideshow = $("slideshow");
    if (!slideshow.parentElement.classList.contains('presentation-scaler')) {
      const viewport = document.createElement('div');
      viewport.className = 'presentation-viewport';

      const scaler = document.createElement('div');
      scaler.className = 'presentation-scaler';

      slideshow.parentNode.insertBefore(viewport, slideshow);
      viewport.appendChild(scaler);
      scaler.appendChild(slideshow);

      // HUD goes on the viewport (letterbox), not over the slide
      viewport.appendChild($("slide-counter"));
      viewport.appendChild($("progress-bar"));
      const logo = $("company-logo");
      if (logo) viewport.appendChild(logo);
    }
  }


  
/* ═══════════════════════════════════════════════════════════════
                          INITIALIZATION
     ═══════════════════════════════════════════════════════════════ */

  async function init(newXmlString, options = {}) {
    updateGroundTruth('INIT', {
      xmlString: newXmlString,
      slideIndex: options.slideIndex,
      fileName: options.fileName
    });

    const theme = state.xmlDoc.documentElement.getAttribute("theme") || DEFAULT_THEME;
    $("theme-selector").value = theme;
    await buildSlidesFromXMLDoc();
    await applyTheme(theme);

    const requestedIndex = Number.isFinite(Number(options.slideIndex))
      ? Math.trunc(Number(options.slideIndex))
      : 0;
    const maxIndex = Math.max(0, state.slideEls.length - 1);
    const targetAbsIndex = Math.max(0, Math.min(requestedIndex, maxIndex));
    state.currentAbsoluteSlideIndex = targetAbsIndex;

    const visibleIndex = resolveVisibleIndexForAbsolute(targetAbsIndex);
    const initNavigationOptions = { skipEditorSave: true };

    if (state.editMode) {
      showSlide(targetAbsIndex, false, initNavigationOptions);
    } else {
      showSlide(visibleIndex, true, initNavigationOptions);
    }
    updateHUD();
    updateToggleCountButtonState();
    announceSessionStatus(options);

    if (state.editMode && $("editor").classList.contains("active")) {
      setupEditorUI();
    }
    
    if (!state.editMode) {
      requestWakeLock();
    }

    if (state.editMode) {
      loadTextareaForCurrentSlide();
    }
  }
  
  // Main entry point
  return async function() {
    await ImageStore.init();
    // Discover and load themes
    await discoverThemes();
    
    // Setup event handlers
    setupEventHandlers();
    
    // Setup 16:9 aspect ratio
    wrapSlideshowFor16x9();
    
    // Handle URL parameters or initialize normally
    handleURLParameters();
    
    // Setup editor if in edit mode
    if (state.editMode) {
      $("editor").classList.add("active");
      setupEditorUI();
    }
  };
})();

// Start the application
ModernSlideshow();
</script>
</body>

</html>