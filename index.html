<!DOCTYPE html>
<!--
Modern Slideshow Application
============================
Details at https://github.com/kevincure/ModernSlides/

This is a single-file HTML application that creates an interactive slideshow system.
The application allows users to create, edit, and present slides using a simple 
text-based markup language.

File Structure:
- HTML structure with slideshow container and editor UI
- CSS styles for themes and responsive design - you can create you own and add it in const AVAILABLE_THEMES
- JavaScript application logic in a single IIFE module

Key Features:
- Multiple built-in themes (Tufte, Oxford, Bringhurst, etc.)
- Live editing with real-time preview
- Support for math equations (MathJax), images, tables, columns
- Keyboard navigation and fullscreen presentation mode
- Import/export functionality for slide decks
- Responsive 16:9 aspect ratio design

The slideshow content is stored as XML with CDATA sections containing
the raw text markup that gets parsed into slide elements.
-->
<html lang="en">
<head>
<meta charset="UTF-8" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Modern Slideshows</title>

<!--------------------------------------- RENDER MATH CORRECTLY --------------------------------------------------------->
<!-- MathJax -->
<script>
  window.MathJax = {
    tex: { 
      inlineMath: [["$", "$"], ["\\(", "\\)"]], 
      displayMath: [["$$", "$$"], ["\\[", "\\]"]], 
      processEscapes: true 
    },
    svg: { fontCache: "global" }
  };
</script>
<script id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>




<!---------------------------------------STYLESHEETS SHARED ACROSS FILES ------------------------------------------------>
<style id="core-styles"> 
/* ----------------------------- */
/* --- Core Style Variables --- */
/* ----------------------------- */

:root {
  --slide-base-font-size: 3cqw;
  --editor-bg-color: #fffff8;
  --editor-text-color: #1a1a1a;
  --editor-border-color: #d4d4d4;
  --editor-accent-color: #333333;
  --editor-accent-text-color: #ffffff;
  --editor-thumb-bg: #ffffff;
  --editor-thumb-selected-border: #333333;
  --editor-input-bg: #ffffff;
  --editor-input-text: #333333;
  --editor-input-border: #d4d4d4;
  --editor-ui-font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --editor-mono-font: "Courier New", monospace;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html, body { width:100%; height:100%; overflow:hidden; }

body {
  line-height: 1.5;
}

/* The entire scaling system is driven by the --base-font-size variable */
.presentation-scaler,
.slide-wrapper {
  container-type: inline-size;
  container-name: slideshow;
  /* This is the single master switch for all slide scaling */
  --base-font-size: var(--slide-base-font-size);
}

.deckbar-spacer {
  flex-grow: 1;
}

#editor button.primary-action {
  --editor-accent-color: #008000;
}

/* ----------------------------- */
/* --- Slideshow Layout --- */
/* ----------------------------- */

.slide {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.4s ease;
  background-position: center;
  background-size: cover;
  background-repeat: no-repeat;
}
.slide.active { opacity: 1; z-index: 1; }
.slide.hidden-in-presentation { display: none !important; }

.slide.is-fullscreen-image-slide {
  background-size: contain;
}
.slide.is-fullscreen-image-slide .slide-content {
  background: transparent !important;
}

.slide-header {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  padding: calc(var(--base-font-size) * 0.2);
  font-size: calc(var(--base-font-size) * 0.8);
}

.slide-content {
  width: 100%;
  height: 100%;
  padding: 4cqw;
  display: flex;
  position: relative;
}

.slide-flow-content {
  width: 80%;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  min-height: 0;
  line-height: 1.6;
  --text-scale: 1;
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
}

.slide[style*="background-image"] .slide-content {
  background: var(--slide-content-bg-if-image);
}

/* ----------------------------- */
/* --- Slide Typography --- */
/* ----------------------------- */

.slide-content h1 {
  font-size: calc(var(--base-font-size) * 2.33);
  line-height: 1.2;
  text-align: center;
  padding-bottom: calc(var(--base-font-size) * 0.25);
  margin-bottom: calc(var(--base-font-size) * 0.25);
  width: 100%;
}

.slide-content p {
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
  line-height: 1.6;
  margin-bottom: calc(var(--base-font-size) * 0.3);
  text-align: left;
}

.slide-content .text-center { text-align: center; }

.slide-content .large {
  --text-scale: 1.6;
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
}

.slide-content .large p {
  text-align: center;
  margin: calc(var(--base-font-size) * 0.5) auto;
}

.slide-content .small {
  --text-scale: 0.67;
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
}

.slide-content .tiny {
  --text-scale: 0.33;
  font-size: calc(var(--base-font-size) * var(--text-scale, 1));
}

.slide-content .notes {
  position: absolute;
  bottom: auto;
  top: calc(var(--base-font-size) * 1.2);
  right: calc(var(--base-font-size) * 0.6);
  width: calc(var(--base-font-size) * 6);
  font-size: calc(var(--base-font-size) * 0.7);
  line-height: 1.5;
}

.slide-content .notes p {
  font-size: 1em;
  margin-bottom: 0.5em;
}

/* ----------------------------- */
/* --- Columns, Tables, Images --- */
/* ----------------------------- */

.slide-content .columns {
  display: flex;
  gap: calc(var(--base-font-size) * 0.75);
  align-items: stretch;
  width: 100%;
  flex: 1;
  min-height: 0;
}

.slide-content .columns .column {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  justify-content: center;
  overflow: visible;
}

.slide-content .columns .column.images-only[data-imgcount]:not([data-imgcount="1"]) {
  justify-content: center;
}

.slide-content .columns .column.images-only > .img-container {
  margin: calc(var(--base-font-size) * 0.1) 0;
  flex: 1;
  min-height: 0;
}

.slide-content table {
  border-collapse: collapse;
  margin: calc(var(--base-font-size) * 0.5) auto;
  font-size: calc(var(--base-font-size) * 0.7);
}

.slide-content th, .slide-content td {
  border: 1px solid var(--h1-border-color);
  padding: calc(var(--base-font-size) * 0.3);
  text-align: left;
}

.slide-content .img-container {
  text-align: center;
  margin-bottom: calc(var(--base-font-size) * 0.5);
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex-shrink: 1;
  min-height: 0;
  overflow: visible;
  inline-size: 100%;
  block-size: 100%;
}

/* Two-way scaling: fill the box while preserving aspect */
.slide-content .img-container img,
.slide-content .column img {
  inline-size: 100%;
  block-size: 100%;
  object-fit: contain;
  display: block;
  margin: 0 auto calc(var(--base-font-size) * 0.2) auto;
}

.slide-content .caption {
  font-size: calc(var(--base-font-size) * 0.33);
  max-width: 90%;
  flex-shrink: 0;
  flex-grow: 0;
}

body.is-edit-mode .slide.has-overflow {
  outline: calc(var(--base-font-size) * 0.1) solid rgba(179, 38, 30, 0.6);
  outline-offset: calc(var(--base-font-size) * -0.05);
}

.overflow-indicator {
  position: absolute;
  left: 50%;
  bottom: calc(var(--base-font-size) * 0.6);
  transform: translateX(-50%);
  background: rgba(179, 38, 30, 0.9);
  color: #fff;
  padding: calc(var(--base-font-size) * 0.2) calc(var(--base-font-size) * 0.6);
  border-radius: calc(var(--base-font-size) * 0.2);
  font-size: calc(var(--base-font-size) * 0.4);
  text-align: center;
  max-width: 80%;
  box-shadow: 0 8px 20px rgba(0,0,0,0.25);
  pointer-events: none;
  display: flex;
  flex-direction: column;
  gap: calc(var(--base-font-size) * 0.15);
}

.overflow-indicator strong {
  font-weight: 600;
  letter-spacing: 0.02em;
}

body:not(.is-edit-mode) .overflow-indicator {
  display: none !important;
}

/* ----------------------------- */
/* --- Presentation HUD --- */
/* ----------------------------- */

.company-logo {
  position: fixed;
  top: calc(var(--base-font-size) * 0.4);
  right: calc(var(--base-font-size) * 0.4);
  max-height: calc(var(--base-font-size) * 2.4);
  display: none;
  z-index: 5;
}
.slide-counter {
  position: fixed;
  bottom: calc(var(--base-font-size) * 0.4);
  left: calc(var(--base-font-size) * 0.4);
  font-size: calc(var(--base-font-size) * 0.2);
  color: color-mix(in srgb, var(--main-text-color) 70%, transparent);
  z-index: 5;
}
#progress-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  height: calc(var(--base-font-size) * 0.16);
  background: var(--accent-color);
  z-index: 10;
  transition: width 0.3s;
}

/* ----------------------------- */
/* --- Editor UI Layout --- */
/* ----------------------------- */

#editor {
  position: fixed;
  inset: 0;
  z-index: 100;
  background: var(--editor-bg-color);
  color: var(--editor-text-color);
  font-family: var(--editor-ui-font-family);
  display: none;
  flex-direction: row;
  overflow: hidden;
}
#editor.active { display: flex; }
#editor.active ~ #slideshow .hidden-in-presentation {
  display: flex !important;
  opacity: 0.3 !important;
}

#thumbs {
  width: 240px;
  overflow-y: auto;
  overflow-x: hidden;
  border-right: 1px solid var(--editor-border-color);
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

#thumbs::-webkit-scrollbar {
  width: 8px;
}
#thumbs::-webkit-scrollbar-track {
  background: transparent;
}
#thumbs::-webkit-scrollbar-thumb {
  background-color: #999;
  border-radius: 4px;
}
#thumbs:hover::-webkit-scrollbar-thumb {
  background-color: #666;
}

#editor-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 1rem;
  overflow: hidden;
}

/* ----------------------------- */
/* --- Editor Components --- */
/* ----------------------------- */

.thumb { 
  position: relative;
  width: 200px;
  height: 112.5px;
  border: 2px solid var(--editor-border-color);
  border-radius: 6px;
  background: #000;
  cursor: move;
  cursor: grab;
  pointer-events: auto;
  overflow: hidden;
  transition: opacity 0.2s;
  user-select: none;
  flex-shrink: 0;
}

.thumb-controls {
  position: absolute;
  top: 6px;
  right: 6px;
  display: inline-flex;
  gap: 0.3rem;
  opacity: 0;
  transition: opacity 0.2s ease;
  pointer-events: none;
}

.thumb:hover .thumb-controls,
.thumb.selected .thumb-controls {
  opacity: 1;
  pointer-events: auto;
}

.thumb-controls button {
  width: 26px;
  height: 26px;
  padding: 0;
  border-radius: 50%;
  background: color-mix(in srgb, var(--editor-accent-color) 85%, black 20%);
  color: var(--editor-accent-text-color);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  border: none;
  cursor: pointer;
  box-shadow: 0 1px 4px rgba(0,0,0,0.25);
}

.thumb-controls button:hover:not(:disabled) {
  background: var(--editor-accent-color);
}

.thumb-controls button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.thumb.selected {
  border-color: var(--editor-thumb-selected-border);
  box-shadow: 0 0 0 2px var(--editor-thumb-selected-border);
}

.thumb:active {
  cursor: grabbing;
}

.thumb.dragging {
  opacity: 0.4;
}

.thumb-iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 200px;
  height: 112.5px;
  border: none;
  pointer-events: none;
  background: var(--editor-thumb-bg)
}

.thumb-number {
  position: absolute;
  top: 4px;
  left: 6px;
  font-size: 10px;
  font-family: var(--editor-mono-font);
  background: var(--editor-accent-color);
  color: var(--editor-accent-text-color);
  padding: 1px 5px;
  border-radius: 3px;
  z-index: 1;
}

.thumb.hidden-slide { opacity: 0.6; }
.thumb.hidden-slide::after {
  content: "HIDDEN";
  position: absolute;
  bottom: 4px;
  right: 4px;
  font-family: var(--editor-mono-font);
  font-size: 10px;
  background-color: rgba(0,0,0,0.7);
  color: white;
  padding: 2px 5px;
  border-radius: 3px;
  z-index: 2;
}

.thumb-placeholder {
  background: #007bff;
  opacity: 0.2;
  border: 2px dashed #0056b3;
  border-radius: 4px;
  margin: 5px;
  box-sizing: border-box;
  width: 200px;
  height: 112.5px;
  flex-shrink: 0;
}

#raw-text-editor {
  flex: 1;
  font-size: 18px;
  line-height: 1.7;
  padding: 1rem;
  border: none;
  resize: none;
  margin-bottom: 1rem;
  font-family: var(--editor-ui-font-family);
  background-color: var(--editor-input-bg);
  color: var(--editor-input-text);
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow: auto;
}

.toolbar {
  display: flex;
  flex-wrap: wrap;
  font-family: var(--editor-ui-font-family);
  font-size: 16px;
  gap: 0.6rem;
  align-items: center;
  margin-bottom: 1rem;
}

#editor button {
  padding: 6px 12px;
  background: var(--editor-accent-color);
  font-family: var(--editor-ui-font-family);
  font-size: 15px;
  color: var(--editor-accent-text-color);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
}
#editor button.ghost {
  background: transparent;
  color: var(--editor-accent-color);
  border: 1px solid color-mix(in srgb, var(--editor-accent-color) 60%, transparent);
}
#editor button.ghost:disabled {
  border-color: color-mix(in srgb, var(--editor-border-color) 80%, transparent);
}
#editor button.ghost:hover:not(:disabled) {
  background: color-mix(in srgb, var(--editor-accent-color) 10%, transparent);
}
#editor button:hover:not(:disabled) {
  background: color-mix(in srgb, var(--editor-accent-color) 85%, black);
}
#editor button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.editor-bottom-bar {
  margin-top: auto;
  display: flex;
  align-items: center;
  gap: 1rem;
  padding-top: 0.75rem;
  border-top: 1px solid color-mix(in srgb, var(--editor-border-color) 70%, transparent);
  min-height: 2.75rem;
}

.overflow-warning {
  font-size: 0.9rem;
  color: #b3261e;
  max-width: 60ch;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.overflow-warning::before {
  content: "⚠";
  font-size: 1.1rem;
  display: inline-flex;
  align-items: center;
}

.overflow-warning:empty::before {
  content: "";
}

.overflow-warning:empty {
  display: none;
}

@keyframes editor-glow {
  from { box-shadow: 0 0 8px 2px var(--editor-accent-color); }
  to   { box-shadow: 0 0 2px 1px color-mix(in srgb, var(--editor-accent-color) 50%, transparent); }
}
#editor .glow { animation: editor-glow 1.2s infinite alternate; }

.toolbar select,
.toolbar input[type="text"] {
  padding: 0.25rem 0.45rem;
  border-radius: 4px;
  border: 1px solid var(--editor-input-border);
  background-color: var(--editor-input-bg);
  font-size: 15px;
  font-family: var(--editor-ui-font-family);
  color: var(--editor-input-text);
}

.toolbar .theme-selector {
  min-width: 9rem;
}

/* ----------------------------- */
/* --- Help Modal --- */
/* ----------------------------- */

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 250;
}
.modal.active { display: flex; }
.modal-box {
  background: var(--editor-bg-color);
  color: var(--editor-text-color);
  max-width: 700px;
  max-height: 85vh;
  overflow: auto;
  padding: 2rem;
  border-radius: 8px;
  font-family: var(--editor-ui-font-family);
  line-height: 1.6;
}
.modal-box h3 {
  margin-bottom: 1rem;
  font-size: 1.5rem;
}
.modal-box pre {
  background-color: color-mix(in srgb, var(--editor-bg-color) 90%, var(--editor-text-color) 10%);
  padding: 1em;
  border-radius: 4px;
  overflow-x: auto;
  font-family: var(--editor-mono-font);
  font-size: 0.9rem;
  white-space: pre-wrap;
}
.modal-box button {
  padding: 0.5rem 1rem;
  background: var(--editor-accent-color);
  color: var(--editor-accent-text-color);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin-top: 1rem;
  float: right;
}

/* ----------------------------- */
/* --- 16:9 Presentation Viewport --- */
/* ----------------------------- */

.presentation-viewport {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
  container-type: inline-size;
  container-name: slideshow;
  --base-font-size: var(--slide-base-font-size);
}

.presentation-scaler {
  position: relative;
  width: min(100vw, 177.78vh);
  height: auto;
  aspect-ratio: 16 / 9;
  overflow: hidden;
  box-shadow: 0 0 50px rgba(0,0,0,0.5);
  container-type: inline-size;
  container-name: slideshow;
}

/* make the slideshow fill the stage without absolute overlay issues */
#slideshow {
  position: relative;
  width: 100%;
  height: 100%;
  background: var(--bg-color);
}

.slide { width: 100%; height: 100%; }

.presentation-viewport .slide-counter {
  position: absolute;
  bottom: calc(var(--base-font-size) * 0.48);
  left: calc(var(--base-font-size) * 0.48);
  font-size: calc(var(--base-font-size) * 0.33);
  color: #888;
  z-index: 100;
  pointer-events: none;
}

.presentation-viewport #progress-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  height: calc(var(--base-font-size) * 0.2);
  width: 100%;
  background-color: #007bff;
  z-index: 100;
  pointer-events: none;
}

.presentation-viewport .company-logo {
  position: absolute;
  top: calc(var(--base-font-size) * 0.8);
  right: calc(var(--base-font-size) * 0.8);
  max-height: calc(var(--base-font-size) * 2);
  max-width: calc(var(--base-font-size) * 6);
  z-index: 100;
  pointer-events: none;
}


/* ----------------------------- */
/* --- Presenter Mode Styles --- */
/* ----------------------------- */

.presenter-body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #1a1a1a;
  color: #fff;
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr auto;
  height: 100vh;
  gap: 20px;
  padding: 20px;
  box-sizing: border-box;
}

.presenter-slide-container {
  background: #000;
  border-radius: 8px;
  overflow: hidden;
  position: relative;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
  aspect-ratio: 16 / 9;
  display: flex;
  align-items: center;
  justify-content: center;
}

.presenter-slide-container iframe {
  width: 100%;
  height: 100%;
  border: none;
}

.presenter-slide-label {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.7);
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 14px;
  z-index: 10;
}

.presenter-notes-section {
  grid-column: 1 / -1;
  background: #2a2a2a;
  border-radius: 8px;
  padding: 20px;
  max-height: 200px;
  overflow-y: auto;
}

.presenter-notes-section h3 {
  margin-top: 0;
  color: #ffa500;
}

.presenter-timer-section {
  position: absolute;
  top: 20px;
  right: 20px;
  text-align: right;
  background: rgba(0,0,0,0.7);
  padding: 10px 15px;
  border-radius: 4px;
}

.presenter-timer {
  font-size: 32px;
  font-family: monospace;
  color: #0f0;
}

.presenter-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 10px;
}

.presenter-controls button {
  padding: 10px 20px;
  background: #333;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}

.presenter-controls button:hover {
  background: #555;
}

/* ----------------------------- */
/* --- PRINT STYLES --- */
/* ----------------------------- */
/* Hide injected print notes on screen */
.print-notes-content { display: none; }
/* Hide the website placeholder on screen */
.website-print-placeholder { display: none; }

@media print {
  @page {
    size: landscape;
    margin: 0;
  }

  /* Allow the printer to see all slides */
  html, body {
    overflow: visible !important;
    background: #fff !important;
    margin: 0 !important;
    padding: 0 !important;
  }
  
  /* Use the exact same container-relative unit for printing */
  .slide {
    --base-font-size: var(--slide-base-font-size);
  }

  /* Hide all on-screen UI chrome */
  #editor, #progress-bar, .slide-counter, #company-logo, .presenter-controls {
    display: none !important;
  }

  /* Ensure all colors and backgrounds print */
  * {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
    color-adjust: exact !important;
  }

  /* Flatten on-screen layout containers */
  .presentation-viewport, .presentation-scaler, #slideshow {
    position: static !important; display: block !important;
    width: auto !important; height: auto !important;
    background: transparent !important; box-shadow: none !important;
    aspect-ratio: unset !important;
  }

  /* --- SLIDE PAGE STRUCTURE --- */
  .slide {
    position: relative !important;
    display: flex !important;
    align-items: center !important; /* Center slide vertically by default */
    justify-content: center !important;
    width: 100vw !important; height: 100vh !important;
    overflow: hidden !important;
    margin: 0 !important; padding: 0 !important;
    opacity: 1 !important;
    page-break-after: always;
    break-after: page;
  }
  .slide:last-child { page-break-after: auto; break-after: avoid; }
  .slide.hidden-in-presentation { display: none !important; }
  
  /* --- 16:9 CONTENT BOX (THE "PRINTABLE SCREEN") --- */
  .slide-content {
    position: relative !important; display: flex !important;
    box-sizing: border-box !important; overflow: hidden !important;
    background: var(--bg-color) !important;
    width: 177.78vh !important; height: 100vh !important;
    max-width: 100vw !important; max-height: 56.25vw !important;
    container-type: inline-size;
    container-name: print-slide-container;
  }

  /* Show iframes and hide their placeholders */
  .slide iframe { display: none !important; }
  .website-print-placeholder { display: flex !important; }

  /* When printing with notes, push the slide to the top of the page */
  body.print-with-notes .slide {
    align-items: flex-start !important;
  }

  /* STEP 1: Shrink the slide's 16:9 container to make room at the bottom.
     The slide content inside will automatically rescale perfectly thanks to `cqw`. */
  body.print-with-notes .slide-content {
    height: 56.25vw !important;
    max-height: 56.25vw !important;
  }

  /* STEP 2: Make the notes area visible and position it in the new empty space. */
  body.print-with-notes .print-notes-content {
    display: block !important;
    position: absolute !important;
    left: 0 !important; right: 0 !important; bottom: 0 !important;
    top: 56.25vw !important; /* Start exactly where the slide content ends */
    padding: calc(var(--base-font-size) * 0.4) calc(var(--base-font-size) * 0.8) !important;
    background: #fff !important;
    font-size: calc(var(--base-font-size) * 0.8) !important;
    line-height: 1.4 !important;
    z-index: 2147483647 !important;
    color: #cc0000 !important; /* The requested red color */
  }

  /* STEP 3: Restore the automatic font-shrinking logic based on paragraph count. */
  body.print-with-notes .print-notes-content:has(p:nth-child(2)) { 
    font-size: calc(var(--base-font-size) * 0.44) !important; 
  }
  body.print-with-notes .print-notes-content:has(p:nth-child(3)) { 
    font-size: calc(var(--base-font-size) * 0.36) !important; 
  }
  body.print-with-notes .print-notes-content:has(p:nth-child(5)) { 
    font-size: calc(var(--base-font-size) * 0.32) !important; 
  }
}
}
</style>
</head>







<!---------------------------------------------------- HTML BODY FOR PRESENTATION AND EDITOR VIEW ------------------->
<body>
  <!-- Presentation View -->
  <div id="slideshow"></div>
  <img id="company-logo" class="company-logo" />
  <div id="slide-counter" class="slide-counter">
    <span id="cur">1</span>/<span id="tot">1</span>
  </div>
  <div id="progress-bar"></div>

  <!-- Editor View -->
  <div id="editor">
    <div id="thumbs"></div>
    <div id="editor-main">
      <textarea id="raw-text-editor" placeholder="Enter slide content here. Click Help for syntax."></textarea>
      <div class="toolbar">
        <button id="add-btn"       title="New Slide">      <i class="fa-solid fa-plus"></i></button>
        <button id="del-btn"       title="Delete Slide">   <i class="fa-solid fa-minus"></i></button>
        <button id="dup-btn"       title="Duplicate Slide"><i class="fa-solid fa-copy"></i></button>
        <button id="toggle-hide-btn" title="Hide/Show Slide"> <i class="fa-solid fa-eye"></i></button>
        <!-- hidden state, still used by updateHUD() -->
        <input type="checkbox" id="show-count" checked style="display:none">
        <!-- toggle button -->
        <button id="toggle-count-btn" title="Hide Slide Numbers">
          <i class="fa-solid fa-sort-numeric-asc"></i>
        </button>
        <select id="theme-selector" class="theme-selector" aria-label="Choose theme">
          <!-- Options will be dynamically populated -->
        </select>
        <button id="undo-btn" class="ghost" title="Undo" disabled>
          <i class="fa-solid fa-rotate-left"></i>
        </button>
        <button id="redo-btn" class="ghost" title="Redo" disabled>
          <i class="fa-solid fa-rotate-right"></i>
        </button>
        <div class="deckbar-spacer"></div>
        <button id="help-btn" title="Help"><i class="fa-solid fa-question"></i></button>
        <button id="new-presentation-btn"   title="New Slideshow">  <i class="fa-solid fa-file-circle-plus"></i></button>
        <button id="load-btn"  title="Load Slideshow"> <i class="fa-solid fa-folder-open"></i></button>
        <button id="restore-btn" title="Restore most recently saved" aria-label="Restore most recently saved slideshow" disabled><i class="fa-solid fa-clock-rotate-left"></i></button>
        <button id="download-txt-btn"        title="Download Raw Presentation">       <i class="fa-solid fa-download"></i></button>
        <button id="print-notes-btn" title="Print with Notes"><i class="fa-solid fa-print"></i></button>
        <button id="save-btn" class="primary-action" title="Presentation View"><i class="fa-solid fa-bullhorn"></i></button>
      </div>
      <div class="editor-bottom-bar">
        <div id="overflow-warning" class="overflow-warning" role="status" aria-live="polite"></div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="help" class="modal">
    <div class="modal-box">
      <button id="close-help">Close</button>
      <h3>Modern Slides | Kevin Bryan | July 2025</h3>
      <p>This is a modern, very computationally light, slideshow maker. It completely separates style rules from content. You can edit it completely online or download the code from <a href="https://github.com/kevincure/ModernSlides">github.com/kevincure/ModernSlides</a> or find more similar tools at <a href="https://kevinbryanecon.com/tools.html">kevinbryanecon.com/tools.html</a> and create your slides locally in your browser. Once your slides are set, click download. You can upload that text file to anywhere you like, then open it with a url query of the form ?xml=...: e.g., <a href="https://kevinbryanecon.com/ModernSlides?xml=Progress2025Class1/Class1Slides.txt">this one here</a></p> 
      <p>Each slide is defined by directives in a Markdown type format. A directive starts a line, ends with a colon `:`, and its value is all text that follows until the next directive. In the text editor, you can use abbrevations, noted like [B:]. That is, if you type B: at the start of a line, Background: will automatically pop up.</p>
      <p>Press 'e' to toggle between edit and present, 'f' to go to full screen mode, and 'p' to open a presenter mode window.
      <pre>
      # --- METADATA (place at the top) ---
      Background: image-url.jpg (B:)
      FullScreenImage: image-url.jpg (F:)

      # --- CONTENT DIRECTIVES ---
      Title: The Main Title of The Slide (t:)
        Supports $LaTeX$ and
        manual line breaks.

      Header: Small text in corner (h:)

      BigText: For large, prominent text.  Within all standard text (b:)
      <<< Text on Left <<<, 
      >>> Text on Right >>>, and 
      ||| Text is centered ||| can be used.

      Text: For standard body text. (x:)
        A blank line between text...

        ...and a skipped line creates a new paragraph.

      SmallText: For smaller body text. (s:)

      TinyText: For footnote-sized text. (t:)

      Break: 1 (or 2.2 or .7), provides a break of a set size

      Notes: For notes at the bottom of the slide. (n:)
        These appear in a special position.

      SpeakerNote: For notes for yourself in presentation mode (S:)

      PrintNote: notes about the slide to appear only when printed from the 'print' button in Edit (if you print from the slides, you won't get these) (P:)

      Image: image-url.jpg (or a weblink to jpg/png/gif), An optional caption for image after the comma (I:)

      FullScreenWebsite: https://example.com. If the website shows as broken, it is being blocked on the other website's end. Your personal website should work fine. You can use this to embed a Youtube video including the start time by clicking 'share' and then 'embed' and copying the embed url on Youtube. (F:)

      Columns: (C:)
        This is the left column. Can contain any
        amount of text, paragraphs, and $math$.
        ---
        This is the right column. You can put an
        image here using the 'image, caption' syntax:
        test.jpg, A caption for the image in the column.
        ...or you can just have more text.
        ---
        Third column

      Table: (T:)
        Header 1 & Header 2 & Header 3
        ---
        Cell 1.1 & Cell 1.2 & Cell 1.3
        ---
        Cell 2.1 & Cell 2.2 & $math$ is fine

      *some text* is italic, **some text** is bold, ***some text*** is bold italic.

      # --- NOTES ---
      # - Download Raw Deck and Load Deck give you your slides but you
      #      will still need any images referred to in the same folder
      # - If you print from your browser, it will give slides with PrintNotes. 
      # - If you print from the print icon in Edit mode, it will show the PrintNotes.
      # - If no directive is given, text defaults to `Text:`.
      # - In `Columns` and `Table`, use `---` on its own line
      #       to separate sections/rows.
      # - You cannot nest some directives (e.g., a Table inside a Column).
      # - As you edit, your two most recent sessions are stored locally. The app automatically reopens the last one and the clock icon restores the prior deck.
      # - Undo and Redo live next to the style selector in the toolbar.
      # - When a thumbnail is highlighted you can use the + / - buttons on it to add or delete slides.
      # - 9 different styles are given, but you can create your own also
      # - you can add a bullet point by typing z:
      </pre>
    </div>
  </div>






<!---------------------------------------------------- SCRIPT TAGS ------------------------------------------>
<script>
const ModernSlideshow = (function() {
  'use strict';
  
  /* ═══════════════════════════════════════════════════════════════
                              CONSTANTS
     ═══════════════════════════════════════════════════════════════ */
  const DEFAULT_THEME = 'tufte-base';
  const AVAILABLE_THEMES = ['tufte-base', 'oxford', 'bringhurst', 'calgary', 'swiss-modern', 'david-carson', 'gradient', 'modern-dark','japan-minimal'];
  const DEFAULT_XML = `<presentation title="New Presentation" showSlideCount="true" theme="${DEFAULT_THEME}">
    <slide>
      <raw><![CDATA[
Title: Modern Slides
Header: Header text here
BigText: This is a slideshow.
Text: Press 'E' to edit, 'F' fullscreen, 'Esc' go back
Break: 1.2
Use arrow keys to navigate.
SmallText: smaller
TinyText: tiny
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
Title: Raw Text Demo
Text: This slide *demonstrates* various **features**. For example: $e = mc^2$.
Columns:
  Left column.
  ---
  Center column. Math like $\\alpha + \\beta$.
  A blank line creates a new paragraph.

  Like this.
  ---
  Image: https://upload.wikimedia.org/wikipedia/commons/3/3b/BlkStdSchnauzer2.jpg, And column 3 here.
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
Text: This slide shows a table
Table:
  Header 1 & Header 2
  ---
  Value 1 & $\\sum_{i=0}^n i^2$
  ---
  Value 2 & Another Value
Notes: And small notes
PrintNote: These notes will only appear if you click print from Edit mode; if you print from the slideshow, the print preview will not show these notes.
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
FullScreenImage: https://files.worldwildlife.org/wwfcmsprod/images/Mountain_Gorilla_Silverback_WW22557/hero_full/cg47pknak_Mountain_Gorilla_Silverback_WW22557.jpg
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
FullScreenWebsite: https://www.kevinbryanecon.com
SpeakerNote: Press p to create a presenter mode window and you'll see your note
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
Image: https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExc3p5N2UwOGppdTc4NXgzMWN1czI5eTRicGhtZzQ3ZWJ3dXUxNXF1aiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/pKf7PlSjbtJN6/giphy.gif
Text: GIFs work too
    ]]></raw>
  </slide> 
  <slide>
    <raw><![CDATA[
Background: https://files.worldwildlife.org/wwfcmsprod/images/Mountain_Gorilla_Silverback_WW22557/hero_full/cg47pknak_Mountain_Gorilla_Silverback_WW22557.jpg
Title: Gorilla
Text: And some text.
<<< Text left justified <<<
>>> And here's a paragraph of text justified on right >>>
||| Text centered |||
      ]]></raw>
    </slide>
  </presentation>`;
  const METADATA_DIRECTIVES = ["Theme", "ShowSlideCount", "LogoUrl"];
  const CONTENT_DIRECTIVES = ["Hidden", "Background", "FullScreenImage", "Header",
                                "Title", "BigText", "Text", "SmallText", "TinyText", "Notes",
                                "Image", "Columns", "Table", "FullScreenWebsite", "SpeakerNote",
                                "PrintNote", "Break", "Logo"];
  const ALL_DIRECTIVES = [...METADATA_DIRECTIVES, ...CONTENT_DIRECTIVES];
  const INLINE_MODE_DIRECTIVE_RE = /\[\[([A-Za-z][A-Za-z0-9.]*)(?::?\s*([^\]]+))?\]\]/g;
  const MIN_TEXT_SCALE = 0.2;
  const MAX_TEXT_SCALE = 5;
  const DEFAULT_TEXT_SCALE = 1;
  const LAST_SESSION_KEY = 'modernSlides_lastSession';
  const PREVIOUS_SESSION_KEY = 'modernSlides_previousSession';
  const DEFAULT_NEW_SLIDE_CONTENT = "Title: New Slide\n\nText: Edit this content.";

  function clampTextScale(value) {
    if (!Number.isFinite(value)) return DEFAULT_TEXT_SCALE;
    return Math.min(MAX_TEXT_SCALE, Math.max(MIN_TEXT_SCALE, value));
  }

  function makeModeState(name, scale) {
    const normalizedName = name || 'Text';
    if (normalizedName === 'Text') {
      return { name: 'Text', textScale: clampTextScale(scale ?? DEFAULT_TEXT_SCALE) };
    }
    return { name: normalizedName };
  }

  function resolveModeState(mode) {
    if (!mode) return makeModeState('Text');

    if (typeof mode === 'string') {
      const interpreted = interpretModeKeyword(mode);
      if (interpreted) return makeModeState(interpreted.name, interpreted.textScale);
      return makeModeState(mode);
    }

    if (typeof mode === 'object') {
      const candidateName = mode.name || mode.type || mode.mode;
      if (candidateName) {
        if (candidateName === 'Text' || candidateName === 'text') {
          const sourceScale = mode.textScale ?? mode.scale ?? mode.factor ?? DEFAULT_TEXT_SCALE;
          return makeModeState('Text', sourceScale);
        }
        return makeModeState(candidateName);
      }
    }

    return makeModeState('Text');
  }

  function interpretModeKeyword(keyword, arg = '') {
    if (!keyword) return null;
    const normalized = keyword.trim();
    if (!normalized) return null;
    const lower = normalized.toLowerCase();

    if (lower === 'bigtext' || lower === 'big') return makeModeState('BigText');
    if (lower === 'smalltext' || lower === 'small') return makeModeState('SmallText');
    if (lower === 'tinytext' || lower === 'tiny') return makeModeState('TinyText');

    if (lower === 'text' || lower === 'normal') {
      const numericArg = parseFloat((arg || '').replace(',', '.'));
      if (Number.isFinite(numericArg)) {
        return makeModeState('Text', numericArg);
      }
      return makeModeState('Text');
    }

    const match = lower.match(/^text(?:(\d+(?:\.\d+)?)|(\.\d+))$/);
    if (match) {
      const scaleStr = match[1] ?? match[2];
      const parsedScale = parseFloat(scaleStr);
      if (Number.isFinite(parsedScale)) {
        return makeModeState('Text', parsedScale);
      }
    }

    return null;
  }

  function interpretInlineDirective(keyword, arg = '') {
    if (!keyword) return null;
    const lower = keyword.toLowerCase();

    if (lower === 'break') {
      const amount = parseFloat((arg || '').replace(',', '.'));
      const lines = Number.isFinite(amount) && amount > 0 ? amount : 1;
      return { action: 'break', lines };
    }

    const modeState = interpretModeKeyword(keyword, arg);
    if (modeState) {
      return { action: 'mode', mode: resolveModeState(modeState) };
    }

    return null;
  }

  
/* ═══════════════════════════════════════════════════════════════
                          APPLICATION STATE
     ═══════════════════════════════════════════════════════════════ */

  const state = {
    // Mode flags
    editMode: false,
    wakeLock: null,
    hasChanges: false, // Simple flag to track if there are any unsaved changes.
    currentFilename: null,

    // Presentation data
    xmlDoc: null, // The single source of truth for the entire presentation.

    // Navigation state
    slideEls: [],
    visibleSlideIndices: [],
    currentVisibleSlideIndex: 0,
    currentAbsoluteSlideIndex: 0,

    // Undo/redo state
    undoStack: [],
    redoStack: [],
    maxUndoDepth: 5,
    isRestoringSnapshot: false,

    // Drag state
    draggedThumbIndex: null,
    placeholder: null,
    thumbnailRefreshPromise: null,

    // Overflow measurement
    pendingOverflowFrame: null,

    // Available themes
    availableThemes: [],

    // Presenter window
    presenterWindow: null,
    presenterTimerInterval: null
  };

/* ═══════════════════════════════════════════════════════════════
      WAKE LOCK TO KEEP SCREEN FROM FALLING ASLEEP IN PRESENTATIONS
     ═══════════════════════════════════════════════════════════════ */
  
  async function requestWakeLock() {
    if ('wakeLock' in navigator) {
      try {
        state.wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake lock acquired');
        
        state.wakeLock.addEventListener('release', () => {
          console.log('Wake lock released');
        });
      } catch (err) {
        console.log(`Wake lock error: ${err.name}, ${err.message}`);
      }
    }
  }

  async function releaseWakeLock() {
    if (state.wakeLock) {
      await state.wakeLock.release();
      state.wakeLock = null;
    }
  }
  
/* ═══════════════════════════════════════════════════════════════
                          EVENT HANDLERS
     ═══════════════════════════════════════════════════════════════ */

  function setupEventHandlers() {
    // ensure print is small pdf w/ embedded websites
    window.addEventListener('beforeprint', () => {
      document.querySelectorAll('.slide iframe').forEach((f) => {
        f.dataset.src = f.src;        // remember
        f.src = 'about:blank';        // blank it so nothing gets rasterized
      });
    });

    window.addEventListener('afterprint', () => {
      document.querySelectorAll('.slide iframe[data-src]').forEach((f) => {
        f.src = f.dataset.src;        // restore
        delete f.dataset.src;
      });
    });

    window.addEventListener('resize', () => scheduleOverflowChecks());

    // Keyboard navigation
    // Navigate between slides using arrow keys or page up/down
    // Toggle edit mode using e
    // Go to full screen using f
    // Open presenter mode window using p
    // Exit full screen using escape
    document.addEventListener("keydown", (e) => {
      if (e.target.closest("textarea, input, select") && e.key !== "Escape") return;

      const navAction = {
        "ArrowRight": 1, " ": 1, "PageDown": 1,
        "ArrowLeft": -1, "PageUp": -1
      }[e.key];

      if (navAction) {
        e.preventDefault();
        const nextIndex = state.editMode ?
          state.currentAbsoluteSlideIndex + navAction :
          state.currentVisibleSlideIndex + navAction;
        if (state.editMode) updateGroundTruth('NAVIGATE', { from: state.currentAbsoluteSlideIndex, to: nextIndex });
        showSlide(nextIndex, !state.editMode);
      } else if (e.key === 'e' || e.key === 'E') {
        e.preventDefault();
        let indexForShowSlide = state.currentAbsoluteSlideIndex; 
        if (!state.editMode) {
          // sync currentAbsoluteSlideIndex with current visible slide
          if (state.visibleSlideIndices.length > 0 && state.currentVisibleSlideIndex >= 0) {
            state.currentAbsoluteSlideIndex = state.visibleSlideIndices[state.currentVisibleSlideIndex];
          }
          indexForShowSlide = state.currentAbsoluteSlideIndex;
        }
        state.editMode = !state.editMode;
        $("editor").classList.toggle("active", state.editMode);
        syncEditModeClass();
        if (state.editMode) {
          setupEditorUI();
          releaseWakeLock();
          highlightThumb(state.currentAbsoluteSlideIndex);
          loadTextareaForCurrentSlide();
          $("raw-text-editor").scrollTop = 0;
          // Scroll the slideshow to show the current slide
          const activeSlide = state.slideEls[state.currentAbsoluteSlideIndex];
          if (activeSlide) {
            activeSlide.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
          updateOverflowWarningForEditor();
        } else {
          // Update ground truth when leaving edit mode
          updateGroundTruth('EXIT_EDIT_MODE');
          buildSlidesFromXMLDoc();
          requestWakeLock();
          const lastAbsoluteIndex = state.currentAbsoluteSlideIndex;
          const targetVisibleIndex = resolveVisibleIndexForAbsolute(lastAbsoluteIndex);
          indexForShowSlide = targetVisibleIndex;
          updateOverflowWarningForEditor();
        }
        showSlide(indexForShowSlide, !state.editMode);
      } else if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        toggleFullscreen();
      } else if (e.key === 'p' || e.key === 'P') {
        e.preventDefault();
        openPresenterMode();
      } else if (e.key === "Escape") {
        if ($("help").classList.contains("active")) {
          $("help").classList.remove("active");
        } else if (document.fullscreenElement) {
          document.exitFullscreen();
        } else if (state.editMode) {
          const lastAbsoluteIndex = state.currentAbsoluteSlideIndex;
          state.editMode = false;
          $("editor").classList.remove("active");
          const targetVisibleIndex = resolveVisibleIndexForAbsolute(lastAbsoluteIndex);
          syncEditModeClass();
          updateOverflowWarningForEditor();
          showSlide(targetVisibleIndex, true);
        }
      }
    });

    // -------------------- EDITOR BUTTONS --------------------
    // Save button
    $("save-btn").onclick = () => {
      updateGroundTruth('SAVE');
      if (state.hasChanges) {
        buildSlidesFromXMLDoc(); // Re-render slides to reflect all changes
      }
      state.hasChanges = false;
      updateSaveButtonGlow();
      state.editMode = false;
      $("editor").classList.remove("active");
      syncEditModeClass();
      const targetVisibleIndex = resolveVisibleIndexForAbsolute(state.currentAbsoluteSlideIndex);
      showSlide(targetVisibleIndex, true);
      updateOverflowWarningForEditor();

      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.log('Could not enter fullscreen:', err);
        });
      }
    };

    // Add slide button
    $("add-btn").onclick = async () => {
      await insertSlideAfter(state.currentAbsoluteSlideIndex);
    };

    // Delete slides
    $("del-btn").onclick = async () => {
      await removeSlideAt(state.currentAbsoluteSlideIndex);
    };

    // Duplicate slide
    $("dup-btn").onclick = async () => {
      updateGroundTruth('SAVE');
      const currentRawText = getRawTextForSlide(state.currentAbsoluteSlideIndex);
      await insertSlideAfter(state.currentAbsoluteSlideIndex, currentRawText);
    };


    // Touch navigation on left/right for mobile
    $("slideshow").addEventListener('click', (e) => {
      // Don't navigate if in edit mode or clicking on interactive elements
      if (state.editMode) return;
      
      // Check if we clicked on an iframe or inside an iframe wrapper
      if (e.target.closest('iframe') || e.target.closest('[style*="z-index: 100"]')) return;
      
      // Navigate based on which side was clicked
      const clickX = e.clientX;
      const screenWidth = window.innerWidth;
      
      if (clickX < screenWidth / 2) {
        // Left side - go to previous slide
        const prevIndex = state.currentVisibleSlideIndex - 1;
        showSlide(prevIndex, true);
      } else {
        // Right side - go to next slide
        const nextIndex = state.currentVisibleSlideIndex + 1;
        showSlide(nextIndex, true);
      }
    });

    // toggle show/hide slide button    
    $("toggle-hide-btn").onclick = () => {
      const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
      if (!slideNode) return;

      const rawNode = slideNode.querySelector('raw');
      if (!rawNode) return;

      const rawText = rawNode.textContent || '';
      const lines = rawText.split('\n');
      let hiddenLineIndex = -1;
      let isCurrentlyHidden = false;

      // Check if Hidden directive exists
      for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(/^Hidden:\s*(.*)/i);
        if (match) {
          hiddenLineIndex = i;
          isCurrentlyHidden = match[1].trim().toLowerCase() === 'true';
          break;
        }
      }

      // Toggle the hidden state
      let newLines;
      if (isCurrentlyHidden) {
        // Currently hidden, so unhide by removing the line
        if (hiddenLineIndex >= 0) {
          newLines = lines.filter((_, index) => index !== hiddenLineIndex);
        } else {
          newLines = lines;
        }
      } else {
        // Currently visible, so hide by adding/updating the line
        if (hiddenLineIndex >= 0) {
          lines[hiddenLineIndex] = 'Hidden: true';
          newLines = lines;
        } else {
          // Add Hidden: true at the beginning (after any empty lines)
          let insertIndex = 0;
          while (insertIndex < lines.length && lines[insertIndex].trim() === '') {
            insertIndex++;
          }
          lines.splice(insertIndex, 0, 'Hidden: true');
          newLines = lines;
        }
      }

      // Update the raw text in XML - trim to avoid extra newlines
      const newRawText = newLines.join('\n').trim();
      recordSnapshot('TOGGLE_HIDE');
      rawNode.textContent = '';
      rawNode.appendChild(state.xmlDoc.createCDATASection(newRawText));

      // **ADD THIS: Sync the XML attribute**
      if (!isCurrentlyHidden) {
        slideNode.setAttribute("hidden", "true");
      } else {
        slideNode.removeAttribute("hidden");
      }

      // Update the UI
      state.hasChanges = true;
      state.slideEls[state.currentAbsoluteSlideIndex].classList.toggle("hidden-in-presentation", !isCurrentlyHidden);
      updateVisibleSlideIndices();
      updateToggleHideButtonState();
      updateSingleThumbnail(state.currentAbsoluteSlideIndex);
      updateSaveButtonGlow();

      // Update the textarea if we're editing this slide
      if (state.editMode && $("raw-text-editor")) {
        $("raw-text-editor").value = newRawText;
      }
    };

    // Toggle 'show slide number' button
    $("toggle-count-btn").onclick = () => {
      const cb = $("show-count");
      cb.checked = !cb.checked;
      updateGroundTruth('TOGGLE_COUNT');
      updateToggleCountButtonState();
      updateHUD();
    };

    // Download as txt button
    $("download-txt-btn").onclick = async () => {
      updateGroundTruth('DOWNLOAD');                       

      const fileContents = buildRawDeck();
      const suggestedName = `${
        (state.currentFilename ||
         state.xmlDoc.documentElement.getAttribute('title') ||
         'presentation')
         .replace(/\s+/g, '-')
      }.txt`;

      try {
        // Attempt to use the modern File System Access API.
        const handle = await window.showSaveFilePicker({
          suggestedName,
          types: [{ description: 'Modern Slides', accept: { 'text/plain': ['.txt'] } }]
        });
        const w = await handle.createWritable();
        await w.write(new Blob([fileContents], { type: 'text/plain' }));
        await w.close();
      } catch (err) {
        // If the modern API fails (e.g., user cancellation, security block, or not supported),
        // fall back to the traditional anchor tag download method.
        console.warn("Modern save picker failed, falling back to legacy download.", err);
        const blob = new Blob([fileContents], { type: 'text/plain' });
        const a = Object.assign(document.createElement('a'), {
          href: URL.createObjectURL(blob),
          download: suggestedName,
          style: 'display:none'
        });
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
      }
    };

    // Print with PrintNote class notes button
    $("print-notes-btn").onclick = () => {
      //  Save the current textarea 
      updateGroundTruth('SAVE');          
      buildSlidesFromXMLDoc();  

      // Add print notes class to body
      document.body.classList.add('print-with-notes');
      
      // Inject print notes into slides
      state.slideEls.forEach((slideEl, index) => {
        const rawText = getRawTextForSlide(index);
        const { attributes } = parseRawText(rawText);
        
        // Remove any existing print notes div
        const existingNotes = slideEl.querySelector('.print-notes-content');
        if (existingNotes) existingNotes.remove();
        
        if (attributes.printNotes) {
          const printNotesDiv = document.createElement('div');
          printNotesDiv.className = 'print-notes-content';
          printNotesDiv.innerHTML = plainTextToHtml(attributes.printNotes);
          slideEl.appendChild(printNotesDiv);
        }
      });
      
      // Trigger print
      window.print();
      
      // Clean up after print
      setTimeout(() => {
        document.body.classList.remove('print-with-notes');
        document.querySelectorAll('.print-notes-content').forEach(el => el.remove());
      }, 1000);
    };

    // New presentation button
    $("new-presentation-btn").onclick = () => {
      updateGroundTruth('NEW');
      init(undefined, { fileName: 'New Presentation', slideIndex: 0 });
    };

    // Load presentation button
    $("load-btn").onclick = () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.slides,.txt,text/xml,text/plain';
      input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        state.currentFilename = file.name.replace(/\.[^/.]+$/, "");
        const reader = new FileReader();
        reader.onload = re => {
          const content = re.target.result;
          let newXML = content.trim().startsWith('<?xml') || content.trim().startsWith('<presentation')
            ? content
            : convertTxtToXML(content, file.name);
          init(newXML, { fileName: state.currentFilename, slideIndex: 0 }); // Re-initialize with loaded file
        };
      reader.readAsText(file);
      };
      input.click();
    };

    $("restore-btn").onclick = () => {
      const btn = $("restore-btn");
      if (!btn || btn.disabled) return;

      const previousSession = localStorage.getItem(PREVIOUS_SESSION_KEY);
      if (!previousSession) {
        updateRestoreButtonState();
        return;
      }

      try {
        init(previousSession, { slideIndex: 0 });
      } catch (err) {
        console.error('Failed to restore previous session', err);
      }
    };

    // Help button
    $("help-btn").onclick = () => $("help").classList.add("active");
    $("close-help").onclick = () => $("help").classList.remove("active");

    // Text editor - this is the main source of changes.
    $("raw-text-editor").addEventListener('input', () => {
      state.hasChanges = true;
      validateAndUpdateTextarea(); // Live preview update
      updateSaveButtonGlow();
    });

    // allow shortcuts
    $("raw-text-editor").addEventListener('keydown', (e) => {
      // Check if user just typed a colon after a single letter at line start
      if (e.key !== ':') return;
      
      const textarea = e.target;
      const cursorPos = textarea.selectionStart;
      const textBefore = textarea.value.substring(0, cursorPos);
      
      // Check if we're at the start of a line with just a single letter
      const lines = textBefore.split('\n');
      const currentLine = lines[lines.length - 1];
      
      // Match single letter at start of line
      if (currentLine.length !== 1) return;
      
      const letter = currentLine;
      const shortcuts = {
        'b': 'BigText',
        'C': 'Columns:\n  ',
        'I': 'Image',
        'T': 'Table:\n  ',
        'W': 'FullScreenWebsite',
        'n': 'Notes',
        's': 'SmallText',
        'h': 'Header',
        't': 'Title',
        'x': 'Text',
        'z': '• ',
        'P': 'PrintNote',
        'S': 'SpeakerNote',
        'F': 'FullScreenImage',
        'B': 'Background'
      };
      
      if (shortcuts[letter]) {
        e.preventDefault();
        
        // Replace the letter with the full directive
        const lineStartPos = cursorPos - 1;
        const before = textarea.value.substring(0, lineStartPos);
        const after = textarea.value.substring(cursorPos);
        
        const precomposed = new Set(['C','T','z']);
        const insertion = precomposed.has(letter) ? shortcuts[letter]
          : shortcuts[letter] + ': ';
        
        textarea.value = before + insertion + after;
        textarea.selectionStart = textarea.selectionEnd = before.length + insertion.length;
        
        // Trigger input event for live preview
        textarea.dispatchEvent(new Event('input'));
      }
    });

    // Change slideshow style
    $("theme-selector").onchange = async () => {
      updateGroundTruth('THEME_CHANGE', { theme: $("theme-selector").value });
      await applyTheme($("theme-selector").value);
    };

    // Toggle fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.log(`Error attempting to enable fullscreen: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    }

    const undoBtn = $("undo-btn");
    if (undoBtn) {
      undoBtn.addEventListener('click', () => {
        handleUndo().catch(err => console.error(err));
      });
    }

    const redoBtn = $("redo-btn");
    if (redoBtn) {
      redoBtn.addEventListener('click', () => {
        handleRedo().catch(err => console.error(err));
      });
    }

    syncEditModeClass();
    updateUndoRedoButtons();
    updateOverflowWarningForEditor();
    updateRestoreButtonState();
  }
  
  /* ═══════════════════════════════════════════════════════════════
                          IMPORT SLIDESHOW
     ═══════════════════════════════════════════════════════════════ */
  
  function convertTxtToXML(txtContent, filename) {
    let title = filename.replace(/\.(txt|xml)$/i, '') || "Imported Presentation";
    let theme = DEFAULT_THEME;
    let showSlideCount = "true";
    let logoUrl = "";
    
    let contentToProcess = txtContent;
    if (txtContent.trim().startsWith('# METADATA:')) {
      const metadataEndIndex = txtContent.indexOf('\n# Slide(');
      if (metadataEndIndex !== -1) {
        const metadataSection = txtContent.substring(0, metadataEndIndex);
        contentToProcess = txtContent.substring(metadataEndIndex);
        
        const metadataLines = metadataSection.split('\n');
        metadataLines.forEach(line => {
          const match = line.match(/^(\w+):\s*(.*)$/);
          if (match) {
            const [, key, value] = match;
            switch(key) {
              case 'Title': title = value.trim(); break;
              case 'Theme': theme = value.trim(); break;
              case 'ShowSlideCount': showSlideCount = value.trim(); break;
              case 'LogoUrl': logoUrl = value.trim(); break;
            }
          }
        });
      }
    }
    
    const parts = contentToProcess.split(/^# Slide\(\d+\):\s*$/m);
    const slideMatches = parts.filter(part => part.trim() !== '');
    
    let xml = `<presentation title="${escapeHtml(title)}" showSlideCount="${showSlideCount}" theme="${theme}"`;
    if (logoUrl) {
      xml += ` logoUrl="${escapeHtml(logoUrl)}"`;
    }
    xml += `>`;
    
    slideMatches.forEach(slideContent => {
      const cleanContent = slideContent.trim();
      if (cleanContent) {
        xml += `\n  <slide>\n    <raw><![CDATA[\n${cleanContent}\n    ]]></raw>\n  </slide>`;
      }
    });
    
    xml += '\n</presentation>';
    return xml;
  }
  
  async function convertImageToDataURL(url) {
    return new Promise((resolve, reject) => {
      fetch(url)
        .then(response => {
          if (!response.ok) throw new Error(`Network response was not ok for ${url}`);
          return response.blob();
        })
        .then(blob => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        })
        .catch(err => reject(`Failed to fetch blob for ${url}: ${err}`));
    });
  }
 
  /* ==================================================================
                        PRESENTER MODE
  ================================================================= */

  function disposePresenterTimer() {
    if (state.presenterTimerInterval) {
      clearInterval(state.presenterTimerInterval);
      state.presenterTimerInterval = null;
    }
  }

  function cleanupPresenterWindowReference() {
    disposePresenterTimer();
    if (state.presenterWindow && !state.presenterWindow.closed) {
      try {
        state.presenterWindow.close();
      } catch (err) {
        console.warn('Unable to close presenter window cleanly.', err);
      }
    }
    state.presenterWindow = null;
  }

  function openPresenterMode() {
    // Open a new window for presenter view
    if (state.presenterWindow && !state.presenterWindow.closed) {
      state.presenterWindow.focus();
      return;
    }

    disposePresenterTimer();
    const presenterWindow = window.open('', 'presenter', 'width=1200,height=800');

    if (!presenterWindow) {
      alert('Please allow popups to use presenter mode');
      return;
    }
    
    // Set up presenter view HTML
    presenterWindow.document.write(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Presenter View</title>
        <style>
          ${document.getElementById('core-styles').textContent}
        </style>
      </head>
      <body class="presenter-body">
        <div class="presenter-slide-container">
          <div class="presenter-slide-label">Current Slide</div>
          <iframe id="current-slide"></iframe>
        </div>
        <div class="presenter-slide-container">
          <div class="presenter-slide-label">Next Slide</div>
          <iframe id="next-slide"></iframe>
        </div>
        <div class="presenter-notes-section">
          <h3>Speaker Notes</h3>
          <div id="notes-content">No notes for this slide</div>
        </div>
        <div class="presenter-timer-section">
          <div>Elapsed Time</div>
          <div class="presenter-timer" id="timer">00:00</div>
        </div>
        <div class="presenter-controls">
          <button onclick="window.opener.prevSlide()">Previous</button>
          <button onclick="window.opener.nextSlide()">Next</button>
        </div>
      </body>
      </html>
    `);

    // Store reference to presenter window
    state.presenterWindow = presenterWindow;
    presenterWindow.addEventListener('beforeunload', cleanupPresenterWindowReference, { once: true });

    // Start timer
    let startTime = Date.now();
    state.presenterTimerInterval = window.setInterval(() => {
      if (!state.presenterWindow || state.presenterWindow.closed) {
        cleanupPresenterWindowReference();
        return;
      }
      const elapsed = Date.now() - startTime;
      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      presenterWindow.document.getElementById('timer').textContent =
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
    
    // Update presenter view when slides change
    updatePresenterView();
  }

  function updatePresenterView() {
    if (!state.presenterWindow || state.presenterWindow.closed) return;
    
    const currentIndex = state.currentAbsoluteSlideIndex;
    let nextIndex;
    const currentVisiblePosition = state.visibleSlideIndices.indexOf(currentIndex);

    // Check if the current slide is visible and not the last one.
    if (currentVisiblePosition !== -1 && currentVisiblePosition < state.visibleSlideIndices.length - 1) {
        // If so, the next slide is the next one in the visible list.
        nextIndex = state.visibleSlideIndices[currentVisiblePosition + 1];
    } else {
        // Otherwise (if on the last visible slide or a hidden slide), just show the current slide again in the "Next" preview.
        nextIndex = currentIndex;
    }
    
    // Get current and next slide HTML
    const currentSlideHTML = state.slideEls[currentIndex].outerHTML;
    const nextSlideHTML = state.slideEls[nextIndex].outerHTML;
    
    // Get theme CSS
    const themeId = document.body.className;
    const themeLink = document.getElementById(`${themeId}-stylesheet`);
    const themeHref = themeLink ? themeLink.href : '';
    
    // Create standalone HTML for iframes
const slideTemplate = (slideHTML) => `
  <!DOCTYPE html>
  <html>
  <head>
    <link rel="stylesheet" href="${themeHref}">
<style>
  ${document.getElementById('core-styles').textContent}
  body { margin: 0; overflow: hidden; }
  .slide-wrapper {
    position: relative;
    width: 100%;
    height: auto;
    aspect-ratio: 16 / 9;
    container-type: inline-size;
    container-name: slideshow;
    font-size: var(--slide-base-font-size);
  }
  #slideshow { position: absolute; inset: 0; }
  .slide { position: absolute; inset: 0; display: flex !important; opacity: 1 !important; }
</style>
  </head>
  <body class="${themeId}">
    <div class="slide-wrapper">
      <div id="slideshow">${slideHTML}</div>
    </div>
  </body>
  </html>
`;
    
    // Update iframes
    state.presenterWindow.document.getElementById('current-slide').srcdoc = slideTemplate(currentSlideHTML);
    state.presenterWindow.document.getElementById('next-slide').srcdoc = slideTemplate(nextSlideHTML);
    
    // Update notes
    const rawText = getRawTextForSlide(currentIndex);
    const { attributes } = parseRawText(rawText);
    const notesElement = state.presenterWindow.document.getElementById('notes-content');
    notesElement.textContent = attributes.speakerNote || 'No notes for this slide';
  }

  // Add these helper functions to expose navigation to presenter window
  window.nextSlide = function() {
    const nextIndex = state.editMode ? 
      state.currentAbsoluteSlideIndex + 1 : 
      state.currentVisibleSlideIndex + 1;
    showSlide(nextIndex, !state.editMode);
  };

  window.prevSlide = function() {
    const prevIndex = state.editMode ? 
      state.currentAbsoluteSlideIndex - 1 : 
      state.currentVisibleSlideIndex - 1;
    showSlide(prevIndex, !state.editMode);
  };  

/* ═══════════════════════════════════════════════════════════════
                          DRAG AND DROP IN EDIT MODE
     ═══════════════════════════════════════════════════════════════ */
  
  function makeThumbnailsDraggable() {
    const thumbsContainer = document.getElementById('thumbs');
    
    // Clean up any existing placeholder completely
    const existingPlaceholders = thumbsContainer.querySelectorAll('.thumb-placeholder');
    existingPlaceholders.forEach(p => p.remove());
    
    // Reset the placeholder reference
    if (state.placeholder) {
      if (state.placeholder.parentNode) {
        state.placeholder.parentNode.removeChild(state.placeholder);
      }
      state.placeholder = null;
    }
    
    // Create new placeholder
    state.placeholder = document.createElement('div');
    state.placeholder.className = 'thumb-placeholder';
    state.placeholder.style.display = 'none';
    
    // Remove any existing event listeners before adding new ones
    const thumbs = thumbsContainer.querySelectorAll('.thumb');
    thumbs.forEach((thumb) => {
      // Clone node to remove all event listeners
      const newThumb = thumb.cloneNode(true);
      thumb.parentNode.replaceChild(newThumb, thumb);
      
      // Add fresh event listeners
      newThumb.draggable = true;
      newThumb.addEventListener('dragstart', handleDragStart);
      newThumb.addEventListener('dragend', handleDragEnd);

      // Re-attach click handler
      const index = parseInt(newThumb.dataset.index);
      newThumb.onclick = () => showSlide(index);

      const controls = newThumb.querySelector('.thumb-controls');
      if (controls) {
        const addControl = controls.querySelector('[data-action="add"]');
        if (addControl) {
          addControl.addEventListener('click', async (event) => {
            event.stopPropagation();
            await insertSlideAfter(index);
          });
        }

        const deleteControl = controls.querySelector('[data-action="delete"]');
        if (deleteControl) {
          const disableDelete = state.slideEls.length <= 1;
          deleteControl.disabled = disableDelete;
          deleteControl.title = disableDelete ? 'Cannot delete the only slide' : 'Delete slide';
          deleteControl.addEventListener('click', async (event) => {
            event.stopPropagation();
            await removeSlideAt(index);
          });
        }
      }
    });
    
    // Remove old container event listeners and add fresh ones
    const newContainer = thumbsContainer.cloneNode(false);
    while (thumbsContainer.firstChild) {
      newContainer.appendChild(thumbsContainer.firstChild);
    }
    thumbsContainer.parentNode.replaceChild(newContainer, thumbsContainer);
    
    // Add container event listeners
    newContainer.addEventListener('dragover', handleDragOver);
    newContainer.addEventListener('drop', handleDrop);
  }
  
  function handleDragStart(e) {
    const thumbsContainer = document.getElementById('thumbs');
    state.draggedThumbIndex = Array.from(thumbsContainer.querySelectorAll('.thumb')).indexOf(e.target);
    
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', '');
    
    state.placeholder.style.height = e.target.offsetHeight + 'px';
    state.placeholder.style.width = e.target.offsetWidth + 'px';
  }
  
  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    if (state.draggedThumbIndex === null) return;
    
    const thumbsContainer = e.currentTarget;
    const afterElement = getDragAfterElement(thumbsContainer, e.clientY);
    
    if (state.placeholder.style.display === 'none') {
      state.placeholder.style.display = 'block';
    }
    
    if (afterElement == null) {
      thumbsContainer.appendChild(state.placeholder);
    } else {
      thumbsContainer.insertBefore(state.placeholder, afterElement);
    }
    
    const rect = thumbsContainer.getBoundingClientRect();
    const scrollSpeed = 5;
    const scrollMargin = 50;
    
    if (e.clientY < rect.top + scrollMargin) {
      thumbsContainer.scrollTop -= scrollSpeed;
    } else if (e.clientY > rect.bottom - scrollMargin) {
      thumbsContainer.scrollTop += scrollSpeed;
    }
  }
  
  async function handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (state.draggedThumbIndex === null) return;
    
    const thumbsContainer = document.getElementById('thumbs');
    const allChildren = Array.from(thumbsContainer.children);
    const placeholderIndex = allChildren.indexOf(state.placeholder);
    
    if (placeholderIndex === -1) return;
    
    const thumbsBeforePlaceholder = allChildren.slice(0, placeholderIndex)
      .filter(el => el.classList.contains('thumb')).length;
    
    let newIndex = thumbsBeforePlaceholder;
    
    if (state.draggedThumbIndex < newIndex) {
      newIndex--;
    }
    
    if (state.draggedThumbIndex !== newIndex) {
      await reorderSlides(state.draggedThumbIndex, newIndex);
    }
    
    cleanupDrag();
  }
  
  function handleDragEnd(e) {
    e.target.classList.remove('dragging');
    cleanupDrag();
  }
  
  function cleanupDrag() {
    // Remove placeholder from DOM completely
    if (state.placeholder && state.placeholder.parentNode) {
      state.placeholder.parentNode.removeChild(state.placeholder);
    }
    
    // Hide it just in case
    if (state.placeholder) {
      state.placeholder.style.display = 'none';
    }
    
    // Reset drag state
    state.draggedThumbIndex = null;
    
    // Remove dragging class from any thumb that might still have it
    document.querySelectorAll('.thumb.dragging').forEach(thumb => {
      thumb.classList.remove('dragging');
    });
  }
  
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.thumb:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
  
  async function reorderSlides(fromIndex, toIndex) {
    if (fromIndex === toIndex) return;
    
    updateGroundTruth('REORDER', { fromIndex, toIndex });
    
    await buildSlidesFromXMLDoc();
    await refreshThumbnails();
    let newCurrentIndex = toIndex;
    showSlide(newCurrentIndex);
  }


/* ═══════════════════════════════════════════════════════════════
                          EDITOR FUNCTIONS
     ═══════════════════════════════════════════════════════════════ */

  function setupEditorUI() {
    const p = state.xmlDoc.querySelector("presentation");
    if (!p) return;

    $("show-count").checked = p.getAttribute("showSlideCount") !== "false";
    $("theme-selector").value = p.getAttribute("theme") || DEFAULT_THEME;

    refreshThumbnails();
    loadTextareaForCurrentSlide();
    updateSaveButtonGlow();
  }

  async function refreshThumbnails() {
    // 1) Bail out if already running to prevent concurrent updates
    if (state.thumbnailRefreshPromise) {
      return state.thumbnailRefreshPromise;
    }

    // 2) The core logic is wrapped in a new Promise that we control
    const promise = new Promise(async (resolve) => {
      const thumbsContainer = $("thumbs");

      // Clear old iframes
      thumbsContainer.querySelectorAll('iframe').forEach(iframe => {
        iframe.src = 'about:blank';
        iframe.remove();
      });

      // Clear old thumbnails. This is what causes the scroll jump.
      thumbsContainer.innerHTML = ''; 
      
      const slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");
      const theme = $("theme-selector").value || DEFAULT_THEME;

      // 3) Rebuild the DOM elements
      for (let i = 0; i < slideNodes.length; i++) {
        const rawText = slideNodes[i].querySelector('raw')?.textContent || '';

        const thumbDiv = document.createElement("div");
        thumbDiv.className = "thumb" + (i === state.currentAbsoluteSlideIndex ? " selected" : "");
        if (slideNodes[i].getAttribute("hidden") === "true") {
          thumbDiv.classList.add("hidden-slide");
        }
        thumbDiv.dataset.index = i;

        const num = document.createElement('div');
        num.className = 'thumb-number';
        num.textContent = i + 1;

        const iframe = document.createElement('iframe');
        iframe.className = 'thumb-iframe';
        iframe.scrolling = "no";
        iframe.loading = "lazy";
        // This await is fine, it just populates the content
        iframe.srcdoc = await getThumbnailHTML(rawText, theme);

        const controls = document.createElement('div');
        controls.className = 'thumb-controls';

        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.title = 'Add slide after';
        addBtn.dataset.action = 'add';
        addBtn.setAttribute('aria-label', 'Add slide after');
        addBtn.innerHTML = '<i class="fa-solid fa-plus"></i>';
        addBtn.addEventListener('click', async (event) => {
          event.stopPropagation();
          await insertSlideAfter(i);
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.title = state.slideEls.length <= 1 ? 'Cannot delete the only slide' : 'Delete slide';
        deleteBtn.dataset.action = 'delete';
        deleteBtn.setAttribute('aria-label', 'Delete slide');
        deleteBtn.innerHTML = '<i class="fa-solid fa-minus"></i>';
        deleteBtn.disabled = state.slideEls.length <= 1;
        deleteBtn.addEventListener('click', async (event) => {
          event.stopPropagation();
          await removeSlideAt(i);
        });

        controls.append(addBtn, deleteBtn);

        thumbDiv.append(num, iframe, controls);
        thumbsContainer.appendChild(thumbDiv);
        thumbDiv.onclick = () => showSlide(i);
      }

      makeThumbnailsDraggable();

      // 4) 
      // Wait for the browser's next painting cycle. This gives the browser
      // time to render the new thumbnails and calculate the new scroll height.
      requestAnimationFrame(() => {
        // Now that the DOM is stable, find the selected thumb
        const selectedThumb = thumbsContainer.querySelector('.thumb.selected');
        if (selectedThumb) {
          // Execute the scroll. This visually corrects the jump.
          selectedThumb.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        }
        // 5) Only after the scroll has been commanded, resolve the promise.
        resolve(); 
      });
    });

    state.thumbnailRefreshPromise = promise;
    
    // Wait for the process to finish and then clear the lock
    try {
      await promise;
    } finally {
      state.thumbnailRefreshPromise = null;
    }
  }

  function highlightThumb(index) {
    const thumbs = document.querySelectorAll("#thumbs .thumb");
    thumbs.forEach((t, i) =>
      t.classList.toggle("selected", i === index)
    );
    const selected = document.querySelector("#thumbs .thumb.selected");
    if (selected) selected.scrollIntoView({ block: 'nearest', inline: 'nearest' });
  }

  function buildRawDeck() {
    const p = state.xmlDoc.documentElement;
    let txt = `# METADATA:
Title: ${p.getAttribute('title')            || ''}
Theme: ${p.getAttribute('theme')            || 'tufte-base'}
ShowSlideCount: ${p.getAttribute('showSlideCount') || 'true'}
LogoUrl: ${p.getAttribute('logoUrl')        || ''}`;

  Array.from(p.querySelectorAll('slide')).forEach((s, i) => {
    txt += `

# Slide(${i + 1}):

${(s.querySelector('raw')?.textContent || '').trim()}`;
  });

    return txt.trim();
  }

  function getRawTextForSlide(index) {
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
    return slideNode?.querySelector("raw")?.textContent || "";
  }

  function loadTextareaForCurrentSlide() {
    // Always load directly from the single source of truth: the xmlDoc.
    $("raw-text-editor").value = getRawTextForSlide(state.currentAbsoluteSlideIndex);
    validateAndUpdateTextarea();
  }

  async function validateAndUpdateTextarea() {
    // This function provides a live preview in the thumbnail without saving to XML.
    const thumbIframe = document.querySelector(
      `#thumbs .thumb[data-index="${state.currentAbsoluteSlideIndex}"] iframe`
    );
    if (thumbIframe) {
      const theme = $("theme-selector").value || 'tufte-base';
      thumbIframe.srcdoc = await getThumbnailHTML($("raw-text-editor").value, theme);
    }
  }

  function captureCurrentSnapshot() {
    if (!state.xmlDoc) return null;
    const serializer = new XMLSerializer();
    return {
      xmlString: serializer.serializeToString(state.xmlDoc),
      currentAbsoluteSlideIndex: state.currentAbsoluteSlideIndex,
      hasChanges: state.hasChanges
    };
  }

  function recordSnapshot(reason) {
    if (state.isRestoringSnapshot) return;
    const snapshot = captureCurrentSnapshot();
    if (!snapshot) return;
    snapshot.reason = reason;
    state.undoStack.push(snapshot);
    if (state.undoStack.length > state.maxUndoDepth) {
      state.undoStack.shift();
    }
    state.redoStack = [];
    updateUndoRedoButtons();
  }

  async function handleUndo() {
    if (state.undoStack.length === 0) return;
    const snapshot = state.undoStack.pop();
    const current = captureCurrentSnapshot();
    if (current) {
      state.redoStack.push(current);
      if (state.redoStack.length > state.maxUndoDepth) {
        state.redoStack.shift();
      }
    }
    await applySnapshot(snapshot);
    updateUndoRedoButtons();
  }

  async function handleRedo() {
    if (state.redoStack.length === 0) return;
    const snapshot = state.redoStack.pop();
    if (!snapshot) return;
    const current = captureCurrentSnapshot();
    if (current) {
      state.undoStack.push(current);
      if (state.undoStack.length > state.maxUndoDepth) {
        state.undoStack.shift();
      }
    }
    await applySnapshot(snapshot);
    updateUndoRedoButtons();
  }

  async function applySnapshot(snapshot) {
    if (!snapshot) return;
    state.isRestoringSnapshot = true;
    try {
      await init(snapshot.xmlString, { slideIndex: snapshot.currentAbsoluteSlideIndex, fileName: state.currentFilename });
    } finally {
      state.isRestoringSnapshot = false;
    }

    state.currentAbsoluteSlideIndex = snapshot.currentAbsoluteSlideIndex;
    state.hasChanges = snapshot.hasChanges;
    updateSaveButtonGlow();
    updateToggleHideButtonState();
    updateOverflowWarningForEditor();
  }

  function saveCurrentSlideText(sourceText, reason) {
    if (!state.xmlDoc) return false;
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
    if (!slideNode) return false;
    const rawNode = slideNode.querySelector('raw');
    if (!rawNode) return false;

    const previous = rawNode.textContent || '';
    const next = typeof sourceText === 'string' ? sourceText : previous;
    if (previous === next) return false;

    recordSnapshot(reason);
    rawNode.textContent = '';
    rawNode.appendChild(state.xmlDoc.createCDATASection(next));
    state.hasChanges = true;
    return true;
  }

  function updateUndoRedoButtons() {
    const undoBtn = $("undo-btn");
    const redoBtn = $("redo-btn");
    if (!undoBtn || !redoBtn) return;
    undoBtn.disabled = state.undoStack.length === 0;
    redoBtn.disabled = state.redoStack.length === 0;
  }

  function collectOverflowSnippets(container, containerRect) {
    const snippets = [];
    if (!container) return snippets;

    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode(node) {
          return node.textContent && node.textContent.trim()
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_REJECT;
        }
      }
    );

    while (walker.nextNode()) {
      const node = walker.currentNode;
      const range = document.createRange();
      range.selectNodeContents(node);
      const rects = Array.from(range.getClientRects());
      range.detach?.();
      const isOverflowing = rects.some(rect =>
        rect.bottom - containerRect.bottom > 1 || rect.right - containerRect.right > 1
      );
      if (isOverflowing) {
        const snippet = node.textContent.trim().replace(/\s+/g, ' ');
        if (snippet) {
          snippets.push(snippet);
          if (snippets.length >= 3) break;
        }
      }
    }

    return snippets;
  }

  function markOverflowForSlide(slideEl) {
    if (!slideEl) return;

    const indicator = slideEl.querySelector('.overflow-indicator');
    if (indicator) indicator.remove();
    slideEl.classList.remove('has-overflow');
    delete slideEl.dataset.overflowSnippets;

    const content = slideEl.querySelector('.slide-flow-content');
    if (!content) return;

    const contentRect = content.getBoundingClientRect();
    if (!contentRect.width || !contentRect.height) return;

    const overflowVert = content.scrollHeight - content.clientHeight > 1;
    const overflowHoriz = content.scrollWidth - content.clientWidth > 1;
    if (!overflowVert && !overflowHoriz) return;

    const snippets = collectOverflowSnippets(content, contentRect);
    slideEl.classList.add('has-overflow');
    slideEl.dataset.overflowSnippets = JSON.stringify(snippets);

    const notice = document.createElement('div');
    notice.className = 'overflow-indicator';
    const preview = snippets.length
      ? escapeHtml(snippets[0].slice(0, 160)) + (snippets[0].length > 160 ? '&hellip;' : '')
      : 'Reduce text size or add a break.';
    notice.innerHTML = `<strong>Overflowing content</strong><span>${preview}</span>`;
    slideEl.appendChild(notice);
  }

  function scheduleOverflowChecks() {
    if (state.pendingOverflowFrame) {
      cancelAnimationFrame(state.pendingOverflowFrame);
    }
    state.pendingOverflowFrame = requestAnimationFrame(() => {
      state.pendingOverflowFrame = null;
      state.slideEls.forEach(markOverflowForSlide);
      updateOverflowWarningForEditor();
    });
  }

  function updateOverflowWarningForEditor() {
    const warning = $("overflow-warning");
    if (!warning) return;

    if (!state.editMode) {
      warning.textContent = '';
      return;
    }

    const slide = state.slideEls[state.currentAbsoluteSlideIndex];
    if (!slide || !slide.classList.contains('has-overflow')) {
      warning.textContent = '';
      return;
    }

    let snippets = [];
    try {
      snippets = slide.dataset.overflowSnippets ? JSON.parse(slide.dataset.overflowSnippets) : [];
    } catch (err) {
      snippets = [];
    }

    if (snippets.length === 0) {
      warning.textContent = 'Content extends beyond the 16×9 frame.';
      return;
    }

    const summary = snippets
      .map(snippet => snippet.slice(0, 160).trim())
      .filter(Boolean)
      .join(' • ');

    warning.textContent = `Content past frame: ${summary}`;
  }

  function syncEditModeClass() {
    document.body.classList.toggle('is-edit-mode', !!state.editMode);
  }

  function updateSaveButtonGlow() {
      // The glow is now controlled entirely by the simple hasChanges flag.
      $("save-btn").classList.toggle("glow", state.hasChanges);
  }

  function updateRestoreButtonState() {
    const restoreBtn = $("restore-btn");
    if (!restoreBtn) return;
    const hasPreviousSession = !!localStorage.getItem(PREVIOUS_SESSION_KEY);
    restoreBtn.disabled = !hasPreviousSession;
    restoreBtn.title = hasPreviousSession ? 'Restore most recently saved' : 'Nothing to restore yet';
    restoreBtn.setAttribute('aria-label', hasPreviousSession ? 'Restore most recently saved slideshow' : 'Restore button disabled until another slideshow is saved');
  }

  function updateToggleHideButtonState() {
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
    const btn = $("toggle-hide-btn");
    const isHidden = slideNode?.getAttribute("hidden") === "true";
    btn.innerHTML = isHidden
      ? '<i class="fa-solid fa-eye"></i>'
      : '<i class="fa-solid fa-eye-slash"></i>';
    btn.title = isHidden ? "Show Slide" : "Hide Slide";
    $("toggle-hide-btn").disabled = !slideNode;
  }

  function updateSlideActionButtons() {
    const totalSlides = state.xmlDoc?.querySelectorAll('presentation > slide').length ?? 0;
    const deleteBtn = $("del-btn");
    if (deleteBtn) {
      const disableDelete = totalSlides <= 1;
      deleteBtn.disabled = disableDelete;
      deleteBtn.title = disableDelete ? "Delete Slide (add more slides to enable)" : "Delete Slide";
    }
  }

  async function insertSlideAfter(index, content = DEFAULT_NEW_SLIDE_CONTENT) {
    const totalSlides = Array.isArray(state.slideEls) ? state.slideEls.length : 0;
    const targetIndex = Math.max(0, Math.min(index + 1, totalSlides));
    updateGroundTruth('ADD_SLIDE', { index: targetIndex, content });
    await buildSlidesFromXMLDoc();
    await refreshThumbnails();
    showSlide(targetIndex);
  }

  async function removeSlideAt(index) {
    const totalSlides = Array.isArray(state.slideEls) ? state.slideEls.length : 0;
    if (totalSlides <= 1) return;
    const clampedIndex = Math.max(0, Math.min(index, totalSlides - 1));
    const nextIndex = clampedIndex >= totalSlides - 1 ? clampedIndex - 1 : clampedIndex;
    updateGroundTruth('DELETE_SLIDE', { index: clampedIndex });
    await buildSlidesFromXMLDoc();
    await refreshThumbnails();
    showSlide(Math.max(0, nextIndex));
  }

  function updateToggleCountButtonState() {
    const btn = $("toggle-count-btn");
    const isOn = $("show-count").checked;
    btn.innerHTML = isOn
      ? '<i class="fa-solid fa-sort-numeric-asc"></i>'
      : '<i class="fa-solid fa-sort-numeric-asc" style="opacity:0.3;"></i>';
    btn.title = isOn ? "Hide Slide Numbers" : "Show Slide Numbers";
  }
 
/* ═══════════════════════════════════════════════════════════════
                    CENTRALIZED STATE UPDATE
   ═══════════════════════════════════════════════════════════════ */

  function updateGroundTruth(action, data = {}) {
    console.log(`[updateGroundTruth] Action: ${action}`, data);

    const editorEl = $("raw-text-editor");
    const editorValue = editorEl ? editorEl.value : null;
    let textPersisted = false;

    if ((action === 'DOWNLOAD' || action === 'SAVE' || action === 'EXIT_EDIT_MODE') && editorValue !== null) {
      textPersisted = saveCurrentSlideText(editorValue, action);
      if (textPersisted) {
        console.log(`[updateGroundTruth] Saved current slide text for ${action}`);
      }
    }

    // 1. Create DOM if needed (for new/load/init actions)
    if (action === 'INIT' || action === 'LOAD' || action === 'NEW') {
      const xmlString = data.xmlString || DEFAULT_XML;
      const parser = new DOMParser();
      const tempDoc = parser.parseFromString(xmlString, "text/xml");
      
      if (tempDoc.getElementsByTagName("parsererror").length > 0) {
        alert("Error parsing presentation XML. Loading default.");
        state.xmlDoc = parser.parseFromString(DEFAULT_XML, "text/xml");
      } else {
        state.xmlDoc = tempDoc;
      }

      // Reset other state
      state.hasChanges = false;
      state.currentAbsoluteSlideIndex = data.slideIndex || 0;
      if (action === 'NEW') {
        state.currentFilename = 'New Presentation';
      }

      if (!state.isRestoringSnapshot) {
        state.undoStack = [];
        state.redoStack = [];
        updateUndoRedoButtons();
      }
      if (data.fileName) {
        state.currentFilename = data.fileName;
      } else if (!state.currentFilename) {
        state.currentFilename = 'New Presentation';
      }
      console.log(`[updateGroundTruth] Created new XML DOM from ${action}`);
    }

    // 2. Update current slide text (for most actions except init)
    if (!textPersisted && action !== 'INIT' && action !== 'LOAD' && action !== 'NEW' && state.editMode && editorValue !== null) {
      if (saveCurrentSlideText(editorValue, action)) {
        textPersisted = true;
        console.log(`[updateGroundTruth] Updated slide ${state.currentAbsoluteSlideIndex} text`);
      }
    }

    // 3. Handle reordering (add, delete, rearrange)
    if (action === 'REORDER') {
      const { fromIndex, toIndex } = data;

      recordSnapshot('REORDER');

      // keep a handle on whichever slide is *currently* selected
      const curSlideNode =
        state.xmlDoc.querySelectorAll('presentation > slide')[state.currentAbsoluteSlideIndex];

      const pres   = state.xmlDoc.querySelector('presentation');
      const slides = Array.from(pres.querySelectorAll('slide'));
      const moved  = slides[fromIndex];

      // physically move the node
      pres.insertBefore(
        moved,
        (fromIndex < toIndex) ? slides[toIndex].nextSibling : slides[toIndex]
      );

      // recompute where the current slide ended up
      const newOrder = Array.from(pres.querySelectorAll('slide'));
      state.currentAbsoluteSlideIndex = newOrder.indexOf(curSlideNode);

      state.hasChanges = true;
      console.log(
        `[updateGroundTruth] Reordered slide ${fromIndex} → ${toIndex}. ` +
        `Current slide is now ${state.currentAbsoluteSlideIndex}`
      );
    }

    if (action === 'ADD_SLIDE') {
      const { index, content } = data;
      recordSnapshot('ADD_SLIDE');
      const newSlideNode = state.xmlDoc.createElement('slide');
      const rawNode = state.xmlDoc.createElement('raw');
      rawNode.appendChild(state.xmlDoc.createCDATASection(content));
      newSlideNode.appendChild(rawNode);

      const slides = state.xmlDoc.querySelectorAll("presentation > slide");
      state.xmlDoc.querySelector("presentation").insertBefore(
        newSlideNode, 
        slides[index] || null
      );
      
      state.hasChanges = true;
      console.log(`[updateGroundTruth] Added slide at index ${index}`);
    }

    if (action === 'DELETE_SLIDE') {
      const { index } = data;
      recordSnapshot('DELETE_SLIDE');
      state.xmlDoc.querySelectorAll("presentation > slide")[index].remove();
      state.hasChanges = true;
      console.log(`[updateGroundTruth] Deleted slide at index ${index}`);
    }

  // 4. Update theme and other metadata
    if (action === 'THEME_CHANGE' || action === 'TOGGLE_COUNT' || action === 'SAVE' || action === 'EXIT_EDIT_MODE') {
      const presNode = state.xmlDoc.querySelector("presentation");
      let metadataChanged = false;

      if (action === 'THEME_CHANGE') {
        if (presNode.getAttribute("theme") !== data.theme) {
          recordSnapshot('THEME_CHANGE');
          presNode.setAttribute("theme", data.theme);
          metadataChanged = true;
        }
      }

      if (action === 'TOGGLE_COUNT') {
        const newValue = $("show-count").checked ? "true" : "false";
        if (presNode.getAttribute("showSlideCount") !== newValue) {
          recordSnapshot('TOGGLE_COUNT');
          presNode.setAttribute("showSlideCount", newValue);
          metadataChanged = true;
        }
      }

      // Scan all slides for the last "Logo:" directive to set it globally.
      let lastLogoUrl = null;
      const logoRegex = /^Logo:\s*(.*)/im;
      state.xmlDoc.querySelectorAll("presentation > slide raw").forEach(raw => {
          const match = (raw.textContent || '').match(logoRegex);
          if (match && match[1].trim()) {
              lastLogoUrl = match[1].trim();
          }
      });

      const previousLogo = presNode.getAttribute("logoUrl") || '';
      if (lastLogoUrl) {
          presNode.setAttribute("logoUrl", lastLogoUrl);
      } else {
          presNode.removeAttribute("logoUrl");
      }
      const currentLogo = presNode.getAttribute("logoUrl") || '';
      if (currentLogo !== previousLogo) {
        metadataChanged = true;
      }

      if (metadataChanged) {
        state.hasChanges = true;
      }
    }
    
    // 5. Handle hide/show
    if (action === 'TOGGLE_HIDE') {
      const { index, hidden } = data;
      const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
      if (slideNode) {
        if (hidden) {
          slideNode.setAttribute("hidden", "true");
        } else {
          slideNode.removeAttribute("hidden");
        }
        state.hasChanges = true;
        console.log(`[updateGroundTruth] Set slide ${index} hidden=${hidden}`);
      }
    }
    
    // Log current state
    console.log(`[updateGroundTruth] Current state:`, {
      slides: state.xmlDoc.querySelectorAll("presentation > slide").length,
      currentSlide: state.currentAbsoluteSlideIndex,
      hasChanges: state.hasChanges,
      theme: state.xmlDoc.documentElement.getAttribute("theme"),
      logoUrl: state.xmlDoc.documentElement.getAttribute("logoUrl")
    });

    // Finally, save the entire presentation to local storage on every update.
    try {
      const serializer = new XMLSerializer();
      const xmlString = serializer.serializeToString(state.xmlDoc);
      const previous = localStorage.getItem(LAST_SESSION_KEY);
      if (previous && previous !== xmlString) {
        localStorage.setItem(PREVIOUS_SESSION_KEY, previous);
      }
      localStorage.setItem(LAST_SESSION_KEY, xmlString);
      console.log('[localStorage] Session saved.');
    } catch (e) {
      console.error('[localStorage] Failed to save session:', e);
    }

    updateRestoreButtonState();
    updateSaveButtonGlow();
  }

  /* ═══════════════════════════════════════════════════════════════
                          NAVIGATION & DISPLAY
     ═══════════════════════════════════════════════════════════════ */
  
  function showSlide(absIndex, fromPresentationNav = false) {
    let targetAbsIndex = absIndex;

    if (state.editMode &&
        state.currentAbsoluteSlideIndex >= 0 && state.currentAbsoluteSlideIndex < state.slideEls.length) {
      updateGroundTruth('NAVIGATE', { from: state.currentAbsoluteSlideIndex, to: absIndex });
    }
    
    if (fromPresentationNav && !state.editMode) {
      let targetVisibleIndex = Math.max(0, Math.min(absIndex, state.visibleSlideIndices.length - 1));
      targetAbsIndex = state.visibleSlideIndices.length > 0 ? 
        state.visibleSlideIndices[targetVisibleIndex] : 0;
      state.currentVisibleSlideIndex = targetVisibleIndex;
    } else {
      targetAbsIndex = Math.max(0, Math.min(absIndex, state.slideEls.length - 1));
    }
    
    state.slideEls.forEach((s, i) => s.classList.toggle("active", i === targetAbsIndex));
    state.currentAbsoluteSlideIndex = targetAbsIndex;
    
    if (!fromPresentationNav || state.editMode) {
      state.currentVisibleSlideIndex = state.visibleSlideIndices.indexOf(state.currentAbsoluteSlideIndex);
    }
 
    // This block forces GIFs to restart when a slide becomes active.
    const activeSlide = state.slideEls[targetAbsIndex];
    if (activeSlide) {
      // 1. For GIFs in <img> tags
      const imgGifs = activeSlide.querySelectorAll('img[src*=".gif"]');
      imgGifs.forEach(gif => {
        const originalSrc = gif.src;
        // This trick forces the browser to reload the image and restart the animation
        gif.src = '';
        gif.src = originalSrc;
      });

      // 2. For GIFs used as a background-image
      if (activeSlide.style.backgroundImage.includes('.gif')) {
        const originalBg = activeSlide.style.backgroundImage;
        // Temporarily remove the background, then add it back in the next frame
        activeSlide.style.backgroundImage = 'none';
        requestAnimationFrame(() => {
          activeSlide.style.backgroundImage = originalBg;
        });
      }
    }
    
    updateHUD();
    updatePresenterView();
    
    if (state.editMode) {
      highlightThumb(state.currentAbsoluteSlideIndex);
      loadTextareaForCurrentSlide();
      updateToggleHideButtonState();
    }

    updateOverflowWarningForEditor();
  }

  function resolveVisibleIndexForAbsolute(absIndex) {
    if (!Array.isArray(state.visibleSlideIndices) || state.visibleSlideIndices.length === 0) {
      return 0;
    }

    const existingIndex = state.visibleSlideIndices.indexOf(absIndex);
    if (existingIndex !== -1) {
      return existingIndex;
    }

    for (let i = 0; i < state.visibleSlideIndices.length; i++) {
      if (state.visibleSlideIndices[i] > absIndex) {
        return i;
      }
    }

    return state.visibleSlideIndices.length - 1;
  }
  
  function updateHUD() {
    const presNode = state.xmlDoc.querySelector("presentation");
    if (!presNode) return;
    
    const showCount = presNode.getAttribute("showSlideCount") !== "false";
    $("slide-counter").style.display = showCount ? "block" : "none";
    $("progress-bar").style.display = showCount ? "block" : "none";
    
    const logoUrl = presNode.getAttribute("logoUrl");
    const logoEl = $("company-logo");
    logoEl.src = logoUrl || '';
    logoEl.style.display = logoUrl ? "block" : "none";
    
    const numVisibleSlides = state.visibleSlideIndices.length;
    const displayCur = numVisibleSlides > 0 ? state.currentVisibleSlideIndex + 1 : 0;
    const displayTot = numVisibleSlides;
    
    $("cur").textContent = state.editMode ? 
      state.currentAbsoluteSlideIndex + 1 : displayCur;
    $("tot").textContent = state.editMode ? 
      state.slideEls.length : displayTot;
    
    let progressPercent = 0;
    if (state.editMode && state.slideEls.length > 0) {
      progressPercent = ((state.currentAbsoluteSlideIndex + 1) / state.slideEls.length) * 100;
    } else if (!state.editMode && numVisibleSlides > 0) {
      progressPercent = ((state.currentVisibleSlideIndex + 1) / numVisibleSlides) * 100;
    }
    $("progress-bar").style.width = `${progressPercent}%`;
  }  

  function buildSlidesFromXMLDoc() {
    state.slideEls = [];
    $("slideshow").innerHTML = "";
    let slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");

    if (slideNodes.length === 0) {
      addSlide(0, "Title: Empty Slide\n\nText: Add content or load a presentation.");
      slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");
    }

    slideNodes.forEach((slideNode) => {
      const rawText = slideNode.querySelector('raw')?.textContent || '';
      const { attributes } = parseRawText(rawText);
      slideNode.setAttribute('title', attributes.title || 'Untitled');
      attributes.hidden ? 
        slideNode.setAttribute('hidden', 'true') : 
        slideNode.removeAttribute('hidden');

      const slideDiv = createSlideElement(rawText);
      $("slideshow").appendChild(slideDiv);
      state.slideEls.push(slideDiv);
    });

    updateVisibleSlideIndices();
    updateSlideActionButtons();
    const finalize = () => {
      scheduleOverflowChecks();
    };

    if (window.MathJax?.typesetPromise) {
      return MathJax.typesetPromise([$("slideshow")]).then(() => finalize());
    }

    finalize();
    return Promise.resolve();
  }
  
  function updateVisibleSlideIndices() {
    state.visibleSlideIndices = [];
    state.xmlDoc.querySelectorAll("presentation > slide").forEach((node, index) => {
      if (node.getAttribute("hidden") !== "true") {
        state.visibleSlideIndices.push(index);
      }
    });
  }
  
  /* ═══════════════════════════════════════════════════════════════
                          SLIDE MANIPULATION
     ═══════════════════════════════════════════════════════════════ */
  
  function addSlide(index, rawContent) {
    const newSlideNode = state.xmlDoc.createElement('slide');
    const rawNode = state.xmlDoc.createElement('raw');
    rawNode.appendChild(state.xmlDoc.createCDATASection(rawContent));
    newSlideNode.appendChild(rawNode);
    
    const slides = state.xmlDoc.querySelectorAll("presentation > slide");
    state.xmlDoc.querySelector("presentation").insertBefore(
      newSlideNode, 
      slides[index] || null
    );
  }
  
  async function updateSingleThumbnail(index) {
    const thumb = document.querySelector(`#thumbs .thumb[data-index="${index}"]`);
    if (!thumb) return;
    
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
    const rawText = slideNode?.querySelector('raw')?.textContent || '';
    const theme = $("theme-selector").value || DEFAULT_THEME;
    
    const iframe = thumb.querySelector('iframe');
    if (iframe) {
      iframe.srcdoc = await getThumbnailHTML(rawText, theme);
    }
    
    // Parse the raw text to check if it's hidden
    const { attributes } = parseRawText(rawText);
    if (attributes.hidden) {
      thumb.classList.add("hidden-slide");
    } else {
      thumb.classList.remove("hidden-slide");
    }
  }  

async function getThumbnailHTML(rawText, theme) {
  const slideElement = createSlideElement(rawText);
  
  // Remove the hidden-in-presentation class for thumbnails
  slideElement.classList.remove('hidden-in-presentation');
  
  const slideElementHTML = slideElement.outerHTML;
  
  // Get the theme CSS content
  let themeCSS = '';
  const themeLink = document.getElementById(`${theme}-stylesheet`);
  const themeHref = themeLink ? themeLink.href : '';
  if (themeLink && themeLink.sheet) {
    try {
      const cssRules = themeLink.sheet.cssRules || themeLink.sheet.rules;
      for (let i = 0; i < cssRules.length; i++) {
        themeCSS += cssRules[i].cssText + '\n';
      }
    } catch (err) {
      // If we can't read CSS, include the link tag
      console.warn('Could not read theme CSS rules, using link tag');
    }
  }
  
  // Always use the same wrapper structure for consistency
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <base href="${window.location.href}">
  <link rel="stylesheet" href="${themeHref}">
  <style>
    ${document.getElementById('core-styles').textContent}
    body { margin: 0; overflow: hidden; }
    .slide-wrapper {
      position: relative;
      width: 100%;
      height: auto;
      aspect-ratio: 16 / 9;
      container-type: inline-size;
      container-name: slideshow;
      font-size: var(--slide-base-font-size);
    }
    #slideshow { position: absolute; inset: 0; }
    .slide { position: absolute; inset: 0; display: flex !important; opacity: 1 !important; }
  </style>
</head>
<body class="${theme}">
  <div class="slide-wrapper">
    <div id="slideshow">${slideElementHTML}</div>
  </div>
</body>
</html>`;
}
  
  /* ═══════════════════════════════════════════════════════════════
                          XML HANDLING
     ═══════════════════════════════════════════════════════════════ */
  
  function initializePresentation(xmlString) {
    const parser = new DOMParser();
    const tempDoc = parser.parseFromString(xmlString, "text/xml");
    
    if (tempDoc.getElementsByTagName("parsererror").length > 0) {
      alert("Error parsing presentation XML. Loading default.");
      state.xmlDoc = parser.parseFromString(DEFAULT_XML, "text/xml");
    } else {
      state.xmlDoc = tempDoc;
    }
    
    const theme = state.xmlDoc.documentElement.getAttribute("theme") || DEFAULT_THEME;
    $("theme-selector").value = theme;
    applyTheme(theme);
  }  

  function createSlideElement(rawText) {
    const { attributes, innerHTML } = parseRawText(rawText);
    const slideDiv = document.createElement("div");
    slideDiv.className = "slide";
    
    if (attributes.hidden) slideDiv.classList.add("hidden-in-presentation");
    
    if (attributes.background) {
      const resolvedUrl = window.presentationBaseUrl ? 
        resolveImagePath(attributes.background, window.presentationBaseUrl) : 
        attributes.background;
      slideDiv.style.backgroundImage = `url("${escapeHtml(resolvedUrl)}")`;
      if (attributes.isFullScreenImage) slideDiv.classList.add("is-fullscreen-image-slide");
    }
    
    if (attributes.header) {
      const headerDiv = document.createElement("div");
      headerDiv.className = "slide-header";
      headerDiv.innerHTML = plainTextToHtml(attributes.header);
      slideDiv.appendChild(headerDiv);
    }

    // Add iframe for FullScreenWebsite
    if (attributes.fullscreenWebsite) {
      const iframeWrapper = document.createElement("div");
      iframeWrapper.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        height: 90%;
        background: white;
        box-shadow: 0 0 50px rgba(0,0,0,0.3);
        border-radius: 8px;
        overflow: hidden;
        z-index: 100;
      `;
      
      const iframe = document.createElement("iframe");
      iframe.src = attributes.fullscreenWebsite;
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 8px;
      `;
      

      // Create a print-only placeholder
      const placeholder = document.createElement("div");
      placeholder.className = "website-print-placeholder";
      placeholder.innerHTML = `<p><strong>Embedded Website:</strong><br>${escapeHtml(attributes.fullscreenWebsite)}</p>`;
      iframeWrapper.appendChild(placeholder);

      iframeWrapper.appendChild(iframe);
      slideDiv.appendChild(iframeWrapper);
      
      // Add click handler to the slide itself for navigation
      slideDiv.addEventListener('click', (e) => {
        // Get the iframe wrapper bounds
        const wrapperBounds = iframeWrapper.getBoundingClientRect();
        const clickX = e.clientX;
        const clickY = e.clientY;
        
        // Check if click is outside the iframe
        if (clickX < wrapperBounds.left || 
            clickX > wrapperBounds.right || 
            clickY < wrapperBounds.top || 
            clickY > wrapperBounds.bottom) {
          
          // Navigate based on which side was clicked
          if (clickX < window.innerWidth / 2) {
            window.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowLeft' }));
          } else {
            window.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowRight' }));
          }
        }
      });
    }
    
    const contentDiv = document.createElement("div");
    contentDiv.className = "slide-content";

    // Create the dedicated wrapper for normal flow content
    const flowContentDiv = document.createElement("div");
    flowContentDiv.className = "slide-flow-content";
    flowContentDiv.innerHTML = innerHTML;
    contentDiv.appendChild(flowContentDiv);
    
    // Check for notes and append them OUTSIDE the flow wrapper
    if (attributes.notes) {
      const notesDiv = document.createElement("div");
      notesDiv.className = "notes";
      notesDiv.innerHTML = plainTextToHtml(attributes.notes);
      contentDiv.appendChild(notesDiv); // Appended as a sibling to flowContentDiv
    }

    slideDiv.appendChild(contentDiv);

    return slideDiv;
  }  

  /* ═══════════════════════════════════════════════════════════════
                      TEXT PARSING & HTML GENERATION
     ═══════════════════════════════════════════════════════════════ */
  
  function plainTextToHtml(text) {
    if (!text || !text.trim()) return "";
    let safeText = escapeHtml(text);
    
    // Process markdown-style formatting
    safeText = safeText.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
    safeText = safeText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    safeText = safeText.replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    return safeText
      .replace(/\r\n/g, '\n')
      .split(/\n{2,}/)
      .map(p => {
        // Don't wrap our alignment divs in paragraph tags
        if (p.trim().startsWith('__ALIGN_')) return p; 
        return `<p>${p.replace(/\n/g, '<br />')}</p>`;
      })
      .join('\n');
  }

  function formatWithJustify(text) {
    if (!text || !text.trim()) return "";

    // Map markers to text-align styles
    const INLINE_ALIGN = {
      "<<<": "text-align:left;",
      ">>>": "text-align:right;",
      "|||": "text-align:center;",
    };

    // 1) Turn inline pairs like <<<text<<< into placeholders
    //    that will later become <p style="..."> (not <div>)
    const inlineMarkers = [];
    const withInlinePlaceholders = text.replace(/(<<<|>>>|\|\|\|)([^\n]*?)\1/g, (_, tok, body) => {
      const key = `__ALIGN_${inlineMarkers.length}__`;
      inlineMarkers.push({
        key,
        // p + width:100% keeps BigText size (.large p) and spans the slide in flex
        html: `<p style="width:100%; ${INLINE_ALIGN[tok]}">${escapeHtml(body)}</p>`,
      });
      return key;
    });

    // 2) Support block fences on their own lines
    const FENCES = new Set(["<<<", ">>>", "|||"]);
    const BLOCK_ALIGN_STYLE = INLINE_ALIGN;

    const lines = withInlinePlaceholders.split(/\r?\n/);
    const out = [];
    let mode = null;
    let buf = [];

    const replaceInlineKeys = (html) => {
      let s = html;
      for (const { key, html: frag } of inlineMarkers) {
        s = s.split(key).join(frag);
      }
      return s;
    };

    const flushNormal = () => {
      if (buf.length === 0) return;
      const html = plainTextToHtml(buf.join("\n"));
      out.push(replaceInlineKeys(html));
      buf = [];
    };

    const flushBlock = (token) => {
      const bodyRaw = buf.join("\n");
      // Allow inline markers inside blocks too
      const bodyWithPlaceholders = bodyRaw.replace(/(<<<|>>>|\|\|\|)([^\n]*?)\1/g, (_, tok, body) => {
        const key = `__ALIGN_${inlineMarkers.length}__`;
        inlineMarkers.push({
          key,
          html: `<p style="${INLINE_ALIGN[tok]}">${escapeHtml(body)}</p>`,
        });
        return key;
      });
      const bodyHtml = replaceInlineKeys(plainTextToHtml(bodyWithPlaceholders));
      // Make the block span the slide so text-align is meaningful in flex layout
      out.push(`<div style="${BLOCK_ALIGN_STYLE[token]}">${bodyHtml}</div>`);
      buf = [];
    };

    for (const raw of lines) {
      const trimmed = raw.trim();
      if (FENCES.has(trimmed)) {
        if (mode === null) {
          flushNormal();
          mode = trimmed;
          buf = [];
        } else if (trimmed === mode) {
          flushBlock(mode);
          mode = null;
        } else {
          buf.push(raw);
        }
        continue;
      }
      buf.push(raw);
    }

    if (mode === null) {
      flushNormal();
    } else {
      flushBlock(mode);
    }

    return out.join("\n");
  }

  function wrapHtmlWithMode(mode, html) {
    if (!html || !html.trim()) return '';

    const normalized = resolveModeState(mode);

    switch (normalized.name) {
      case 'BigText':
        return `<div class="large">${html}</div>`;
      case 'SmallText':
        return `<div class="small">${html}</div>`;
      case 'TinyText':
        return `<div class="tiny">${html}</div>`;
      case 'Text': {
        const scale = normalized.textScale ?? DEFAULT_TEXT_SCALE;
        if (Math.abs(scale - DEFAULT_TEXT_SCALE) > 1e-6) {
          return `<div class="text-scale" style="--text-scale:${scale}; font-size: calc(var(--base-font-size) * ${scale});">${html}</div>`;
        }
        return html;
      }
      default:
        return html;
    }
  }

  function renderRichTextWithModes(rawText, startingMode = 'Text') {
    if (!rawText) {
      return { html: '', mode: resolveModeState(startingMode) };
    }

    let mode = resolveModeState(startingMode);
    let html = '';
    let buffer = '';

    INLINE_MODE_DIRECTIVE_RE.lastIndex = 0;
    const tokens = [];
    let lastIndex = 0;
    let match;

    while ((match = INLINE_MODE_DIRECTIVE_RE.exec(rawText)) !== null) {
      if (match.index > lastIndex) {
        tokens.push({ type: 'text', value: rawText.slice(lastIndex, match.index) });
      }
      tokens.push({
        type: 'directive',
        keyword: match[1] || '',
        arg: (match[2] || '').trim()
      });
      lastIndex = INLINE_MODE_DIRECTIVE_RE.lastIndex;
    }

    if (lastIndex < rawText.length) {
      tokens.push({ type: 'text', value: rawText.slice(lastIndex) });
    }

    const flushBuffer = () => {
      const trimmed = buffer.trim();
      if (!trimmed) {
        buffer = '';
        return;
      }
      html += wrapHtmlWithMode(mode, formatWithJustify(trimmed));
      buffer = '';
    };

    for (const token of tokens) {
      if (token.type === 'text') {
        buffer += token.value;
        continue;
      }

      flushBuffer();

      const directiveInfo = interpretInlineDirective(token.keyword, token.arg);
      if (!directiveInfo) {
        continue;
      }

      if (directiveInfo.action === 'break') {
        html += `<div aria-hidden="true" style="display:block;height:calc(${directiveInfo.lines} * 1lh);"></div>`;
        continue;
      }

      mode = resolveModeState(directiveInfo.mode);
    }

    flushBuffer();
    return { html, mode: resolveModeState(mode) };
  }
 
  function resolveDirectiveToken(rawToken) {
    if (!rawToken) return null;

    if (METADATA_DIRECTIVES.includes(rawToken)) {
      return { name: rawToken, isMetadata: true };
    }

    if (CONTENT_DIRECTIVES.includes(rawToken)) {
      const info = { name: rawToken, isMetadata: false };
      if (rawToken === 'Text') {
        info.textScale = DEFAULT_TEXT_SCALE;
      }
      return info;
    }

    const modeState = interpretModeKeyword(rawToken);
    if (modeState && modeState.name === 'Text') {
      const lower = rawToken.toLowerCase();
      if (lower.startsWith('text') && lower !== 'text') {
        return { name: 'Text', isMetadata: false, textScale: modeState.textScale };
      }
    }

    return null;
  }

  function parseRawText(rawText) {
    const attributes = {};
    let innerHTML = '';
    const lines = (rawText || '').split('\n');
    let currentDirective = { name: 'Text', isMetadata: false, textScale: DEFAULT_TEXT_SCALE };
    let buffer = [];

    function processBuffer() {
      if (buffer.length === 0) return;
      const content = buffer.join('\n').trim();
      if (!content) return;

      // Handle metadata directives
      const directiveName = currentDirective.name || 'Text';
      if (currentDirective.isMetadata || METADATA_DIRECTIVES.includes(directiveName)) {
        attributes[directiveName.toLowerCase()] = content;
        buffer = [];
        return;
      }

      // Handle content directives
      switch (directiveName) {
        case "Hidden":
          if (content.toLowerCase() === 'true') attributes.hidden = true;
          break;
          
        case "Background":
        case "FullScreenImage":
          attributes.background = content;
          if (directiveName === "FullScreenImage") attributes.isFullScreenImage = true;
          break;

        case "Break": {
          const lines = Math.max(0, parseFloat(content) || 1);
          innerHTML += `<div aria-hidden="true" style="display:block;height:calc(${lines} * 1lh);"></div>`;
          break;
        }

        case "FullScreenWebsite":
          attributes.fullscreenWebsite = content.trim();
          break;
          
        case "Header": 
          attributes.header = content; 
          break;
          
        case "Title":
          attributes.title = content.split('\n')[0].trim();
          innerHTML += `<h1>${escapeHtml(content).replace(/\n/g, '<br />')}</h1>`;
          break;

        case "BigText":
          innerHTML += wrapHtmlWithMode('BigText', formatWithJustify(content));
          break;

        case "Text":
          innerHTML += wrapHtmlWithMode(
            makeModeState('Text', currentDirective.textScale),
            formatWithJustify(content)
          );
          break;

        case "SmallText":
          innerHTML += wrapHtmlWithMode('SmallText', formatWithJustify(content));
          break;

        case "TinyText":
          innerHTML += wrapHtmlWithMode('TinyText', formatWithJustify(content));
          break;

        case "Notes":
          attributes.notes = content;
          break;
 
        case "SpeakerNote":
          attributes.speakerNote = content;
          break;

        case "PrintNote":
          attributes.printNotes = content;
          break;
          
        case "Image": {
          const [url, ...captionParts] = content.split(/,(.*)/s);
          const caption = (captionParts[0] || '').trim();
          const resolvedUrl = window.presentationBaseUrl ? 
            resolveImagePath(url.trim(), window.presentationBaseUrl) : url.trim();
          innerHTML += `<div class="img-container"><img src="${escapeHtml(resolvedUrl)}" alt="${escapeHtml(caption)}"><div class="caption">${plainTextToHtml(caption)}</div></div>`;
          break;
        }
          
        case "Columns": {
          const parts = content.split(/^\s*---\s*$/m);

          // Allow extensions with optional ?query, and data: URLs
          const imgLineRe = /^\s*(?:Image:\s*)?(.+\.(?:png|jpe?g|gif|webp|svg)(?:\?.*)?|data:image\/[a-zA-Z+.\-]+;base64,[^,]+)\s*(?:,\s*(.*))?$/i;

          const htmlContainsVisibleText = (html) => {
            if (!html) return false;
            return html.replace(/<[^>]*>/g, '').trim().length > 0;
          };

          const processInlineModesForImageLine = (line, startingMode) => {
            INLINE_MODE_DIRECTIVE_RE.lastIndex = 0;
            let match;
            let lastIndex = 0;
            let seenNonDirectiveSegment = false;
            let mode = resolveModeState(startingMode);
            const beforeFragments = [];
            const afterFragments = [];
            const textSegments = [];

            while ((match = INLINE_MODE_DIRECTIVE_RE.exec(line)) !== null) {
              if (match.index > lastIndex) {
                const between = line.slice(lastIndex, match.index);
                textSegments.push(between);
                if (between.trim()) {
                  seenNonDirectiveSegment = true;
                }
              }

              const directiveInfo = interpretInlineDirective(match[1] || '', (match[2] || '').trim());

              if (directiveInfo) {
                if (directiveInfo.action === 'break') {
                  const frag = `<div aria-hidden="true" style="display:block;height:calc(${directiveInfo.lines} * 1lh);"></div>`;
                  (seenNonDirectiveSegment ? afterFragments : beforeFragments).push(frag);
                } else if (directiveInfo.action === 'mode') {
                  mode = resolveModeState(directiveInfo.mode);
                }
              }

              lastIndex = INLINE_MODE_DIRECTIVE_RE.lastIndex;
            }

            if (lastIndex < line.length) {
              const remainder = line.slice(lastIndex);
              textSegments.push(remainder);
              if (remainder.trim()) {
                seenNonDirectiveSegment = true;
              }
            }

            return {
              sanitizedLine: textSegments.join(''),
              mode: resolveModeState(mode),
              beforeHtml: beforeFragments.join(''),
              afterHtml: afterFragments.join('')
            };
          };

          const colsHtml = parts.map(part => {
            const lines = part.trim().split(/\r?\n/);

            const blocks = [];
            let pendingText = '';
            let currentMode = makeModeState('Text');
            let imageCount = 0;
            let hasTextBlock = false;

            const flushText = () => {
              if (!pendingText) {
                pendingText = '';
                return;
              }
              const rendered = renderRichTextWithModes(pendingText, currentMode);
              if (rendered.html.trim()) {
                blocks.push(rendered.html);
                if (htmlContainsVisibleText(rendered.html)) {
                  hasTextBlock = true;
                }
              }
              currentMode = rendered.mode;
              pendingText = '';
            };

            for (const rawLine of lines) {
              const inlineInfo = processInlineModesForImageLine(rawLine, currentMode);
              const sanitized = inlineInfo.sanitizedLine.trim();
              const match = sanitized ? sanitized.match(imgLineRe) : null;

              if (match) {
                flushText();

                if (inlineInfo.beforeHtml) {
                  blocks.push(inlineInfo.beforeHtml);
                  if (htmlContainsVisibleText(inlineInfo.beforeHtml)) {
                    hasTextBlock = true;
                  }
                }

                imageCount++;
                const imageUrl = match[1].trim();
                const colCaption = (match[2] || '').trim();
                const resolvedUrl = window.presentationBaseUrl
                  ? resolveImagePath(imageUrl, window.presentationBaseUrl)
                  : imageUrl;
                blocks.push(
                  `<div class="img-container">
                    <img src="${escapeHtml(resolvedUrl)}" alt="${escapeHtml(colCaption)}">
                    <div class="caption">${plainTextToHtml(colCaption)}</div>
                  </div>`
                );

                if (inlineInfo.afterHtml) {
                  blocks.push(inlineInfo.afterHtml);
                  if (htmlContainsVisibleText(inlineInfo.afterHtml)) {
                    hasTextBlock = true;
                  }
                }

                currentMode = inlineInfo.mode;
                continue;
              }

              pendingText += pendingText ? `\n${rawLine}` : rawLine;
            }

            flushText();

            const onlyImages = imageCount > 0 && !hasTextBlock;
            const cls  = onlyImages ? 'column images-only' : 'column';
            const data = onlyImages ? ` data-imgcount="${imageCount}"` : '';
            return `<div class="${cls}"${data}>${blocks.join('')}</div>`;
          }).join('');

          innerHTML += `<div class="columns">${colsHtml}</div>`;
          break;
        }

        case "Table": {
          const rows = content.split(/^\s*---\s*$/m);
          let tableHtml = '<table>';

          if (rows.length > 0) {
            const headerCells = rows.shift().split('&').map(cell => {
              const rendered = renderRichTextWithModes(cell.trim());
              return `<th>${rendered.html || plainTextToHtml(cell.trim())}</th>`;
            }).join('');
            tableHtml += `<thead><tr>${headerCells}</tr></thead>`;
          }

          const bodyRows = rows.map(row => {
            const cells = row.split('&').map(cell => {
              const trimmed = cell.trim();
              const rendered = renderRichTextWithModes(trimmed);
              const cellHtml = rendered.html || plainTextToHtml(trimmed);
              return `<td>${cellHtml}</td>`;
            }).join('');
            return `<tr>${cells}</tr>`;
          }).join('');

          tableHtml += `<tbody>${bodyRows}</tbody></table>`;
          innerHTML += tableHtml;
          break;
        }
      }
      buffer = [];
    }

    // Process lines
    for (const line of lines) {
      const match = line.match(/^([A-Za-z][A-Za-z0-9.]*):\s*(.*)/);
      if (match) {
        const directiveInfo = resolveDirectiveToken(match[1]);
        if (directiveInfo) {
          processBuffer();
          const nextDirective = { ...directiveInfo };
          if (nextDirective.name === 'Text' && typeof nextDirective.textScale !== 'number') {
            nextDirective.textScale = DEFAULT_TEXT_SCALE;
          }
          currentDirective = nextDirective;
          buffer = [];
          buffer.push(match[2] || '');
          continue;
        }
      }
      buffer.push(line);
    }
    processBuffer();

    return { attributes, innerHTML };
  }

  /* ═══════════════════════════════════════════════════════════════
                          UTILITY FUNCTIONS
     ═══════════════════════════════════════════════════════════════ */
  
  const $ = (id) => document.getElementById(id);
  
  const escapeHtml = (s) =>
    s.replace(/[&<>"']/g, c =>
      ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c])
    );
  
  /* ═══════════════════════════════════════════════════════════════
                        THEME DISCOVERY & LOADING
     ═══════════════════════════════════════════════════════════════ */
  
  async function discoverThemes() {
    state.availableThemes = [];
    
    for (const themeName of AVAILABLE_THEMES) {
      const filename = `${themeName}.css`;
      try {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = filename;
        link.id = `${themeName}-stylesheet`;
        link.disabled = true;
        document.head.appendChild(link);
        
        const displayName = themeName
          .replace(/-/g, ' ')
          .split(' ')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
        
        state.availableThemes.push({
          filename: filename,
          id: themeName,
          name: displayName
        });
      } catch (e) {
        console.warn(`Theme ${filename} not found`);
      }
    }
    
    const themeSelector = $('theme-selector');
    themeSelector.innerHTML = '';
    state.availableThemes.forEach(theme => {
      const option = document.createElement('option');
      option.value = theme.id;
      option.textContent = theme.name;
      themeSelector.appendChild(option);
    });
  }
  
async function applyTheme(themeId) {
  // Disable all theme stylesheets
  document.querySelectorAll('link[id$="-stylesheet"]').forEach(link => {
    link.disabled = true;
  });
  
  // Enable the selected theme
  const themeLink = document.getElementById(`${themeId}-stylesheet`);
  if (themeLink) {
    themeLink.disabled = false;
    
    // Wait for the stylesheet to actually load
    await new Promise((resolve) => {
      if (themeLink.sheet && themeLink.sheet.cssRules) {
        resolve(); // Already loaded
      } else {
        themeLink.addEventListener('load', resolve, { once: true });
        setTimeout(resolve, 500); // Timeout fallback
      }
    });
  }
  
  // Update body class without disturbing edit-mode flag
  document.body.classList.remove(...AVAILABLE_THEMES);
  document.body.classList.add(themeId);
  if (state.editMode) {
    document.body.classList.add('is-edit-mode');
  }

  // Now refresh thumbnails with loaded CSS
  await refreshThumbnails();
}

  /* ═══════════════════════════════════════════════════════════════
                          URL PARAMETER HANDLING
     ═══════════════════════════════════════════════════════════════ */
  
  function handleURLParameters() {
    const urlParams = new URLSearchParams(window.location.search);
    const inputUrl = urlParams.get('xml');
    
    // Check for a saved session in local storage first, but only if no URL is specified.
    if (!inputUrl) {
        const savedSession = localStorage.getItem(LAST_SESSION_KEY);
        if (savedSession) {
            init(savedSession, { slideIndex: 0 });
            return; // Stop here to prevent loading the default.
        }
        // If no saved session, proceed to load the default.
        init(undefined, { fileName: 'New Presentation', slideIndex: 0 });
        return;
    }

    let textFileUrl;
    let baseFolderUrl;

    if (inputUrl.match(/dropbox\.com\/sh\//)) {
      const clean = inputUrl.split('?')[0];
      baseFolderUrl = clean.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
      textFileUrl = `${baseFolderUrl}/Slides.txt?dl=1`;
    } else if (inputUrl.match(/drive\.google\.com\/drive\/folders\//)) {
      alert('Google Drive folders aren\'t directly fetchable. Please link to your Slides.txt file, not to the folder.');
      return init(undefined, { fileName: 'New Presentation', slideIndex: 0 });
    } else {
      const absoluteInputUrl = new URL(inputUrl, window.location.href).href;
      textFileUrl = absoluteInputUrl;
      baseFolderUrl = absoluteInputUrl.substring(0, absoluteInputUrl.lastIndexOf('/') + 1);
    }

    const absoluteXmlUrl = new URL(textFileUrl, window.location.href).href;
    const fetchUrl = 'proxy.php?url=' + encodeURIComponent(absoluteXmlUrl);

    window.presentationBaseUrl = baseFolderUrl;

    fetch(fetchUrl)
      .then(res => {
        if (!res.ok) throw new Error(`Load failed: ${res.status}`);
        return res.text();
      })
      .then(txt => {
        const fileLeaf = textFileUrl.split('/').pop() || 'Slides.txt';
        const cleanName = fileLeaf.replace(/\.[^.]+$/, '');
        const newXml = convertTxtToXML(txt, fileLeaf);
        state.currentFilename = cleanName;
        sessionStorage.setItem(`Slides_${cleanName}`, newXml);
        init(newXml, { fileName: cleanName, slideIndex: 0 });
      })
      .catch(err => {
        console.error(err);
        alert('Failed to load presentation.');
        init(undefined, { fileName: 'New Presentation', slideIndex: 0 });
      });
  }

  window.resolveImagePath = function(imageSrc, baseUrl) {
    if (!baseUrl || imageSrc.startsWith('http://') || 
        imageSrc.startsWith('https://') || imageSrc.startsWith('data:')) {
      return imageSrc;
    }
    return new URL(imageSrc, baseUrl).href;
  };
  
  /* ═══════════════════════════════════════════════════════════════
                          16:9 ASPECT RATIO SETUP
     ═══════════════════════════════════════════════════════════════ */
  
function wrapSlideshowFor16x9() {
  const slideshow = $("slideshow");
  if (!slideshow.parentElement.classList.contains('presentation-scaler')) {
    const viewport = document.createElement('div');
    viewport.className = 'presentation-viewport';

    const scaler = document.createElement('div');
    scaler.className = 'presentation-scaler';

    slideshow.parentNode.insertBefore(viewport, slideshow);
    viewport.appendChild(scaler);
    scaler.appendChild(slideshow);

    // HUD goes on the viewport (letterbox), not over the slide
    viewport.appendChild($("slide-counter"));
    viewport.appendChild($("progress-bar"));
    const logo = $("company-logo");
    if (logo) viewport.appendChild(logo);
  }
}


  
/* ═══════════════════════════════════════════════════════════════
                          INITIALIZATION
     ═══════════════════════════════════════════════════════════════ */

  async function init(newXmlString, options = {}) {
    updateGroundTruth('INIT', {
      xmlString: newXmlString,
      slideIndex: options.slideIndex,
      fileName: options.fileName
    });

    const theme = state.xmlDoc.documentElement.getAttribute("theme") || DEFAULT_THEME;
    $("theme-selector").value = theme;
    await applyTheme(theme);

    await buildSlidesFromXMLDoc();
    const visibleIndex = resolveVisibleIndexForAbsolute(state.currentAbsoluteSlideIndex);
    if (state.editMode) {
      showSlide(state.currentAbsoluteSlideIndex, false);
    } else {
      showSlide(visibleIndex, true);
    }
    updateHUD();
    updateToggleCountButtonState();

    if (state.editMode && $("editor").classList.contains("active")) {
      setupEditorUI();
    }
    
    if (!state.editMode) {
      requestWakeLock();
    }

    $("raw-text-editor").value = getRawTextForSlide(state.currentAbsoluteSlideIndex);
  }
  
  // Main entry point
  return async function() {
    // Discover and load themes
    await discoverThemes();
    
    // Setup event handlers
    setupEventHandlers();
    
    // Setup 16:9 aspect ratio
    wrapSlideshowFor16x9();
    
    // Handle URL parameters or initialize normally
    handleURLParameters();
    
    // Setup editor if in edit mode
    if (state.editMode) {
      $("editor").classList.add("active");
      setupEditorUI();
    }
  };
})();

// Start the application
ModernSlideshow();
</script>
</body>
</html>