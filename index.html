<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Modern Slideshow Editor</title>

<!----- RENDER MATH CORRECTLY -->
<!-- MathJax -->
<script>
  window.MathJax = {
    tex: { 
      inlineMath: [["$", "$"], ["\\(", "\\)"]], 
      displayMath: [["$$", "$$"], ["\\[", "\\]"]], 
      processEscapes: true 
    },
    svg: { fontCache: "global" }
  };
</script>
<script id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>

<style id="core-styles">
/* ----------------------------- */
/* --- Core Style Variables --- */
/* ----Specific slide style set in the user-created .css files----- */

/* Default variables, overridden by themes */
:root {
  --editor-bg-color: #fffff8;
  --editor-text-color: #1a1a1a;
  --editor-border-color: #d4d4d4;
  --editor-accent-color: #333333;
  --editor-accent-text-color: #ffffff;
  --editor-thumb-bg: #ffffff;
  --editor-thumb-selected-border: #333333;
  --editor-input-bg: #ffffff;
  --editor-input-text: #333333;
  --editor-input-border: #d4d4d4;
  --editor-ui-font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --editor-mono-font: "Courier New", monospace;
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { width: 100%; height: 100%; overflow: hidden; font-size: var(--base-font-size); }

body {
  line-height: 1.5;
}

/* --------------------------*/
/* ---- Minor frontend --- */
/* ------------------------*/
.deckbar-spacer {
  flex-grow: 1; /* This makes the spacer expand and push other items */
}

#editor button.primary-action {
  --editor-accent-color: #008000; 
}


/* ----------------------------- */
/* --- Slideshow Layout --- */
/* ----------------------------- */

#slideshow {
  position: fixed; inset: 0; display: flex; align-items: center;
  justify-content: center; background: var(--bg-color);
}

.slide {
  position: absolute; inset: 0; display: flex; align-items: center;
  justify-content: center; opacity: 0; transition: opacity 0.4s ease;
  background-position: center; background-size: cover; background-repeat: no-repeat;
}
.slide.active { opacity: 1; z-index: 1; }
.slide.hidden-in-presentation { display: none !important; }

.slide.is-fullscreen-image-slide {
  background-size: contain;
}
.slide.is-fullscreen-image-slide .slide-content {
  background: transparent !important;
}

.slide-header {
  position: absolute; top: 0; left: 0; width: 100%;
  font-family: var(--sans-font); font-size: 0.9rem;
  padding: 0.6rem 1rem; color: var(--accent-color);
}

.slide-content {
  width: 100%; height: 100%; padding: 4rem;
  display: flex; /* This is primarily for the notes positioning now */
  position: relative; 
}

.slide-flow-content {
  width: 100%;
  margin: auto; 
  display: flex;
  flex-direction: column;
  align-items: center; /* Centers block-level children like tables/images */
}

.slide[style*="background-image"] .slide-content {
  background: var(--slide-content-bg-if-image);
}

/* ----------------------------- */
/* --- Slide Typography --- */
/* ----------------------------- */
.slide-content .text-center { text-align: center; }

.slide-content .columns { 
  display: flex; gap: 2rem; align-items: flex-start; width: 100%; 
}
.slide-content .columns .column { flex: 1; }

.slide-content table { 
  border-collapse: collapse; margin: 1rem auto; font-size: 1.1rem; 
}
.slide-content th, .slide-content td { 
  border: 1px solid var(--h1-border-color); 
  padding: 0.5em 0.8em; 
  text-align: left; 
}
.slide-content th { 
  font-weight: bold; 
  background-color: color-mix(in srgb, var(--bg-color) 95%, var(--main-text-color) 5%); 
}

.slide-content .img-container { 
  text-align: center; 
  margin-bottom: 1rem; 
  max-width: 100%; 
  max-height: 80vh; 
}
.slide-content .img-container img, .slide-content .column img {
  max-width: 100%; 
  display: block;
  margin: 0 auto 0.5rem auto; 
  border-radius: 0px; 
  object-fit: contain;
  width: auto; 
  height: auto; 
  max-height: calc(80vh - 3.5rem); 
}

.slide-content .caption { 
  font-size: 1rem; 
  font-style: italic; 
  color: var(--accent-light-color); 
}

/* ----------------------------- */
/* --- Presentation HUD --- */
/* ----------------------------- */

.company-logo { 
  position: fixed; 
  top: 1rem; 
  right: 1rem; 
  max-height: 60px; 
  display: none; 
  z-index: 5; 
}
.slide-counter { 
  position: fixed; 
  bottom: 1rem; 
  left: 1rem; 
  font-size: 0.9rem; 
  color: color-mix(in srgb, var(--main-text-color) 70%, transparent); 
  z-index: 5; 
}
#progress-bar { 
  position: fixed; 
  bottom: 0; 
  left: 0; 
  height: 4px; 
  background: var(--accent-color); 
  z-index: 10; 
  transition: width 0.3s; 
}

/* ----------------------------- */
/* --- Editor UI Layout --- */
/* ----------------------------- */

#editor {
  position: fixed; 
  inset: 0; 
  z-index: 100;
  background: var(--editor-bg-color);
  color: var(--editor-text-color);
  font-family: var(--editor-ui-font-family);
  display: none; 
  flex-direction: row; 
  overflow: hidden;
}
#editor.active { display: flex; }
#editor.active ~ #slideshow .hidden-in-presentation {
  display: flex !important;
  opacity: 0.3 !important;
}

#thumbs {
  width: 240px; 
  overflow-y: auto;
  border-right: 1px solid var(--editor-border-color);
  padding: 1rem; 
  display: flex; 
  flex-direction: column; 
  gap: 1rem;
}
#editor-main {
  flex: 1; 
  display: flex; 
  flex-direction: column;
  padding: 1rem; 
  overflow: hidden;
}

/* ----------------------------- */
/* --- Editor Components --- */
/* ----------------------------- */

.thumb {
  position: relative;
  width: 200px;
  padding-top: 112px;
  border: 2px solid var(--editor-border-color);
  border-radius: 6px;
  background: var(--editor-thumb-bg);
  cursor: pointer;
  pointer-events: auto;
  overflow: hidden;
}
.thumb.selected {
  border-color: var(--editor-thumb-selected-border);
  box-shadow: 0 0 0 2px var(--editor-thumb-selected-border);
}

.thumb-iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 640px;
  height: 360px;
  transform: scale(0.3125);
  transform-origin: top left;
  border: none;
  pointer-events: none;
}

.thumb-number {
  position: absolute; 
  top: 4px; 
  left: 6px; 
  font-size: 10px;
  font-family: var(--editor-mono-font);
  background: var(--editor-accent-color); 
  color: var(--editor-accent-text-color);
  padding: 1px 5px; 
  border-radius: 3px; 
  z-index: 1;
}
.thumb.hidden-slide { opacity: 0.6; }
.thumb.hidden-slide::after {
  content: "HIDDEN";
  position: absolute; 
  bottom: 4px; 
  right: 4px; 
  font-family: var(--editor-mono-font);
  font-size: 10px;
  background-color: rgba(0,0,0,0.7); 
  color: white;
  padding: 2px 5px; 
  border-radius: 3px; 
  z-index: 2;
}

#raw-text-editor {
  flex: 1;
  font-size: 18px;
  line-height: 1.7;
  padding: 1rem;
  border: none;
  resize: none;
  margin-bottom: 1rem;
  font-family: var(--editor-ui-font-family);
  background-color: var(--editor-input-bg);
  color: var(--editor-input-text);
  white-space: pre-wrap; 
  word-wrap: break-word;
  overflow: auto;
}
.ta-valid { border-color: #4caf50; }
.ta-invalid { border-color: #f44336; }

.toolbar {
  display: flex; 
  flex-wrap: wrap; 
  font-family: var(--editor-ui-font-family);
  font-size: 16px;
  gap: 0.75rem;
  align-items: center; 
  margin-bottom: 1rem;
}
.toolbar #logo-url {
  width: 150px;
}

#editor button {
  padding: 8px 16px;
  background: var(--editor-accent-color);
  font-family: var(--editor-ui-font-family);
  font-size: 16px;
  color: var(--editor-accent-text-color);
  border: none; 
  border-radius: 4px; 
  cursor: pointer;
  transition: background-color 0.2s;
}
#editor button:hover:not(:disabled) { 
  background: color-mix(in srgb, var(--editor-accent-color) 85%, black); 
}
#editor button:disabled { 
  opacity: 0.5; 
  cursor: not-allowed; 
}

@keyframes editor-glow {
  from { box-shadow: 0 0 8px 2px var(--editor-accent-color); }
  to   { box-shadow: 0 0 2px 1px color-mix(in srgb, var(--editor-accent-color) 50%, transparent); }
}
#editor .glow { animation: editor-glow 1.2s infinite alternate; }

.toolbar label { 
  display: inline-flex; 
  align-items: center; 
  gap: 0.4em; 
}
.toolbar select, .toolbar input[type="text"] {
  padding: 0.3rem 0.5rem;
  border-radius: 4px; 
  border: 1px solid var(--editor-input-border);
  background-color: var(--editor-input-bg); 
  font-size: 16px;
  font-family: var(--editor-ui-font-family);
  color: var(--editor-input-text);
}

/* ----------------------------- */
/* --- Help Modal --- */
/* ----------------------------- */

.modal {
  position: fixed; 
  inset: 0; 
  background: rgba(0, 0, 0, 0.6);
  display: none; 
  align-items: center; 
  justify-content: center; 
  z-index: 250;
}
.modal.active { display: flex; }
.modal-box {
  background: var(--editor-bg-color); 
  color: var(--editor-text-color);
  max-width: 700px; 
  max-height: 85vh; 
  overflow: auto;
  padding: 2rem; 
  border-radius: 8px; 
  font-family: var(--editor-ui-font-family);
  line-height: 1.6;
}
.modal-box h3 { 
  margin-bottom: 1rem; 
  font-size: 1.5rem; 
}
.modal-box pre {
  background-color: color-mix(in srgb, var(--editor-bg-color) 90%, var(--editor-text-color) 10%);
  padding: 1em; 
  border-radius: 4px; 
  overflow-x: auto;
  font-family: var(--editor-mono-font); 
  font-size: 0.9rem;
  white-space: pre-wrap;
}
.modal-box button {
  padding: 0.5rem 1rem; 
  background: var(--editor-accent-color);
  color: var(--editor-accent-text-color); 
  border: none;
  border-radius: 4px; 
  cursor: pointer; 
  margin-top: 1rem; 
  float: right;
}

/* ----------------------------- */
/* --- Drag and Drop Styles --- */
/* ----------------------------- */

#thumbs {
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 100%;
}
#thumbs::-webkit-scrollbar {
  width: 8px;
}
#thumbs::-webkit-scrollbar-track {
  background: transparent;
}
#thumbs::-webkit-scrollbar-thumb {
  background-color: #999;
  border-radius: 4px;
}
#thumbs:hover::-webkit-scrollbar-thumb {
  background-color: #666;
}


.thumb {
  cursor: move;
  cursor: grab;
  transition: opacity 0.2s;
  user-select: none;
}

.thumb:active {
  cursor: grabbing;
}

.thumb.dragging {
  opacity: 0.4;
}

.thumb-placeholder {
  background: #007bff;
  opacity: 0.2;
  border: 2px dashed #0056b3;
  border-radius: 4px;
  margin: 5px;
  box-sizing: border-box;
}

/* ----------------------------- */
/* --- 16:9 Aspect Ratio --- */
/* ----------------------------- */

.presentation-viewport {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
}

.presentation-scaler {
  position: relative;
  width: 100%;
  max-width: 177.77vh;
  max-height: 56.25vw;
  aspect-ratio: 16/9;
  box-shadow: 0 0 50px rgba(0,0,0,0.5);
}

#slideshow {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--bg-color);
}

.presentation-scaler .slide-counter {
  position: absolute;
  bottom: 20px;
  right: 20px;
  font-size: 16px;
  color: #888;
  z-index: 100;
}

.presentation-scaler #progress-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 5px;
  background-color: #007bff;
  z-index: 100;
}

.presentation-scaler .company-logo {
  position: absolute;
  top: 20px;
  right: 20px;
  max-height: 50px;
  max-width: 150px;
  z-index: 100;
}

.slide {
  width: 100%;
  height: 100%;
}


@media print {
  /* Page setup */
  @page {
    size: landscape;
    margin: 0;
  }

  /* Hide UI chrome */
  #editor,
  #progress-bar,
  #slide-counter {
    display: none !important;
  }

  /* Reset document margins and overflow */
  html, body {
    margin: 0 !important;
    padding: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: #fff !important;
    overflow: visible !important;
  }

  /* Flatten viewport/scaler and slideshow containers */
  .presentation-viewport,
  .presentation-scaler,
  #slideshow {
    position: static !important;
    width: auto !important;
    height: auto !important;
    max-width: none !important;
    max-height: none !important;
    display: block !important;
    background: transparent !important;
    transform: none !important;
    box-shadow: none !important;
    aspect-ratio: unset !important;
    top: auto !important;
    left: auto !important;
    right: auto !important;
    bottom: auto !important;
    inset: unset !important;
  }

  /* Each slide becomes a full-page white "letterbox" */
  .slide {
    overflow: hidden !important;
    position: relative !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: calc((100vh - 56.25vw) / 2) 0 !important; 
    background-color: #fff !important;
    background-clip: padding-box !important; 
    opacity: 1 !important;
    visibility: visible !important;
    z-index: auto !important;
    transform: none !important;
    transition: none !important;
    page-break-after: always;
    page-break-inside: avoid;
    break-after: page;
    break-inside: avoid;
  }

  /* Don't force a break after the last slide or show hidden slides */
  .slide:last-child {
    page-break-after: auto;
  }
  .slide.hidden-in-presentation {
    display: none !important;
  }

  .slide[style*="background-image"] {
    background-size: cover !important;
    background-position: center !important;
    background-clip: content-box !important;
  }

  /* Preserve any slide background images */
  .slide[style*="background-image"] .slide-content {
    background-image: inherit !important;
    background-size: cover !important;
    background-position: center center !important;
  }
  .slide[style*="background-image"] .slide-content::before {
    content: '';
    position: absolute;
    inset: 0;
    background: var(--slide-content-bg-if-image);
    pointer-events: none;
  }

  /* Inner aspect-ratio container */
  .slide::before {
    content: '';
    position: absolute !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    width: 177.78vh !important;   /* 16:9 aspect ratio */
    height: 100vh !important;
    max-width: 100vw !important;
    max-height: 56.25vw !important;
    background-image: none !important;
    z-index: 99999 !important;
  }

  /* Slide content box */
  .slide-content {
    position: relative !important;
    display: flex !important;
    width: 177.78vh !important;
    height: 100vh !important;
    max-width: 100vw !important;
    max-height: 56.25vw !important;
    padding: 4rem !important;
    box-sizing: border-box !important;
    overflow: hidden !important;
    background: var(--bg-color) !important;
  }

  /* Flow content inside slides */
  .slide-flow-content {
    position: relative !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    width: 100% !important;
    margin: auto !important;
  }

  /* Ensure all colors and backgrounds print */
  * {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
    color-adjust: exact !important;
  }

  .slide.is-fullscreen-image-slide .slide-content::before {
    background: transparent !important;
  }
}
</style>

<!-- Theme stylesheets will be dynamically loaded -->

</head>
<body>
  <!-- Presentation View -->
  <div id="slideshow"></div>
  <img id="company-logo" class="company-logo" />
  <div id="slide-counter" class="slide-counter">
    <span id="cur">1</span>/<span id="tot">1</span>
  </div>
  <div id="progress-bar"></div>

  <!-- Editor View -->
  <div id="editor">
    <div id="thumbs"></div>
    <div id="editor-main">
      <textarea id="raw-text-editor" placeholder="Enter slide content here. Click Help for syntax."></textarea>
      <div class="toolbar">
        <button id="add-btn"       title="New Slide">      <i class="fa-solid fa-plus"></i></button>
        <button id="del-btn"    title="Delete Slide">   <i class="fa-solid fa-minus"></i></button>
        <button id="toggle-hide-btn"    title="Hide/Show Slide"> <i class="fa-solid fa-eye"></i></button>
        <!-- hidden state, still used by updateHUD() -->
        <input type="checkbox" id="show-count" checked style="display:none">
        <!-- toggle button -->
        <button id="toggle-count-btn" title="Hide Slide Numbers">
          <i class="fa-solid fa-numeric-sort-asc"></i>
        </button>
        <label>Logo? <input id="logo-url" type="text" /></label>
        <label>Theme
          <select id="theme-selector">
          <!-- Options will be dynamically populated -->
          </select>
        </label>
        <div class="deckbar-spacer"></div> 
        <button id="help-btn" title="Help"><i class="fa-solid fa-question"></i></button> 
        <button id="new-presentation-btn"   title="New Slideshow">  <i class="fa-solid fa-file-circle-plus"></i></button>
        <button id="load-btn"  title="Load Slideshow"> <i class="fa-solid fa-folder-open"></i></button>
        <button id="download-txt-btn"        title="Download Raw Presentation">       <i class="fa-solid fa-download"></i></button>
        <button id="save-btn" class="primary-action" title="Presentation View"><i class="fa-solid fa-bullhorn"></i></button> 
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="help" class="modal">
    <div class="modal-box">
      <button id="close-help">Close</button>
      <h3>Modern Slides | Kevin Bryan | July 2025</h3>
      <p>This is a modern, very computationally light, slideshow maker. It completely separates style rules from content. You can edit it completely online or download the code from <a href="https://github.com/kevincure/ModernSlides">github.com/kevincure/ModernSlides</a> or find more similar tools at <a href="https://kevinbryanecon.com/tools.html">kevinbryanecon.com/tools.html</a> and create your slides locally in your browser. Once your slides are set, click download. You can upload that text file to anywhere you like, then open it with a url query of the form ?xml=...: e.g., <a href="https://kevinbryanecon.com/ModernSlides/?xml=http://www.inastrangetown.com/testslides.txt">this one here</a></p> 
      <p>Each slide is defined by directives in a Markdown type format. A directive starts a line, ends with a colon `:`, and its value is all text that follows until the next directive.</p>
      <p>Press 'e' to toggle between edit and present, 'f' to go to full screen mode, and 'p' to open a presenter mode window.
      <pre>
# --- METADATA (place at the top) ---
Hidden: true (hides the slide, can be set with eye open/closed button)
Background: image-url.jpg
FullScreenImage: image-url.jpg
Header: Small text in corner


# --- CONTENT DIRECTIVES ---
Title: The Main Title of The Slide
  Supports $LaTeX$ and
  manual line breaks.

BigText: For large, prominent text.
  Also supports line breaks and paragraphs.

Text: For standard body text.
  A blank line between text...

  ...and a skipped line creates a new paragraph.

SmallText: For smaller body text.

TinyText: For footnote-sized text.

Notes: For notes at the bottom of the slide.
  These appear in a special position.

SpeakerNote: For notes for yourself in presentation mode

Image: image-url.jpg (or a weblink to jpg/png/gif), An optional caption for image after the comma

FullScreenWebsite: https://example.com

Columns:
  This is the left column. Can contain any
  amount of text, paragraphs, and $math$.
  ---
  This is the right column. You can put an
  image here using the 'image, caption' syntax:
  test.jpg, A caption for the image in the column.
  ...or you can just have more text.
  ---
  Third column

Table:
  Header 1 & Header 2 & Header 3
  ---
  Cell 1.1 & Cell 1.2 & Cell 1.3
  ---
  Cell 2.1 & Cell 2.2 & $math$ is fine

*some text* is italic, **some text** is bold, ***some text*** is bold italic.

# --- NOTES ---
# - Download Raw Deck and Load Deck give you your slides but you
#      will still need any images referred to in the same folder
# - If no directive is given, text defaults to `Text:`.
# - In `Columns` and `Table`, use `---` on its own line
#       to separate sections/rows.
# - You cannot nest directives (e.g., a Table inside a Column).
# - Notes appear at the bottom in a special color and shift other content up.
# - 7 different styles are given, but you can create your own also
</pre>
    </div>
  </div>

<script>
const tufteSlideshowApp = (function() {
  'use strict';
  
  /* ═══════════════════════════════════════════════════════════════
                              CONSTANTS
     ═══════════════════════════════════════════════════════════════ */
  
  const DEFAULT_XML = `<presentation title="New Presentation" showSlideCount="true" theme="minimal">
  <slide>
    <raw><![CDATA[
Title: Modern Slides
Header: Header text here
BigText: This is a slideshow.
  Press 'E' to edit, 'F' fullscreen, 'Esc' go back
Text: Use arrow keys to navigate.
SmallText: smaller
TinyText: tiny
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
Title: Raw Text Demo
Text: This slide *demonstrates* various **features**. For example: $e = mc^2$.
Columns:
  Column 1
  ---
  This is the ***left*** column. You can have text and math like $\\alpha + \\beta$.
  A blank line creates a new paragraph.

  Like this.
  ---
  And column 3 here.
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
Text: This slide shows a table
Table:
  Header 1 & Header 2
  ---
  Value 1 & $\\sum_{i=0}^n i^2$
  ---
  Value 2 & Another Value
Notes: And notes for later
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
FullScreenImage: https://files.worldwildlife.org/wwfcmsprod/images/Mountain_Gorilla_Silverback_WW22557/hero_full/cg47pknak_Mountain_Gorilla_Silverback_WW22557.jpg
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
FullScreenWebsite: https://www.kevinbryanecon.com
SpeakerNote: Press p to create a presenter mode window and you'll see your note
    ]]></raw>
  </slide>
  <slide>
    <raw><![CDATA[
Image: https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExc3p5N2UwOGppdTc4NXgzMWN1czI5eTRicGhtZzQ3ZWJ3dXUxNXF1aiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/pKf7PlSjbtJN6/giphy.gif
Text: GIFs work too
    ]]></raw>
  </slide> 
  <slide>
    <raw><![CDATA[
Background: https://files.worldwildlife.org/wwfcmsprod/images/Mountain_Gorilla_Silverback_WW22557/hero_full/cg47pknak_Mountain_Gorilla_Silverback_WW22557.jpg
Title: Gorilla
BigText: And some text.
    ]]></raw>
  </slide>
</presentation>`;

  const METADATA_DIRECTIVES = ["Theme", "ShowSlideCount", "LogoUrl"];
  const CONTENT_DIRECTIVES = ["Hidden", "Background", "FullScreenImage", "Header", 
                              "Title", "BigText", "Text", "SmallText", "TinyText", "Notes",
                              "Image", "Columns", "Table", "FullScreenWebsite", "SpeakerNote"];
  const ALL_DIRECTIVES = [...METADATA_DIRECTIVES, ...CONTENT_DIRECTIVES];
  
/* ═══════════════════════════════════════════════════════════════
                          APPLICATION STATE
     ═══════════════════════════════════════════════════════════════ */

  const state = {
    // Mode flags
    editMode: false,
    wakeLock: null,
    hasChanges: false, // Simple flag to track if there are any unsaved changes.
    currentFilename: null,

    // Presentation data
    xmlDoc: null, // The single source of truth for the entire presentation.

    // Navigation state
    slideEls: [],
    visibleSlideIndices: [],
    currentVisibleSlideIndex: 0,
    currentAbsoluteSlideIndex: 0,

    // Drag state
    draggedThumbIndex: null,
    placeholder: null,
    thumbnailRefreshPromise: null,

    // Available themes
    availableThemes: [],

    // Presenter window
    presenterWindow: null
  };

/* ═══════════════════════════════════════════════════════════════
                          WAKE LOCK
     ═══════════════════════════════════════════════════════════════ */
  
  async function requestWakeLock() {
    if ('wakeLock' in navigator) {
      try {
        state.wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake lock acquired');
        
        state.wakeLock.addEventListener('release', () => {
          console.log('Wake lock released');
        });
      } catch (err) {
        console.log(`Wake lock error: ${err.name}, ${err.message}`);
      }
    }
  }

  async function releaseWakeLock() {
    if (state.wakeLock) {
      await state.wakeLock.release();
      state.wakeLock = null;
    }
  }
  
/* ═══════════════════════════════════════════════════════════════
                          EVENT HANDLERS
     ═══════════════════════════════════════════════════════════════ */

  function setupEventHandlers() {
    // Keyboard navigation
    document.addEventListener("keydown", (e) => {
      if (e.target.closest("textarea, input, select") && e.key !== "Escape") return;

      const navAction = {
        "ArrowRight": 1, " ": 1, "PageDown": 1,
        "ArrowLeft": -1, "PageUp": -1
      }[e.key];

      if (navAction) {
        e.preventDefault();
        const nextIndex = state.editMode ?
          state.currentAbsoluteSlideIndex + navAction :
          state.currentVisibleSlideIndex + navAction;
        if (state.editMode) updateGroundTruth('NAVIGATE', { from: state.currentAbsoluteSlideIndex, to: nextIndex });
        showSlide(nextIndex, !state.editMode);
      } else if (e.key === 'e' || e.key === 'E') {
        e.preventDefault();
        state.editMode = !state.editMode;
        $("editor").classList.toggle("active", state.editMode);
        if (state.editMode) {
          setupEditorUI();
          releaseWakeLock();
        } else {
          // Update ground truth when leaving edit mode
          updateGroundTruth('EXIT_EDIT_MODE');
          buildSlidesFromXMLDoc();
          requestWakeLock();
        }
  showSlide(state.currentAbsoluteSlideIndex, !state.editMode);
      } else if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        toggleFullscreen();
      } else if (e.key === 'p' || e.key === 'P') {
        e.preventDefault();
        openPresenterMode();
      } else if (e.key === "Escape") {
        if ($("help").classList.contains("active")) {
          $("help").classList.remove("active");
        } else if (document.fullscreenElement) {
          document.exitFullscreen();
        } else if (state.editMode) {
          state.editMode = false;
          $("editor").classList.remove("active");
          showSlide(state.currentAbsoluteSlideIndex, true);
        }
      }
    });

    // Editor buttons
    $("save-btn").onclick = () => {
      updateGroundTruth('SAVE');

      if (state.hasChanges) {
        buildSlidesFromXMLDoc(); // Re-render slides to reflect all changes
      }

      state.hasChanges = false;
      updateSaveButtonGlow();
      state.editMode = false;
      $("editor").classList.remove("active");
      showSlide(state.currentAbsoluteSlideIndex, true);

      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.log('Could not enter fullscreen:', err);
        });
      }
    };

    $("add-btn").onclick =  async () => {
      updateGroundTruth('ADD_SLIDE', { 
         index: state.currentAbsoluteSlideIndex + 1, 
         content: "Title: New Slide\n\nText: Edit this content." 
      });

      buildSlidesFromXMLDoc();
      await refreshThumbnails();
      showSlide(state.currentAbsoluteSlideIndex + 1);
    };


    $("del-btn").onclick = async () => {
      if (state.slideEls.length <= 1) {
        alert("Cannot delete the last slide.");
        return;
      }
      if (!confirm("Are you sure you want to delete this slide?")) {
        return;
      }

      updateGroundTruth('DELETE_SLIDE', { index: state.currentAbsoluteSlideIndex });

      buildSlidesFromXMLDoc();
      await refreshThumbnails();
      showSlide(Math.max(0, state.currentAbsoluteSlideIndex - 1));
    };

// Add touch navigation for mobile
$("slideshow").addEventListener('click', (e) => {
  // Don't navigate if in edit mode or clicking on interactive elements
  if (state.editMode) return;
  
  // Check if we clicked on an iframe or inside an iframe wrapper
  if (e.target.closest('iframe') || e.target.closest('[style*="z-index: 100"]')) return;
  
  // Navigate based on which side was clicked
  const clickX = e.clientX;
  const screenWidth = window.innerWidth;
  
  if (clickX < screenWidth / 2) {
    // Left side - go to previous slide
    const prevIndex = state.currentVisibleSlideIndex - 1;
    showSlide(prevIndex, true);
  } else {
    // Right side - go to next slide
    const nextIndex = state.currentVisibleSlideIndex + 1;
    showSlide(nextIndex, true);
  }
});

$("toggle-hide-btn").onclick = () => {
  const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
  if (!slideNode) return;

  const rawNode = slideNode.querySelector('raw');
  if (!rawNode) return;

  const rawText = rawNode.textContent || '';
  const lines = rawText.split('\n');
  let hiddenLineIndex = -1;
  let isCurrentlyHidden = false;

  // Check if Hidden directive exists
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(/^Hidden:\s*(.*)/i);
    if (match) {
      hiddenLineIndex = i;
      isCurrentlyHidden = match[1].trim().toLowerCase() === 'true';
      break;
    }
  }

  // Toggle the hidden state
  let newLines;
  if (isCurrentlyHidden) {
    // Currently hidden, so unhide by removing the line
    if (hiddenLineIndex >= 0) {
      newLines = lines.filter((_, index) => index !== hiddenLineIndex);
    } else {
      newLines = lines;
    }
  } else {
    // Currently visible, so hide by adding/updating the line
    if (hiddenLineIndex >= 0) {
      lines[hiddenLineIndex] = 'Hidden: true';
      newLines = lines;
    } else {
      // Add Hidden: true at the beginning (after any empty lines)
      let insertIndex = 0;
      while (insertIndex < lines.length && lines[insertIndex].trim() === '') {
        insertIndex++;
      }
      lines.splice(insertIndex, 0, 'Hidden: true');
      newLines = lines;
    }
  }

  // Update the raw text in XML - trim to avoid extra newlines
  const newRawText = newLines.join('\n').trim();
  rawNode.textContent = '';
  rawNode.appendChild(state.xmlDoc.createCDATASection(`\n${newRawText}\n`));

  // Update the UI
  state.hasChanges = true;
  state.slideEls[state.currentAbsoluteSlideIndex].classList.toggle("hidden-in-presentation", !isCurrentlyHidden);
  updateVisibleSlideIndices();
  updateToggleHideButtonState();
  updateSingleThumbnail(state.currentAbsoluteSlideIndex);
  updateSaveButtonGlow();

  // Update the textarea if we're editing this slide
  if (state.editMode && $("raw-text-editor")) {
    $("raw-text-editor").value = newRawText;
  }
};

    $("toggle-count-btn").onclick = () => {
      const cb = $("show-count");
      cb.checked = !cb.checked;
      updateGroundTruth('TOGGLE_COUNT');
      updateToggleCountButtonState();
      updateHUD();
    };

    $("download-txt-btn").onclick = async () => {
      updateGroundTruth('DOWNLOAD');                       // flush textarea to XML

      const fileContents = buildRawDeck();
      const suggestedName = `${
        (state.currentFilename ||
         state.xmlDoc.documentElement.getAttribute('title') ||
         'presentation')
         .replace(/\s+/g, '-')
      }.txt`;

      try {
        // Attempt to use the modern File System Access API.
        const handle = await window.showSaveFilePicker({
          suggestedName,
          types: [{ description: 'Modern Slides', accept: { 'text/plain': ['.txt'] } }]
        });
        const w = await handle.createWritable();
        await w.write(new Blob([fileContents], { type: 'text/plain' }));
        await w.close();
      } catch (err) {
        // If the modern API fails (e.g., user cancellation, security block, or not supported),
        // fall back to the traditional anchor tag download method.
        console.warn("Modern save picker failed, falling back to legacy download.", err);
        const blob = new Blob([fileContents], { type: 'text/plain' });
        const a = Object.assign(document.createElement('a'), {
          href: URL.createObjectURL(blob),
          download: suggestedName,
          style: 'display:none'
        });
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
      }
    };



    $("new-presentation-btn").onclick = () => {
      if (state.hasChanges && !confirm("You have unsaved changes that will be lost unless you download the slides. Continue?")) return;
      updateGroundTruth('NEW');
      init();
    };

    $("load-btn").onclick = () => {
      if (state.hasChanges && !confirm("You have unsaved changes that will be lost unless you download the slides. Continue?")) return;
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.slides,.txt,text/xml,text/plain';
      input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        state.currentFilename = file.name.replace(/\.[^/.]+$/, "");
        const reader = new FileReader();
        reader.onload = re => {
          const content = re.target.result;
          let newXML = content.trim().startsWith('<?xml') || content.trim().startsWith('<presentation')
            ? content
            : convertTxtToXML(content, file.name);
          init(newXML); // Re-initialize with loaded file
        };
        reader.readAsText(file);
      };
      input.click();
    };

    $("help-btn").onclick = () => $("help").classList.add("active");
    $("close-help").onclick = () => $("help").classList.remove("active");

    // Text editor - this is the main source of changes.
    $("raw-text-editor").addEventListener('input', () => {
      state.hasChanges = true;
      validateAndUpdateTextarea(); // Live preview update
      updateSaveButtonGlow();
    });

    // Theme and deck properties
    $("theme-selector").onchange = async () => {
      updateGroundTruth('THEME_CHANGE', { theme: $("theme-selector").value });
      await applyTheme($("theme-selector").value);
      if (state.editMode) {
        await refreshThumbnails();
      }
    };

    $("logo-url").oninput = () => {
        updateGroundTruth('LOGO_CHANGE');
        updateHUD(); // Live update for the logo
    };
    
  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.log(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      document.exitFullscreen();
    }
  }

    // Add beforeunload warning for unsaved changes
    window.addEventListener('beforeunload', (e) => {
        if (state.hasChanges) {
            e.preventDefault();
            e.returnValue = ''; // Required for legacy browsers.
        }
    });
  }
  
  /* ═══════════════════════════════════════════════════════════════
                          IMPORT
     ═══════════════════════════════════════════════════════════════ */
  
  function convertTxtToXML(txtContent, filename) {
    let title = filename.replace(/\.(txt|xml)$/i, '') || "Imported Presentation";
    let theme = "minimal";
    let showSlideCount = "true";
    let logoUrl = "";
    
    let contentToProcess = txtContent;
    if (txtContent.trim().startsWith('# METADATA:')) {
      const metadataEndIndex = txtContent.indexOf('\n# Slide(');
      if (metadataEndIndex !== -1) {
        const metadataSection = txtContent.substring(0, metadataEndIndex);
        contentToProcess = txtContent.substring(metadataEndIndex);
        
        const metadataLines = metadataSection.split('\n');
        metadataLines.forEach(line => {
          const match = line.match(/^(\w+):\s*(.*)$/);
          if (match) {
            const [, key, value] = match;
            switch(key) {
              case 'Title': title = value.trim(); break;
              case 'Theme': theme = value.trim(); break;
              case 'ShowSlideCount': showSlideCount = value.trim(); break;
              case 'LogoUrl': logoUrl = value.trim(); break;
            }
          }
        });
      }
    }
    
    const parts = contentToProcess.split(/^# Slide\(\d+\):\s*$/m);
    const slideMatches = parts.filter(part => part.trim() !== '');
    
    let xml = `<presentation title="${escapeHtml(title)}" showSlideCount="${showSlideCount}" theme="${theme}"`;
    if (logoUrl) {
      xml += ` logoUrl="${escapeHtml(logoUrl)}"`;
    }
    xml += `>`;
    
    slideMatches.forEach(slideContent => {
      const cleanContent = slideContent.trim();
      if (cleanContent) {
        xml += `\n  <slide>\n    <raw><![CDATA[\n${cleanContent}\n    ]]></raw>\n  </slide>`;
      }
    });
    
    xml += '\n</presentation>';
    return xml;
  }
  
  async function convertImageToDataURL(url) {
    return new Promise((resolve, reject) => {
      fetch(url)
        .then(response => {
          if (!response.ok) throw new Error(`Network response was not ok for ${url}`);
          return response.blob();
        })
        .then(blob => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        })
        .catch(err => reject(`Failed to fetch blob for ${url}: ${err}`));
    });
  }
 
  /* ==================================================================
                        PRESENTER MODE
  ================================================================= */

  function openPresenterMode() {
    // Open a new window for presenter view
    const presenterWindow = window.open('', 'presenter', 'width=1200,height=800');
    
    if (!presenterWindow) {
      alert('Please allow popups to use presenter mode');
      return;
    }
    
    // Set up presenter view HTML
    presenterWindow.document.write(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Presenter View</title>
        <style>
          body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr auto;
            height: 100vh;
            gap: 20px;
            padding: 20px;
            box-sizing: border-box;
          }
          .slide-container {
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
          }
          .slide-container iframe {
            width: 100%;
            height: 100%;
            border: none;
          }
          .slide-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 10;
          }
          .notes-section {
            grid-column: 1 / -1;
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            max-height: 200px;
            overflow-y: auto;
          }
          .notes-section h3 {
            margin-top: 0;
            color: #ffa500;
          }
          .timer-section {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 4px;
          }
          .timer {
            font-size: 32px;
            font-family: monospace;
            color: #0f0;
          }
          .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
          }
          .controls button {
            padding: 10px 20px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
          }
          .controls button:hover {
            background: #555;
          }
          .slide-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 4px;
          }
        </style>
      </head>
      <body>
        <div class="slide-container">
          <div class="slide-label">Current Slide</div>
          <iframe id="current-slide"></iframe>
        </div>
        <div class="slide-container">
          <div class="slide-label">Next Slide</div>
          <iframe id="next-slide"></iframe>
        </div>
        <div class="notes-section">
          <h3>Speaker Notes</h3>
          <div id="notes-content">No notes for this slide</div>
        </div>
        <div class="timer-section">
          <div>Elapsed Time</div>
          <div class="timer" id="timer">00:00</div>
        </div>
        <!-- <div class="slide-info" id="slide-info">
          Slide 1 of 10
        </div> -->
        <div class="controls">
          <button onclick="window.opener.prevSlide()">Previous</button>
          <button onclick="window.opener.nextSlide()">Next</button>
        </div>
      </body>
      </html>
    `);
    
    // Store reference to presenter window
    state.presenterWindow = presenterWindow;
    
    // Start timer
    let startTime = Date.now();
    setInterval(() => {
      if (presenterWindow.closed) return;
      const elapsed = Date.now() - startTime;
      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      presenterWindow.document.getElementById('timer').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
    
    // Update presenter view when slides change
    updatePresenterView();
  }

  function updatePresenterView() {
    if (!state.presenterWindow || state.presenterWindow.closed) return;
    
    const currentIndex = state.currentAbsoluteSlideIndex;
    const nextIndex = Math.min(currentIndex + 1, state.slideEls.length - 1);
    
    // Get current and next slide HTML
    const currentSlideHTML = state.slideEls[currentIndex].outerHTML;
    const nextSlideHTML = state.slideEls[nextIndex].outerHTML;
    
    // Get theme CSS
    const themeId = document.body.className;
    const themeLink = document.getElementById(`${themeId}-stylesheet`);
    const themeHref = themeLink ? themeLink.href : '';
    
    // Create standalone HTML for iframes
    const slideTemplate = (slideHTML) => `
      <!DOCTYPE html>
      <html>
      <head>
        <link rel="stylesheet" href="${themeHref}">
        <style>
          ${document.getElementById('core-styles').textContent}
          body { margin: 0; overflow: hidden; }
          .slide { 
            display: flex !important; 
            opacity: 1 !important; 
            width: 100vw;
            height: 100vh;
          }
        </style>
      </head>
      <body class="${themeId}">
        <div id="slideshow">${slideHTML}</div>
      </body>
      </html>
    `;
    
    // Update iframes
    state.presenterWindow.document.getElementById('current-slide').srcdoc = slideTemplate(currentSlideHTML);
    state.presenterWindow.document.getElementById('next-slide').srcdoc = slideTemplate(nextSlideHTML);
    
    // Update notes
    const rawText = getRawTextForSlide(currentIndex);
    const { attributes } = parseRawText(rawText);
    const notesElement = state.presenterWindow.document.getElementById('notes-content');
    notesElement.textContent = attributes.speakerNote || 'No notes for this slide';
  }

  // Add these helper functions to expose navigation to presenter window
  window.nextSlide = function() {
    const nextIndex = state.editMode ? 
      state.currentAbsoluteSlideIndex + 1 : 
      state.currentVisibleSlideIndex + 1;
    showSlide(nextIndex, !state.editMode);
  };

  window.prevSlide = function() {
    const prevIndex = state.editMode ? 
      state.currentAbsoluteSlideIndex - 1 : 
      state.currentVisibleSlideIndex - 1;
    showSlide(prevIndex, !state.editMode);
  };  

/* ═══════════════════════════════════════════════════════════════
                          DRAG AND DROP
     ═══════════════════════════════════════════════════════════════ */
  
  function makeThumbnailsDraggable() {
    const thumbsContainer = document.getElementById('thumbs');
    
    // Clean up any existing placeholder completely
    const existingPlaceholders = thumbsContainer.querySelectorAll('.thumb-placeholder');
    existingPlaceholders.forEach(p => p.remove());
    
    // Reset the placeholder reference
    if (state.placeholder) {
      if (state.placeholder.parentNode) {
        state.placeholder.parentNode.removeChild(state.placeholder);
      }
      state.placeholder = null;
    }
    
    // Create new placeholder
    state.placeholder = document.createElement('div');
    state.placeholder.className = 'thumb-placeholder';
    state.placeholder.style.display = 'none';
    
    // Remove any existing event listeners before adding new ones
    const thumbs = thumbsContainer.querySelectorAll('.thumb');
    thumbs.forEach((thumb) => {
      // Clone node to remove all event listeners
      const newThumb = thumb.cloneNode(true);
      thumb.parentNode.replaceChild(newThumb, thumb);
      
      // Add fresh event listeners
      newThumb.draggable = true;
      newThumb.addEventListener('dragstart', handleDragStart);
      newThumb.addEventListener('dragend', handleDragEnd);
      
      // Re-attach click handler
      const index = parseInt(newThumb.dataset.index);
      newThumb.onclick = () => showSlide(index);
    });
    
    // Remove old container event listeners and add fresh ones
    const newContainer = thumbsContainer.cloneNode(false);
    while (thumbsContainer.firstChild) {
      newContainer.appendChild(thumbsContainer.firstChild);
    }
    thumbsContainer.parentNode.replaceChild(newContainer, thumbsContainer);
    
    // Add container event listeners
    newContainer.addEventListener('dragover', handleDragOver);
    newContainer.addEventListener('drop', handleDrop);
  }
  
  function handleDragStart(e) {
    const thumbsContainer = document.getElementById('thumbs');
    state.draggedThumbIndex = Array.from(thumbsContainer.querySelectorAll('.thumb')).indexOf(e.target);
    
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', '');
    
    state.placeholder.style.height = e.target.offsetHeight + 'px';
    state.placeholder.style.width = e.target.offsetWidth + 'px';
  }
  
  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    if (state.draggedThumbIndex === null) return;
    
    const thumbsContainer = e.currentTarget;
    const afterElement = getDragAfterElement(thumbsContainer, e.clientY);
    
    if (state.placeholder.style.display === 'none') {
      state.placeholder.style.display = 'block';
    }
    
    if (afterElement == null) {
      thumbsContainer.appendChild(state.placeholder);
    } else {
      thumbsContainer.insertBefore(state.placeholder, afterElement);
    }
    
    const rect = thumbsContainer.getBoundingClientRect();
    const scrollSpeed = 5;
    const scrollMargin = 50;
    
    if (e.clientY < rect.top + scrollMargin) {
      thumbsContainer.scrollTop -= scrollSpeed;
    } else if (e.clientY > rect.bottom - scrollMargin) {
      thumbsContainer.scrollTop += scrollSpeed;
    }
  }
  
  async function handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (state.draggedThumbIndex === null) return;
    
    const thumbsContainer = document.getElementById('thumbs');
    const allChildren = Array.from(thumbsContainer.children);
    const placeholderIndex = allChildren.indexOf(state.placeholder);
    
    if (placeholderIndex === -1) return;
    
    const thumbsBeforePlaceholder = allChildren.slice(0, placeholderIndex)
      .filter(el => el.classList.contains('thumb')).length;
    
    let newIndex = thumbsBeforePlaceholder;
    
    if (state.draggedThumbIndex < newIndex) {
      newIndex--;
    }
    
    if (state.draggedThumbIndex !== newIndex) {
      await reorderSlides(state.draggedThumbIndex, newIndex);
    }
    
    cleanupDrag();
  }
  
  function handleDragEnd(e) {
    e.target.classList.remove('dragging');
    cleanupDrag();
  }
  
  function cleanupDrag() {
    // Remove placeholder from DOM completely
    if (state.placeholder && state.placeholder.parentNode) {
      state.placeholder.parentNode.removeChild(state.placeholder);
    }
    
    // Hide it just in case
    if (state.placeholder) {
      state.placeholder.style.display = 'none';
    }
    
    // Reset drag state
    state.draggedThumbIndex = null;
    
    // Remove dragging class from any thumb that might still have it
    document.querySelectorAll('.thumb.dragging').forEach(thumb => {
      thumb.classList.remove('dragging');
    });
  }
  
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.thumb:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
  
async function reorderSlides(fromIndex, toIndex) {
  if (fromIndex === toIndex) return;
  
  updateGroundTruth('REORDER', { fromIndex, toIndex });
  
  buildSlidesFromXMLDoc();
  await refreshThumbnails();
  let newCurrentIndex = toIndex;
  showSlide(newCurrentIndex);
}


/* ═══════════════════════════════════════════════════════════════
                          EDITOR FUNCTIONS
     ═══════════════════════════════════════════════════════════════ */

  function setupEditorUI() {
    const p = state.xmlDoc.querySelector("presentation");
    if (!p) return;

    $("show-count").checked = p.getAttribute("showSlideCount") !== "false";
    $("logo-url").value = p.getAttribute("logoUrl") || "";
    $("theme-selector").value = p.getAttribute("theme") || "minimal";

    refreshThumbnails();
    loadTextareaForCurrentSlide();
    updateSaveButtonGlow();
  }

  async function refreshThumbnails() {
    // 1) Bail out if already running to prevent concurrent updates
    if (state.thumbnailRefreshPromise) {
      return state.thumbnailRefreshPromise;
    }

    // 2) The core logic is wrapped in a new Promise that we control
    const promise = new Promise(async (resolve) => {
      const thumbsContainer = $("thumbs");

      // Clear old thumbnails. This is what causes the scroll jump.
      thumbsContainer.innerHTML = ''; 
      
      const slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");
      const theme = $("theme-selector").value || "minimal";

      // 3) Rebuild the DOM elements
      for (let i = 0; i < slideNodes.length; i++) {
        const rawText = slideNodes[i].querySelector('raw')?.textContent || '';

        const thumbDiv = document.createElement("div");
        thumbDiv.className = "thumb" + (i === state.currentAbsoluteSlideIndex ? " selected" : "");
        if (slideNodes[i].getAttribute("hidden") === "true") {
          thumbDiv.classList.add("hidden-slide");
        }
        thumbDiv.dataset.index = i;

        const num = document.createElement('div');
        num.className = 'thumb-number';
        num.textContent = i + 1;

        const iframe = document.createElement('iframe');
        iframe.className = 'thumb-iframe';
        iframe.scrolling = "no";
        iframe.loading = "lazy";
        // This await is fine, it just populates the content
        iframe.srcdoc = await getThumbnailHTML(rawText, theme);

        thumbDiv.append(num, iframe);
        thumbsContainer.appendChild(thumbDiv);
        thumbDiv.onclick = () => showSlide(i);
      }

      makeThumbnailsDraggable();

      // 4) 
      // Wait for the browser's next painting cycle. This gives the browser
      // time to render the new thumbnails and calculate the new scroll height.
      requestAnimationFrame(() => {
        // Now that the DOM is stable, find the selected thumb
        const selectedThumb = thumbsContainer.querySelector('.thumb.selected');
        if (selectedThumb) {
          // Execute the scroll. This visually corrects the jump.
          selectedThumb.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        }
        // 5) Only after the scroll has been commanded, resolve the promise.
        resolve(); 
      });
    });

    state.thumbnailRefreshPromise = promise;
    
    // Wait for the process to finish and then clear the lock
    try {
      await promise;
    } finally {
      state.thumbnailRefreshPromise = null;
    }
  }

function highlightThumb(index) {
  const thumbs = document.querySelectorAll("#thumbs .thumb");
  thumbs.forEach((t, i) =>
    t.classList.toggle("selected", i === index)
  );
  const selected = document.querySelector("#thumbs .thumb.selected");
  if (selected) selected.scrollIntoView({ block: 'nearest', inline: 'nearest' });
}

function buildRawDeck() {
  const p = state.xmlDoc.documentElement;
  let txt = `# METADATA:
Title: ${p.getAttribute('title')            || ''}
Theme: ${p.getAttribute('theme')            || 'minimal'}
ShowSlideCount: ${p.getAttribute('showSlideCount') || 'true'}
LogoUrl: ${p.getAttribute('logoUrl')        || ''}`;

  Array.from(p.querySelectorAll('slide')).forEach((s, i) => {
    txt += `

# Slide(${i + 1}):

${(s.querySelector('raw')?.textContent || '').trim()}`;
  });

  return txt.trim();
}

  function getRawTextForSlide(index) {
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
    return slideNode?.querySelector("raw")?.textContent.trim() || "";
  }

  function loadTextareaForCurrentSlide() {
    // Always load directly from the single source of truth: the xmlDoc.
    $("raw-text-editor").value = getRawTextForSlide(state.currentAbsoluteSlideIndex);
    validateAndUpdateTextarea();
  }

  async function validateAndUpdateTextarea() {
    // This function provides a live preview in the thumbnail without saving to XML.
    const thumbIframe = document.querySelector(
      `#thumbs .thumb[data-index="${state.currentAbsoluteSlideIndex}"] iframe`
    );
    if (thumbIframe) {
      const theme = $("theme-selector").value || 'minimal';
      thumbIframe.srcdoc = await getThumbnailHTML($("raw-text-editor").value, theme);
    }
  }

  function updateSaveButtonGlow() {
      // The glow is now controlled entirely by the simple hasChanges flag.
      $("save-btn").classList.toggle("glow", state.hasChanges);
  }

  function updateToggleHideButtonState() {
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
    const btn = $("toggle-hide-btn");
    const isHidden = slideNode?.getAttribute("hidden") === "true";
    btn.innerHTML = isHidden
      ? '<i class="fa-solid fa-eye"></i>'
      : '<i class="fa-solid fa-eye-slash"></i>';
    btn.title = isHidden ? "Show Slide" : "Hide Slide";
    $("toggle-hide-btn").disabled = !slideNode;
  }

  function updateToggleCountButtonState() {
    const btn = $("toggle-count-btn");
    const isOn = $("show-count").checked;
    btn.innerHTML = isOn
      ? '<i class="fa-solid fa-sort-numeric-asc"></i>'
      : '<i class="fa-solid fa-sort-numeric-asc" style="opacity:0.3;"></i>';
    btn.title = isOn ? "Hide Slide Numbers" : "Show Slide Numbers";
  }
 
/* ═══════════════════════════════════════════════════════════════
                    CENTRALIZED STATE UPDATE
   ═══════════════════════════════════════════════════════════════ */

function updateGroundTruth(action, data = {}) {
  console.log(`[updateGroundTruth] Action: ${action}`, data);

  // 0. Save first
  if (action === 'DOWNLOAD' || action === 'SAVE' || action === 'EXIT_EDIT_MODE') {
    // Force save current slide text regardless of mode
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
    if (slideNode && $("raw-text-editor")) {
      const rawNode = slideNode.querySelector('raw');
      const newText = $("raw-text-editor").value;
    
      if (rawNode) {
        rawNode.textContent = '';
        rawNode.appendChild(
          state.xmlDoc.createCDATASection(`\n${newText}\n`)
        );
        console.log(`[updateGroundTruth] Saved current slide text for ${action}`);
      }
    }
    console.log(`Current slides `, state.xmlDoc);
  }
  
  // 1. Create DOM if needed (for new/load/init actions)
  if (action === 'INIT' || action === 'LOAD' || action === 'NEW') {
    const xmlString = data.xmlString || DEFAULT_XML;
    const parser = new DOMParser();
    const tempDoc = parser.parseFromString(xmlString, "text/xml");
    
    if (tempDoc.getElementsByTagName("parsererror").length > 0) {
      alert("Error parsing presentation XML. Loading default.");
      state.xmlDoc = parser.parseFromString(DEFAULT_XML, "text/xml");
    } else {
      state.xmlDoc = tempDoc;
    }
    
    // Reset other state
    state.hasChanges = false;
    state.currentAbsoluteSlideIndex = data.slideIndex || 0;
    console.log(`[updateGroundTruth] Created new XML DOM from ${action}`);
  }
  
  // 2. Update current slide text (for most actions except init)
  if (action !== 'INIT' && action !== 'LOAD' && action !== 'NEW' && state.editMode) {
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[state.currentAbsoluteSlideIndex];
    if (slideNode) {
      const rawNode = slideNode.querySelector('raw');
      const newText = $("raw-text-editor").value;
      
      if (rawNode && newText.trim() !== (rawNode.textContent || '').trim()) {
        rawNode.textContent = '';
        rawNode.appendChild(state.xmlDoc.createCDATASection(`\n${newText}\n`));
        state.hasChanges = true;
        console.log(`[updateGroundTruth] Updated slide ${state.currentAbsoluteSlideIndex} text`);
      }
    }
  }
  
  // 3. Handle reordering (add, delete, rearrange)
  if (action === 'REORDER') {
    const { fromIndex, toIndex } = data;

    // keep a handle on whichever slide is *currently* selected
    const curSlideNode =
      state.xmlDoc.querySelectorAll('presentation > slide')[state.currentAbsoluteSlideIndex];

    const pres   = state.xmlDoc.querySelector('presentation');
    const slides = Array.from(pres.querySelectorAll('slide'));
    const moved  = slides[fromIndex];

    // physically move the node
    pres.insertBefore(
      moved,
      (fromIndex < toIndex) ? slides[toIndex].nextSibling : slides[toIndex]
    );

    // recompute where the current slide ended up
    const newOrder = Array.from(pres.querySelectorAll('slide'));
    state.currentAbsoluteSlideIndex = newOrder.indexOf(curSlideNode);

    state.hasChanges = true;
    console.log(
      `[updateGroundTruth] Reordered slide ${fromIndex} → ${toIndex}. ` +
      `Current slide is now ${state.currentAbsoluteSlideIndex}`
    );
  }

  if (action === 'ADD_SLIDE') {
    const { index, content } = data;
    const newSlideNode = state.xmlDoc.createElement('slide');
    const rawNode = state.xmlDoc.createElement('raw');
    rawNode.appendChild(state.xmlDoc.createCDATASection(`\n${content}\n`));
    newSlideNode.appendChild(rawNode);
    
    const slides = state.xmlDoc.querySelectorAll("presentation > slide");
    state.xmlDoc.querySelector("presentation").insertBefore(
      newSlideNode, 
      slides[index] || null
    );
    
    state.hasChanges = true;
    console.log(`[updateGroundTruth] Added slide at index ${index}`);
  }
  
  if (action === 'DELETE_SLIDE') {
    const { index } = data;
    state.xmlDoc.querySelectorAll("presentation > slide")[index].remove();
    state.hasChanges = true;
    console.log(`[updateGroundTruth] Deleted slide at index ${index}`);
  }
  
  // 4. Update theme
  if (action === 'THEME_CHANGE' || action === 'LOGO_CHANGE' || action === 'TOGGLE_COUNT') {
    const presNode = state.xmlDoc.querySelector("presentation");
    
    if (action === 'THEME_CHANGE') {
      presNode.setAttribute("theme", data.theme);
      console.log(`[updateGroundTruth] Updated theme to ${data.theme}`);
    }
    
    if (action === 'LOGO_CHANGE') {
      const logoUrl = $("logo-url").value.trim();
      if (logoUrl) {
        presNode.setAttribute("logoUrl", logoUrl);
      } else {
        presNode.removeAttribute("logoUrl");
      }
      console.log(`[updateGroundTruth] Updated logo to ${logoUrl}`);
    }
    
    if (action === 'TOGGLE_COUNT') {
      presNode.setAttribute("showSlideCount", $("show-count").checked ? "true" : "false");
      console.log(`[updateGroundTruth] Updated showSlideCount to ${$("show-count").checked}`);
    }
    
    state.hasChanges = true;
  }
  
  // 5. Handle hide/show
  if (action === 'TOGGLE_HIDE') {
    const { index, hidden } = data;
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
    if (slideNode) {
      if (hidden) {
        slideNode.setAttribute("hidden", "true");
      } else {
        slideNode.removeAttribute("hidden");
      }
      state.hasChanges = true;
      console.log(`[updateGroundTruth] Set slide ${index} hidden=${hidden}`);
    }
  }
  
  // Log current state
  console.log(`[updateGroundTruth] Current state:`, {
    slides: state.xmlDoc.querySelectorAll("presentation > slide").length,
    currentSlide: state.currentAbsoluteSlideIndex,
    hasChanges: state.hasChanges,
    theme: state.xmlDoc.documentElement.getAttribute("theme"),
    logoUrl: state.xmlDoc.documentElement.getAttribute("logoUrl")
  });
  
  updateSaveButtonGlow();
}

  /* ═══════════════════════════════════════════════════════════════
                          NAVIGATION & DISPLAY
     ═══════════════════════════════════════════════════════════════ */
  
  function showSlide(absIndex, fromPresentationNav = false) {
    let targetAbsIndex = absIndex;

    if (state.editMode && state.currentAbsoluteSlideIndex !== absIndex && 
        state.currentAbsoluteSlideIndex >= 0 && state.currentAbsoluteSlideIndex < state.slideEls.length) {
      updateGroundTruth('NAVIGATE', { from: state.currentAbsoluteSlideIndex, to: absIndex });
    }
    
    if (fromPresentationNav && !state.editMode) {
      let targetVisibleIndex = Math.max(0, Math.min(absIndex, state.visibleSlideIndices.length - 1));
      targetAbsIndex = state.visibleSlideIndices.length > 0 ? 
        state.visibleSlideIndices[targetVisibleIndex] : 0;
      state.currentVisibleSlideIndex = targetVisibleIndex;
    } else {
      targetAbsIndex = Math.max(0, Math.min(absIndex, state.slideEls.length - 1));
    }
    
    state.slideEls.forEach((s, i) => s.classList.toggle("active", i === targetAbsIndex));
    state.currentAbsoluteSlideIndex = targetAbsIndex;
    
    if (!fromPresentationNav || state.editMode) {
      state.currentVisibleSlideIndex = state.visibleSlideIndices.indexOf(state.currentAbsoluteSlideIndex);
    }
 
    // This block forces GIFs to restart when a slide becomes active.
    const activeSlide = state.slideEls[targetAbsIndex];
    if (activeSlide) {
      // 1. For GIFs in <img> tags
      const imgGifs = activeSlide.querySelectorAll('img[src*=".gif"]');
      imgGifs.forEach(gif => {
        const originalSrc = gif.src;
        // This trick forces the browser to reload the image and restart the animation
        gif.src = '';
        gif.src = originalSrc;
      });

      // 2. For GIFs used as a background-image
      if (activeSlide.style.backgroundImage.includes('.gif')) {
        const originalBg = activeSlide.style.backgroundImage;
        // Temporarily remove the background, then add it back in the next frame
        activeSlide.style.backgroundImage = 'none';
        requestAnimationFrame(() => {
          activeSlide.style.backgroundImage = originalBg;
        });
      }
    }
    
    updateHUD();
    updatePresenterView();
    
    if (state.editMode) {
      highlightThumb(state.currentAbsoluteSlideIndex);
      loadTextareaForCurrentSlide();
      updateToggleHideButtonState();
    }
  }
  
  function updateHUD() {
    const presNode = state.xmlDoc.querySelector("presentation");
    if (!presNode) return;
    
    const showCount = presNode.getAttribute("showSlideCount") !== "false";
    $("slide-counter").style.display = showCount ? "block" : "none";
    $("progress-bar").style.display = showCount ? "block" : "none";
    
    const logoUrl = presNode.getAttribute("logoUrl");
    const logoEl = $("company-logo");
    logoEl.src = logoUrl || '';
    logoEl.style.display = logoUrl ? "block" : "none";
    
    const numVisibleSlides = state.visibleSlideIndices.length;
    const displayCur = numVisibleSlides > 0 ? state.currentVisibleSlideIndex + 1 : 0;
    const displayTot = numVisibleSlides;
    
    $("cur").textContent = state.editMode ? 
      state.currentAbsoluteSlideIndex + 1 : displayCur;
    $("tot").textContent = state.editMode ? 
      state.slideEls.length : displayTot;
    
    let progressPercent = 0;
    if (state.editMode && state.slideEls.length > 0) {
      progressPercent = ((state.currentAbsoluteSlideIndex + 1) / state.slideEls.length) * 100;
    } else if (!state.editMode && numVisibleSlides > 0) {
      progressPercent = ((state.currentVisibleSlideIndex + 1) / numVisibleSlides) * 100;
    }
    $("progress-bar").style.width = `${progressPercent}%`;
  }  

  function buildSlidesFromXMLDoc() {
    state.slideEls = [];
    $("slideshow").innerHTML = "";
    let slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");

    if (slideNodes.length === 0) {
      addSlide(0, "Title: Empty Slide\n\nText: Add content or load a presentation.");
      slideNodes = state.xmlDoc.querySelectorAll("presentation > slide");
    }

    slideNodes.forEach((slideNode) => {
      const rawText = slideNode.querySelector('raw')?.textContent || '';
      const { attributes } = parseRawText(rawText);
      slideNode.setAttribute('title', attributes.title || 'Untitled');
      attributes.hidden ? 
        slideNode.setAttribute('hidden', 'true') : 
        slideNode.removeAttribute('hidden');

      const slideDiv = createSlideElement(rawText);
      $("slideshow").appendChild(slideDiv);
      state.slideEls.push(slideDiv);
    });

    updateVisibleSlideIndices();
    if (window.MathJax?.typesetPromise) {
      MathJax.typesetPromise([$("slideshow")]);
    }
  }
  
  function updateVisibleSlideIndices() {
    state.visibleSlideIndices = [];
    state.xmlDoc.querySelectorAll("presentation > slide").forEach((node, index) => {
      if (node.getAttribute("hidden") !== "true") {
        state.visibleSlideIndices.push(index);
      }
    });
  }
  
  /* ═══════════════════════════════════════════════════════════════
                          SLIDE MANIPULATION
     ═══════════════════════════════════════════════════════════════ */
  
  function addSlide(index, rawContent) {
    const newSlideNode = state.xmlDoc.createElement('slide');
    const rawNode = state.xmlDoc.createElement('raw');
    rawNode.appendChild(state.xmlDoc.createCDATASection(`\n${rawContent}\n`));
    newSlideNode.appendChild(rawNode);
    
    const slides = state.xmlDoc.querySelectorAll("presentation > slide");
    state.xmlDoc.querySelector("presentation").insertBefore(
      newSlideNode, 
      slides[index] || null
    );
  }
  
  function updateSingleSlide(index) {
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
    if (!slideNode) return;
    
    const rawText = slideNode.querySelector('raw')?.textContent || '';
    const newSlideElement = createSlideElement(rawText);
    
    if (state.slideEls[index]) {
      state.slideEls[index].replaceWith(newSlideElement);
      state.slideEls[index] = newSlideElement;
      
      if (index === state.currentAbsoluteSlideIndex) {
        newSlideElement.classList.add('active');
      }
      
      if (window.MathJax?.typesetPromise) {
        MathJax.typesetPromise([newSlideElement]);
      }
    }
  }
  
async function updateSingleThumbnail(index) {
  const thumb = document.querySelector(`#thumbs .thumb[data-index="${index}"]`);
  if (!thumb) return;
  
  const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
  const rawText = slideNode?.querySelector('raw')?.textContent || '';
  const theme = $("theme-selector").value || "minimal";
  
  const iframe = thumb.querySelector('iframe');
  if (iframe) {
    iframe.srcdoc = await getThumbnailHTML(rawText, theme);
  }
  
  // Parse the raw text to check if it's hidden
  const { attributes } = parseRawText(rawText);
  if (attributes.hidden) {
    thumb.classList.add("hidden-slide");
  } else {
    thumb.classList.remove("hidden-slide");
  }
}
  async function updateSingleThumbnail(index) {
    const thumb = document.querySelector(`#thumbs .thumb[data-index="${index}"]`);
    if (!thumb) return;
    
    const slideNode = state.xmlDoc.querySelectorAll("presentation > slide")[index];
    const rawText = slideNode?.querySelector('raw')?.textContent || '';
    const theme = $("theme-selector").value || "minimal";
    
    const iframe = thumb.querySelector('iframe');
    if (iframe) {
      iframe.srcdoc = await getThumbnailHTML(rawText, theme);
    }
    
    // Parse the raw text to check if it's hidden
    const { attributes } = parseRawText(rawText);
    if (attributes.hidden) {
      thumb.classList.add("hidden-slide");
    } else {
      thumb.classList.remove("hidden-slide");
    }
  }  

 async function getThumbnailHTML(rawText, theme) {
  const slideElement = createSlideElement(rawText);
  
  // Remove the hidden-in-presentation class for thumbnails
  // We want to see the content in thumbnails even if hidden
  slideElement.classList.remove('hidden-in-presentation');
  
  const slideElementHTML = slideElement.outerHTML;
  
  // Get the theme CSS content WITHOUT fetch
  let themeCSS = '';
  const themeLink = document.getElementById(`${theme}-stylesheet`);
  if (themeLink && themeLink.sheet) {
    try {
      // Read from the already-loaded stylesheet
      const cssRules = themeLink.sheet.cssRules || themeLink.sheet.rules;
      for (let i = 0; i < cssRules.length; i++) {
        themeCSS += cssRules[i].cssText + '\n';
      }
    } catch (err) {
      // Fallback: include the link tag instead
      themeCSS = `<link rel="stylesheet" href="${themeLink.href}">`;
      return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <base href="${window.location.href}">
    ${themeCSS}
    <style>
      ${document.getElementById('core-styles').textContent}
      body { margin: 0; overflow: hidden; }
      .slide { display: flex !important; opacity: 1 !important; transform: none !important; }
      .hidden-in-presentation { display: flex !important; opacity: 1 !important; }
    </style>
</head>
<body class="${theme}">
    ${slideElementHTML}
</body>
</html>`;
    }
  }
  
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <base href="${window.location.href}">
    <style>
      ${document.getElementById('core-styles').textContent}
      ${themeCSS}
      body { margin: 0; overflow: hidden; }
      .slide { display: flex !important; opacity: 1 !important; transform: none !important; }
      .hidden-in-presentation { display: flex !important; opacity: 1 !important; }
    </style>
</head>
<body class="${theme}">
    ${slideElementHTML}
</body>
</html>`;
}
  
  /* ═══════════════════════════════════════════════════════════════
                          XML HANDLING
     ═══════════════════════════════════════════════════════════════ */
  
  function initializePresentation(xmlString) {
    const parser = new DOMParser();
    const tempDoc = parser.parseFromString(xmlString, "text/xml");
    
    if (tempDoc.getElementsByTagName("parsererror").length > 0) {
      alert("Error parsing presentation XML. Loading default.");
      state.xmlDoc = parser.parseFromString(DEFAULT_XML, "text/xml");
    } else {
      state.xmlDoc = tempDoc;
    }
    
    const theme = state.xmlDoc.documentElement.getAttribute("theme") || "minimal";
    $("theme-selector").value = theme;
    applyTheme(theme);
  }  
  function createSlideElement(rawText) {
    const { attributes, innerHTML } = parseRawText(rawText);
    const slideDiv = document.createElement("div");
    slideDiv.className = "slide";
    
    if (attributes.hidden) slideDiv.classList.add("hidden-in-presentation");
    
    if (attributes.background) {
      const resolvedUrl = window.presentationBaseUrl ? 
        resolveImagePath(attributes.background, window.presentationBaseUrl) : 
        attributes.background;
      slideDiv.style.backgroundImage = `url("${escapeHtml(resolvedUrl)}")`;
      if (attributes.isFullScreenImage) slideDiv.classList.add("is-fullscreen-image-slide");
    }
    
    if (attributes.header) {
      const headerDiv = document.createElement("div");
      headerDiv.className = "slide-header";
      headerDiv.innerHTML = plainTextToHtml(attributes.header);
      slideDiv.appendChild(headerDiv);
    }

    // Add iframe for FullScreenWebsite
    if (attributes.fullscreenWebsite) {
      const iframeWrapper = document.createElement("div");
      iframeWrapper.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        height: 90%;
        background: white;
        box-shadow: 0 0 50px rgba(0,0,0,0.3);
        border-radius: 8px;
        overflow: hidden;
        z-index: 100;
      `;
      
      const iframe = document.createElement("iframe");
      iframe.src = attributes.fullscreenWebsite;
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 8px;
      `;
      
      iframeWrapper.appendChild(iframe);
      slideDiv.appendChild(iframeWrapper);
      
      // Add click handler to the slide itself for navigation
      slideDiv.addEventListener('click', (e) => {
        // Get the iframe wrapper bounds
        const wrapperBounds = iframeWrapper.getBoundingClientRect();
        const clickX = e.clientX;
        const clickY = e.clientY;
        
        // Check if click is outside the iframe
        if (clickX < wrapperBounds.left || 
            clickX > wrapperBounds.right || 
            clickY < wrapperBounds.top || 
            clickY > wrapperBounds.bottom) {
          
          // Navigate based on which side was clicked
          if (clickX < window.innerWidth / 2) {
            window.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowLeft' }));
          } else {
            window.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowRight' }));
          }
        }
      });
    }
    
    const contentDiv = document.createElement("div");
    contentDiv.className = "slide-content";

    // Create the dedicated wrapper for normal flow content
    const flowContentDiv = document.createElement("div");
    flowContentDiv.className = "slide-flow-content";
    flowContentDiv.innerHTML = innerHTML;
    contentDiv.appendChild(flowContentDiv);
    
    // Check for notes and append them OUTSIDE the flow wrapper
    if (attributes.notes) {
      const notesDiv = document.createElement("div");
      notesDiv.className = "notes";
      notesDiv.innerHTML = plainTextToHtml(attributes.notes);
      contentDiv.appendChild(notesDiv); // Appended as a sibling to flowContentDiv
    }

    slideDiv.appendChild(contentDiv);

    return slideDiv;
  }  
  /* ═══════════════════════════════════════════════════════════════
                      TEXT PARSING & HTML GENERATION
     ═══════════════════════════════════════════════════════════════ */
  
  function plainTextToHtml(text) {
    if (!text || !text.trim()) return "";
    let safeText = escapeHtml(text.trim());
    
    // Process markdown-style formatting
    safeText = safeText.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
    safeText = safeText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    safeText = safeText.replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    return safeText
      .replace(/\r\n/g, '\n')
      .split(/\n{2,}/)
      .map(p => `<p>${p.replace(/\n/g, '<br />')}</p>`)
      .join('\n');
  }
  
  function parseRawText(rawText) {
    const attributes = {};
    let innerHTML = '';
    const lines = (rawText || '').split('\n');
    let currentDirective = "Text";
    let buffer = [];

    function processBuffer() {
      if (buffer.length === 0) return;
      const content = buffer.join('\n').trim();
      if (!content) return;

      // Handle metadata directives
      if (METADATA_DIRECTIVES.includes(currentDirective)) {
        attributes[currentDirective.toLowerCase()] = content;
        buffer = [];
        return;
      }

      // Handle content directives
      switch (currentDirective) {
        case "Hidden": 
          if (content.toLowerCase() === 'true') attributes.hidden = true; 
          break;
          
        case "Background":
        case "FullScreenImage":
          attributes.background = content;
          if (currentDirective === "FullScreenImage") attributes.isFullScreenImage = true;
          break;

        case "FullScreenWebsite":
          attributes.fullscreenWebsite = content.trim();
          break;
          
        case "Header": 
          attributes.header = content; 
          break;
          
        case "Title":
          attributes.title = content.split('\n')[0].trim();
          innerHTML += `<h1>${escapeHtml(content).replace(/\n/g, '<br />')}</h1>`;
          break;
          
        case "BigText": 
          innerHTML += `<div class="large">${plainTextToHtml(content)}</div>`; 
          break;
          
        case "Text": 
          innerHTML += plainTextToHtml(content); 
          break;

        case "SmallText":
          innerHTML += `<div class="small">${plainTextToHtml(content)}</div>`;
          break;
        
        case "TinyText":
          innerHTML += `<div class="tiny">${plainTextToHtml(content)}</div>`;
          break;
        
        case "Notes":
          attributes.notes = content;
          break;
 
        case "SpeakerNote":
          attributes.speakerNote = content;
          break;
          
        case "Image": {
          const [url, ...captionParts] = content.split(/,(.*)/s);
          const caption = (captionParts[0] || '').trim();
          const resolvedUrl = window.presentationBaseUrl ? 
            resolveImagePath(url.trim(), window.presentationBaseUrl) : url.trim();
          innerHTML += `<div class="img-container"><img src="${escapeHtml(resolvedUrl)}" alt="${escapeHtml(caption)}"><div class="caption">${plainTextToHtml(caption)}</div></div>`;
          break;
        }
          
        case "Columns": {
          const parts = content.split(/^\s*---\s*$/m);
          const colsHtml = parts.map(part => {
            const trimmedPart = part.trim();
            const [firstPart, ...restParts] = trimmedPart.split(/,(.*)/s);
            if (/\.(png|jpe?g|gif|webp|svg)$/i.test(firstPart.trim()) || 
                firstPart.trim().startsWith('data:')) {
              const colCaption = (restParts[0] || '').trim();
              const imageUrl = firstPart.trim();
              const resolvedUrl = window.presentationBaseUrl ? 
                resolveImagePath(imageUrl, window.presentationBaseUrl) : imageUrl;
              return `<div class="column"><div class="img-container"><img src="${escapeHtml(resolvedUrl)}" alt="${escapeHtml(colCaption)}"><div class="caption">${plainTextToHtml(colCaption)}</div></div></div>`;
            }
            return `<div class="column">${plainTextToHtml(trimmedPart)}</div>`;
          }).join('');
          innerHTML += `<div class="columns">${colsHtml}</div>`;
          break;
        }
          
        case "Table": {
          let tableHtml = '<table>';
          const rows = content.split(/^\s*---\s*$/m);
          if (rows.length > 0) {
            const headerCells = rows.shift().split('&')
              .map(c => `<th>${plainTextToHtml(c.trim())}</th>`).join('');
            tableHtml += `<thead><tr>${headerCells}</tr></thead>`;
          }
          const bodyRows = rows.map(row => {
            const cells = row.split('&')
              .map(c => `<td>${plainTextToHtml(c.trim())}</td>`).join('');
            return `<tr>${cells}</tr>`;
          }).join('');
          tableHtml += `<tbody>${bodyRows}</tbody></table>`;
          innerHTML += tableHtml;
          break;
        }
      }
      buffer = [];
    }

    // Process lines
    for (const line of lines) {
      const match = line.match(/^([A-Za-z]+):\s*(.*)/);
      if (match && ALL_DIRECTIVES.includes(match[1])) {
        processBuffer();
        currentDirective = match[1];
        buffer.push(match[2]);
      } else {
        buffer.push(line);
      }
    }
    processBuffer();
    
    return { attributes, innerHTML };
  }  
  /* ═══════════════════════════════════════════════════════════════
                          UTILITY FUNCTIONS
     ═══════════════════════════════════════════════════════════════ */
  
  const $ = (id) => document.getElementById(id);
  
  const escapeHtml = (s) =>
    s.replace(/[&<>"']/g, c =>
      ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c])
    );
  
  /* ═══════════════════════════════════════════════════════════════
                        THEME DISCOVERY & LOADING
     ═══════════════════════════════════════════════════════════════ */
  
  async function discoverThemes() {
    // For local file system, we can't discover files dynamically
    // So we'll check for known theme patterns
    const knownThemes = [
      'minimal.css',
      'calgary.css',
      'swiss-modern.css',
      'david-carson.css',
      'tufte-base.css',
      'gradient.css', 
      'modern-dark.css'
    ];
    
    state.availableThemes = [];
    
    for (const filename of knownThemes) {
      try {
        // Try to create a link element to test if the file exists
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = filename;
        link.id = filename.replace('.css', '-stylesheet');
        link.disabled = true;
        document.head.appendChild(link);
        
        // Extract theme name from filename
        const themeName = filename.replace('.css', '');
        const displayName = themeName
          .replace('theme-', '')
          .replace(/-/g, ' ')
          .split(' ')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
        
        state.availableThemes.push({
          filename: filename,
          id: themeName,
          name: displayName
        });
      } catch (e) {
        console.warn(`Theme ${filename} not found`);
      }
    }
    
    // Populate theme selector
    const themeSelector = $('theme-selector');
    themeSelector.innerHTML = '';
    state.availableThemes.forEach(theme => {
      const option = document.createElement('option');
      option.value = theme.id;
      option.textContent = theme.name;
      themeSelector.appendChild(option);
    });
  }
  
  async function applyTheme(themeId) {
    // Disable all theme stylesheets
    document.querySelectorAll('link[id$="-stylesheet"]').forEach(link => {
      link.disabled = true;
    });
    
    // Enable the selected theme
    const themeLink = document.getElementById(`${themeId}-stylesheet`);
    if (themeLink) {
      themeLink.disabled = false;
    }
    
    // Update body class
    document.body.className = themeId;
    
    // Refresh thumbnails
    await new Promise(resolve => setTimeout(resolve, 50));
    await refreshThumbnails();
    document.querySelectorAll('#thumbs .thumb-iframe').forEach(f => { f.srcdoc = f.srcdoc; });
  }

  /* ═══════════════════════════════════════════════════════════════
                          URL PARAMETER HANDLING
     ═══════════════════════════════════════════════════════════════ */
  
  function handleURLParameters() {
    const urlParams = new URLSearchParams(window.location.search);
    const inputUrl = urlParams.get('xml');
    if (!inputUrl) return init();

    let textFileUrl;
    let baseFolderUrl;

    if (inputUrl.match(/dropbox\.com\/sh\//)) {
      const clean = inputUrl.split('?')[0];
      baseFolderUrl = clean.replace('www.dropbox.com', 'dl.dropboxusercontent.com');
      textFileUrl = `${baseFolderUrl}/Slides.txt?dl=1`;
    } else if (inputUrl.match(/drive\.google\.com\/drive\/folders\//)) {
      alert('Google Drive folders aren\'t directly fetchable. Please link to your Slides.txt file, not to the folder.');
      return init();
    } else {
      const absoluteInputUrl = new URL(inputUrl, window.location.href).href;
      textFileUrl = absoluteInputUrl;
      baseFolderUrl = absoluteInputUrl.substring(0, absoluteInputUrl.lastIndexOf('/') + 1);
    }

    const absoluteXmlUrl = new URL(textFileUrl, window.location.href).href;
    const fetchUrl = 'proxy.php?url=' + encodeURIComponent(absoluteXmlUrl);

    window.presentationBaseUrl = baseFolderUrl;

    fetch(fetchUrl)
      .then(res => {
        if (!res.ok) throw new Error(`Load failed: ${res.status}`);
        return res.text();
      })
      .then(txt => {
        const newXml = convertTxtToXML(txt, textFileUrl.split('/').pop());
        sessionStorage.setItem(`Slides_${state.currentPresentationName}`, newXml);
        init(newXml);
      })
      .catch(err => {
        console.error(err);
        alert('Failed to load presentation.');
        init();
      });
  }
  
  window.resolveImagePath = function(imageSrc, baseUrl) {
    if (!baseUrl || imageSrc.startsWith('http://') || 
        imageSrc.startsWith('https://') || imageSrc.startsWith('data:')) {
      return imageSrc;
    }
    return new URL(imageSrc, baseUrl).href;
  };
  
  /* ═══════════════════════════════════════════════════════════════
                          16:9 ASPECT RATIO SETUP
     ═══════════════════════════════════════════════════════════════ */
  
  function wrapSlideshowFor16x9() {
    const slideshow = $("slideshow");
    if (!slideshow.parentElement.classList.contains('presentation-scaler')) {
      const viewport = document.createElement('div');
      viewport.className = 'presentation-viewport';
      
      const scaler = document.createElement('div');
      scaler.className = 'presentation-scaler';
      
      slideshow.parentNode.insertBefore(viewport, slideshow);
      viewport.appendChild(scaler);
      scaler.appendChild(slideshow);

      scaler.appendChild($("slide-counter"));
      scaler.appendChild($("progress-bar"));
      const logo = $("company-logo");
      if (logo) scaler.appendChild(logo);
    }
  }
  
/* ═══════════════════════════════════════════════════════════════
                          INITIALIZATION
     ═══════════════════════════════════════════════════════════════ */

function init(newXmlString) {
  updateGroundTruth('INIT', { xmlString: newXmlString });
  
  const theme = state.xmlDoc.documentElement.getAttribute("theme") || "minimal";
  $("theme-selector").value = theme;
  applyTheme(theme);
  
  buildSlidesFromXMLDoc();
  showSlide(0, true);
  updateHUD();
  updateToggleCountButtonState();
  
  if (state.editMode && $("editor").classList.contains("active")) {
    setupEditorUI();
  }
  
  if (!state.editMode) {
    requestWakeLock();
  }
}
  
  // Main entry point
  return async function() {
    // Discover and load themes
    await discoverThemes();
    
    // Setup event handlers
    setupEventHandlers();
    
    // Setup 16:9 aspect ratio
    wrapSlideshowFor16x9();
    
    // Handle URL parameters or initialize normally
    handleURLParameters();
    
    // Setup editor if in edit mode
    if (state.editMode) {
      $("editor").classList.add("active");
      setupEditorUI();
    }
  };
})();

// Start the application
tufteSlideshowApp();
</script>
</body>
</html>